var store = [{
        "title": "Java Trivia Questions",
        "excerpt":"Notes taken from: JavaTpoint Side Notes:   No need to remove unreferenced objects because there is Automatic Garbage Collection in java.  Java is secured because:          No explicit pointer      Java Programs run inside virtual machine sandbox      There is exception handling and type checking mechanism in java (Java is a statically typed language).        In C programming, int data type occupies 2 bytes of memory for 32-bit architecture and 4 bytes of memory for 64-bit architecture. But in java, it occupies 4 bytes of memory for both 32 and 64 bit architectures.  Whenever you write java command on the command prompt to run the java class, an instance of JVM is created.  Java Stack stores frames.It holds local variables and partial results, and plays a part in method invocation and return. Each thread has a private JVM stack, created at the same time as thread. A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes.  There are three types of variables in java: local, instance and static.  In java programming, multiple and hybrid inheritance is supported through interface only  super() can be used to invoke immediate parent class constructor.  super() is added in each class constructor automatically by compiler if there is no super() or this().  Runtime polymorphism can’t be achieved by data members.  An object is an instance of particular java class, but it is also an instance of its superclass.  If there is any abstract method in a class, that class must be abstract.  If you are extending any abstract class that have abstract method, you must either provide the implementation of the method or make this class abstract.  Abstraction in Java can be achieved through abstract classes or interfaces. Interface provides full abstraction because it is just a blueprint and all methods are abstract. In an abstract class, some methods may not be abstract.  Since Java 8, interface can have default and static methods  The java compiler adds public and abstract keywords before the interface method. More, it adds public, static and final keywords before data members.  Since Java 8, we can have method body in interface. But we need to make it default method.  Since Java 8, we can have static method in interface.  If you don’t handle exception, before terminating the program, JVM executes finally block(if any).  For each try block there can be zero or more catch blocks, but only one finally block.  The finally block will not be executed if program exits(either by calling System.exit() or by causing a fatal error that causes the process to abort).  String objects are stored in a special memory area known as string constant pool.  To create the singleton class, we need to have static member of class, private constructor and static factory method.Object-oriented Object-oriented means we organize our software as a combination of different types of objects that incorporates both data and behaviour.Object-oriented programming(OOPs) is a methodology that simplify software development and maintenance by providing some rules. Basic concepts of OOPs are:   Object  Class  Inheritance  Polymorphism  Abstraction  EncapsulationPlatform-Independent A platform is the hardware or software environment in which a program runs. There are two types of platforms software-based and hardware-based. Java provides software-based platform. The Java platform differs from most other platforms in the sense that it is a software-based platform that runs on the top of other hardware-based platforms. It has two components:   Runtime Environment  API(Application Programming Interface)Java code can be run on multiple platforms e.g. Windows, Linux, Sun Solaris, Mac/OS etc. Java code is compiled by the compiler and converted into bytecode. This bytecode is a platform-independent code because it can be run on multiple platforms i.e. Write Once and Run Anywhere(WORA). Multi-threading in Java A thread is like a separate program, executing concurrently. We can write Java programs that deal with many tasks at once by defining multiple threads. The main advantage of multi-threading is that it doesn’t occupy memory for each thread. It shares a common memory area. Diff between C++ and Java https://www.javatpoint.com/cpp-vs-java Q.  What happens at runtime and compile time? Q. **Comparison of JRE, JDK, JVM Q. Why char uses 2 byte in java and what is \\u0000 ? It is because java uses Unicode system than ASCII code system. The \\u0000 is the lowest range of Unicode system. What is difference between object oriented programming language and object based programming language? Object based programming languages follow all the features of OOPs except Inheritance. Examples of object based programming languages are JavaScript, VBScript etc. What is constructor? Constructor is just like a method that is used to initialize the state of an object. It is invoked at the time of object creation. **Does constructor return any value? Yes, that is current class instance (You cannot use return type yet it returns a value). **What is a Java static block? Is used to initialize the static data member.It is executed before main method at the time of classloading. What is Inheritance?   Inheritance in java is a mechanism in which one object acquires all the properties and behaviors of parent object.  The idea behind inheritance in java is that you can create new classes that are built upon existing classes. When you inherit from an existing class, you can reuse methods and fields of parent class, and you can add new methods and fields also.  Inheritance represents the IS-A relationship, also known as parent-child relationship.What is Aggregation? Has-A relationship. When an object of one class is instantiated in another class. When use Aggregation? Code reuse is best achieved by aggregation when there is no is-a relationship.Inheritance should be used only if the relationship is-a is maintained throughout the lifetime of the objects involved; otherwise, aggregation is the best choice. Method Overriding If subclass (child class) has the same method as declared in the parent class, it is known as method overriding in java. Can we override static method? No, you can’t override the static method because they are the part of class not object. What is covariant return type?   overriding a method by just changing the return type. (when return type is non-primitive).Java final variable If you make any variable as final, you cannot change the value of final variable(It will be constant). Java final method If you make any method as final, you cannot override it. Java final class If you make any class as final, you cannot extend it. **What is blank or uninitialized final variable? A final variable that is not initialized at the time of declaration is known as blank final variable. If you want to create a variable that is initialized at the time of creating object and once initialized may not be changed, it is useful. For example PAN CARD number of an employee. It can be initialized only in constructor. **What is static blank final variable A static final variable that is not initialized at the time of declaration is known as static blank final variable. It can be initialized only in static block. What is Polymorphism? Polymorphism in java is a concept by which we can perform a single action by different ways. There are two types of polymorphism in java: compile time polymorphism and runtime polymorphism. We can perform polymorphism in java by method overloading and method overriding. ** If you overload static method in java, it is the example of compile time polymorphism. Here, we will focus on runtime polymorphism in java Runtime polymorphism or Dynamic Method Dispatch is a process in which a call to an overridden method is resolved at runtime rather than compile-time Upcasting When reference variable of Parent class refers to the object of Child class, it is known as upcasting Upcasting + overriding = runtime polymorphism Java Runtime Polymorphism with Data Member ** Method is overridden not the datamembers, so runtime polymorphism can’t be achieved by data members.In the example given below, both the classes have a datamember speedlimit, we are accessing the datamember by the reference variable of Parent class which refers to the subclass object. Since we are accessing the datamember which is not overridden, hence it will access the datamember of Parent class always. Static binding When type of the object is determined at compiled time(by the compiler), it is known as static binding. If there is any private, final or static method in a class, there is static binding. Dynamic binding When type of the object is determined at run-time, it is known as dynamic binding. Abstract class in Java A class that is declared with abstract keyword, is known as abstract class in java. It can have abstract and non-abstract methods (method with body). It needs to be extended and its method implemented. It cannot be instantiated. Abstract method A method that is declared as abstract and does not have implementation is known as abstract method. Interface in Java   An interface in java is a blueprint of a class. It has static constants and abstract methods.  The interface in java is a mechanism to achieve abstraction.  There can be only abstract methods in the java interface not method body.  It is used to achieve abstraction and multiple inheritance in Java.  Java Interface also represents IS-A relationship.-** It cannot be instantiated just like abstract class.**Q. Why use Java interface? There are mainly three reasons to use interface:   It is used to achieve abstraction.  By using interface, we can support the functionality of multiple inheritance.  It can be used to achieve loose coupling.Q. Can you declare an interface method static? No, because methods of an interface is abstract by default, and static and abstract keywords can’t be used together. Multiple inheritance in Java by interface If a class implements multiple interfaces, or an interface extends multiple interfaces i.e. known as multiple inheritance. Multiple inheritance is not supported through class in java but it is possible by interface, why? As we have explained in the inheritance chapter, multiple inheritance is not supported in case of class because of ambiguity. But it is supported in case of interface because there is no ambiguity as implementation is provided by the implementation class. Q. **Can we define private and protected modifiers for variables in interfaces? No, they are implicitly public. Q. When can an object reference be cast to an interface reference? An object reference can be cast to an interface reference when the object implements the referenced interface. Q. What is package? A package is a group of similar type of classes, interfaces and sub-packages. It provides access protection and removes naming collision. **What is the difference between import and static import? The import allows the java programmer to access classes of a package without package qualification whereas the static import feature allows to access the static members of a class without the class qualification. The import provides accessibility to classes and interface whereas static import provides accessibility to static members of the class. Q. What is Exception Handling? Exception Handling is a mechanism to handle runtime errors. Java finally block   Java finally block follows try or catch block.  Java finally block is always executed whether exception occurs or not and whether it is handled or not.  Java finally block is a block that is used to execute important code such as closing connection, stream etc.Q. **Why are string objects immutable in Java? Because java uses the concept of string literal. Suppose there are 5 reference variables, all refer to one object “sachin”.If one reference variable changes the value of the object, it will be affected to all the reference variables. That is why string objects are immutable in java. Each time you create a string literal, the JVM checks the string constant pool first. If the string already exists in the pool, a reference to the pooled instance is returned. If string doesn’t exist in the pool, a new string instance is created and placed in the pool. For example: String s1=”Welcome”;String s2=”Welcome”;//will not create new instance Q. Why java uses concept of string literal? To make Java more memory efficient By new keyword String s=new String(“Welcome”); //creates two objects and one reference variable In such case, JVM will create a new string object in normal(non pool) heap memory and the literal “Welcome” will be placed in the string constant pool. The variable s will refer to the object in heap(non pool). StringBuffer Java StringBuffer class is thread-safe i.e. multiple threads cannot access it simultaneously (synchronized). So it is safe and will result in an order. StringBuilder The Java StringBuilder class is same as StringBuffer class except that it is non-synchronized. It is also more efficient than StringBuffer. **Multi-threading Multithreading in java is a process of executing multiple threads simultaneously. Thread is basically a lightweight sub-process, a smallest unit of processing. Multiprocessing and multithreading, both are used to achieve multitasking. But we use multithreading than multiprocessing because threads share a common memory area. They don’t allocate separate memory area so saves memory, and context-switching between the threads takes less time than process. Life-cycle of threads The life cycle of the thread in java is controlled by JVM. The java thread states are as follows:   New  Runnable  Non-Runnable (Blocked)  TerminatedHow to create thread There are two ways to create a thread:   By extending Thread class  By implementing Runnable interface. (If you are not extending the Thread class,your class object would not be treated as a thread object.So you need to explicitely create Thread class object.We are passing the object of your class that implements Runnable so that your class run() method may execute)**What if we call run() method directly instead start() method? Each thread starts in a separate call stack.Invoking the run() method from main thread, the run() method goes onto the current call stack rather than at the beginning of a new call stack. refer this: https://www.javatpoint.com/what-if-we-call-run()-method-directly Points to remember for Daemon Thread in Java   It provides services to user threads for background supporting tasks.  It has no role in life than to serve user threads.  Its life depends on user threads.  It is a low priority thread.  If you want to make a user thread as Daemon, it must not be started otherwise it will throw IllegalThreadStateException.Java Thread pool represents a group of worker threads that are waiting for the job and reuse many times. In case of thread pool, a group of fixed size threads are created. A thread from the thread pool is pulled out and assigned a job by the service provider. After completion of the job, thread is contained in the thread pool again. Advantage of Java Thread Pool Better performance It saves time because there is no need to create new thread. Java Garbage Collection   In java, garbage means unreferenced objects.  Garbage Collection is process of reclaiming the runtime unused memory automatically.      In other words, it is a way to destroy the unused objects.     The finalize() method is invoked each time before the object is garbage collected. This method can be used to perform cleanup processing.  The Garbage collector of JVM collects only those objects that are created by new keyword. So if you have created any object without new, you can use finalize method to perform cleanup processing  The gc() method is used to invoke the garbage collector to perform cleanup processing.Synchronization in Java Synchronization in java is the capability to control the access of multiple threads to any shared resource. Java Synchronization is better option where we want to allow only one thread to access the shared resource.   Mutual Exclusive  Mutual Exclusive helps keep threads from interfering with one another while sharing data. This can be done by three ways in java:          by synchronized method      by synchronized block      by static synchronization      Concept of Lock in Java Synchronization is built around an internal entity known as the lock or monitor. Every object has an lock associated with it. By convention, a thread that needs consistent access to an object’s fields has to acquire the object’s lock before accessing them, and then release the lock when it’s done with them. Synchronized block in java Synchronized block can be used to perform synchronization on any specific resource of the method. Suppose you have 50 lines of code in your method, but you want to synchronize only 5 lines, you can use synchronized block. Advantage of static synchronization method If you make any static method as synchronized, the lock will be on the class not on object. Suppose there are two objects of a shared class(e.g. Table) named object1 and object2.In case of synchronized method and synchronized block there cannot be interference between t1 and t2 or t3 and t4 because t1 and t2 both refers to a common object that have a single lock.But there can be interference between t1 and t3 or t2 and t4 because t1 acquires another lock and t3 acquires another lock.I want no interference between t1 and t3 or t2 and t4.Static synchronization solves this problem. *Enums in Java https://www.javatpoint.com/enum-in-java Garbage Collection in Java   Garbage collection is the phrase used to describe automatic memory management in Java.  it’s typical for memory to be used to create a stack, a heap, in Java’s case constant pools, and method areas. The heap is that part of memory where Java objects live, and it’s the one and only part of memory that is in any way involved in the garbage collection process.  When the garbage collector runs, its purpose is to find and delete objects that cannot be reached.  An object is eligible for garbage collection when no live thread can access it.","categories": ["Tech"],
        "tags": [],
        "url": "http://localhost:4000/tech/Java-Trivia/",
        "teaser":null},{
        "title": "System Design and Scalability",
        "excerpt":"  The idea of these questions is to have a discussion about the problem at hand. What’s important for the interviewer is the process, which you use to tackle the problem. Remember that there is no one right answer. A system can be built in different ways. The important thing is to be able to justify your ideas. System design questions require a combination of the right strategy and knowledge. By strategy we mean a way to approach the problem at an interview. Important Links       Harvard Video         Extensive Prep         Differential Synchronization         Scalability for Dummies         REST principles         HiredInTech         Database sharding         Database Indexing     ​   System Design Process Constraints and Use Cases   The very first thing you should do with any system design question is to clarify the system’s constraints and to identify what use cases the system needs to satisfy.  Usually, part of what the interviewer wants to see is if you can gather the requirements about the problem at hand, and design a solution that covers them well. Never assume things that were not explicitly stated.  Constraints consist of either the amount of traffic or the amount of data that our system needs to handle      Find the data per second(read and written), and memory required           Imagine this is your startup idea and you are designing your system. This way, you would eliminate many assumptions that you would normally make when you try and replicate a well-established system like bit.ly or Google.       Abstract Design   Once you’ve scoped the system you’re about to design, you should continue by outlining a high-level abstract design. The goal of this is to outline all the important components that your architecture will need.  Sketch your main components and the connections between them. If you do this, very quickly you will be able to get feedback if you are moving in the right direction. Of course, you must be able to justify the high-level design that you just drew.  Don’t get lured to dive deep into some particular aspect of the abstract design. Not yet. Rather, make sure you sketch the important components and the connections between them. Justify your ideas in front of the interviewer and try to address every constraint and use case.  Usually, this sort of high-level design is a combination of well-known techniques, which people have developed. You have to make sure you are familiar with what’s out there and feel comfortable using this knowledge.Understanding Bottlenecks   Most likely your high-level design will have one or more bottlenecks given the constraints of the problem. This is perfectly ok. You are not expected to design a system from the ground up, which immediately handles all the load in the world. It just needs to be scalable, in order for you to be able to improve it using some standard tools and techniques.  Now that you have your high-level design, start thinking about what bottlenecks it has. Perhaps your system needs a load balancer and many machines behind it to handle the user requests. Or maybe the data is so huge that you need to distribute your database on multiple machines. What are some of the downsides that occur from doing that? Is the database too slow and does it need some in-memory caching?  It may be the case that the interviewer wants to direct the discussion in one particular direction. Then, maybe you won’t need to address all the bottlenecks but rather talk in more depth about one particular area. In any case, you need to be able to identify the weak spots in a system and be able to resolve them.  Remember, usually each solution is a trade-off of some kind. Changing something will worsen something else. However, the important thing is to be able to talk about these trade-offs, and to measure their impact on the system given the constraints and use cases defined.Scaling the Abstract Design   There is a common set of scalability principles that you need to know. Knowing what they are, understanding how they are used, and being able to discuss their pros and cons is what scalability at interviews is all about.","categories": ["Tech"],
        "tags": [],
        "url": "http://localhost:4000/tech/System-Design-and-Scalability/",
        "teaser":null},{
        "title": "Android Notes",
        "excerpt":"Notes taken during Grow with google Android Dev course on Udacity General Notes       Important project settings can be found in File —&gt; Project Structure —&gt; app —&gt; flavors         HAXM is the kernel driver used for hardware virtualization by AVDs on Windows and Mac     ​   Lesson 2 What happens when you hit run in Android Studio? When you hit run in Android studio, first the code is compiled into byte code that can be run in the run time on the device. Gradle builds this code and packages this byte code along with the application’s resources into an android application package (.apk) file (apk is a specialized zip format). Android studio then signs it and pushes it to the device using the android debug bridge (adb). What is Gradle? Gradle is the build system of choice for Android Studio. Because of that, there’s various functionality available within the platform. When you make a project, there are a few gradle build scripts automatically generated for you. Gradle scripts are also run before running the project, if anything has changed since the last build. A gradle task represents a single, atomic piece of work for a build. Components An Android Application is a collection of components that interact with each other. There are 4 types of components that make up an app:   Activity - window that your app uses to receive events from the system  Service  Content Providers  Broadcast ReceiversAndroid knows about each of these because they are registered in the **android manifest.** Activity   An activity is a single focused thing that the user can do. Activities are responsible for creating the window that your application uses to draw and receive events from the system.  From the user’s perspective, an application is a series of linked activities, starting from the one that is started from the launcher.  An activity is registered with the launcher by specifying an intent filter in the application —&gt; activity tag in the android manifest file.  An activity creates views to show the user information, and to let the user interact with the activity. An activity determines what views to create (and where to put them), by reading an XML layout file. setContentView(R.layout.activity_main) causes the XML layout to be inflated, converting everything in the XML file to a heirarchy of view objects in memory.Views       Views are a class in the Android UI framework. They occupy a rectangular area on the screen and are responsible for drawing and handling events.         There are two major categories of views: UI Components and Container Views.         Examples of Container Views:        How do the XML Layouts relate to the Java Activites? After you create your XML Layout you need to associate it with your activity. This is done in the onCreate method of the Activity using the method setContentView. You pass a reference to the layout file as R.layout.name_of_layout The R Class When your application is compiled the R class is generated. It creates constants that allow you to dynamically identify the various contents of the res folder, including layouts. setContentView() So what is the setContentView method doing? It inflates the layout. Essentially what happens is that Android reads your XML file and generates Java objects for each of the tags in your layout file. You can then edit these objects in the Java code by calling methods on the Java objects. Responsive Design The android UI needs to scale to different resolutions and device widths used by various devices. FrameLayout, ConstraintLayout and LinearLayout are the 3 basic layouts we should be using. Always use the simplest layout that gets the job done.   FrameLayout: use for simple layouts when we have only one child view. (example a list view which would fill the entire screen content area)  LinearLayout: use for stacking views horizontally or vertically against each other, and to break up the display proporationally between them.  ConstraintLayout: This is a more complicated, but a very powerful layout. We can position each child view relative to the parent or relative to each other.ConstraintLayout Basics Useful links: google codelabs building responsive UI with constraint layout a. Use a baseline constraint By using a baseline constraint, you can vertically align elements that have text, such as a TextView, EditText, or Button, so that the text baselines are aligned. Use baseline constraints to align elements that use different text sizes. Baseline constraints are also useful for aligning the text baselines of elements of different sizes.  Click the ab button to show the text baseline. Then click and drag from the TextView’s baseline, which is blinking in green, to the baseline of the Plain Text element, as shown in the following animated figure b. The Infer Constraints tool The Infer Constraints tool infers, or figures out, the constraints you need to match a rough layout of elements. It works by taking into account the positions and sizes of the elements. Drag elements to the layout in the positions you want them, and use the Infer Constraints tool to automatically create the constraint connections. - What’s the difference between Inference and Autoconnect? The Infer Constraints  tool calculates and sets constraints for all of the elements in a layout, rather than just the selected element. It bases its calculations on inferred relationships between the elements.The Autoconnect  tool creates constraint connections for a selected element to the element’s parent. c. Use ratios to size elements You can quickly resize elements by aspect ratio if at least one of the element’s dimensions is set to match constraints. d. Constrain to a guideline You can add a vertical or horizontal guideline to which you can constrain views, and the guideline will be invisible to app users. You can position the guideline within the layout based on either dp units or percent, relative to the layout’s edge. To create a guideline, click Guidelines in the toolbar, and then click either Add Vertical Guideline or Add Horizontal Guideline. Drag the dotted line to reposition it and click the circle at the edge of the guideline to toggle the measurement mode. e. Use barriers to align elements that dynamically vary in size Barriers allow you to specify a constraint based on multiple UI elements. You’ll want to use barriers any time that multiple elements could dynamically change their size based on user input or language. The barrierDirection is an attribute that controls how the barrier is positioned relative to the referenced views. A constraint to a barrier is just like a constraint to another element. However, users don’t see barriers, and barriers don’t add a level to the app’s view hierarchy, which means they don’t affect performance. f. Use chains to position multiple elements A chain is a group of elements that are linked to each other with bi-directional position constraints. When you create a chain, you can position all of the elements as a group. For example, you can center all of your chained elements as if they were a single element. Some chain modes:   Packed: The elements are packed together, as shown above.  Spread: The elements are spread out over the available space.  Spread inside: Similar to Spread, but the endpoints of the chain are not spread out.Lesson 3 Logging A good practice is to have the class name as the TAG in logs. Log levels: WTF, ERROR, WARN, INFO, DEBUG, VERBOSE ","categories": ["Tech"],
        "tags": [],
        "url": "http://localhost:4000/tech/Android-Notes/",
        "teaser":null},{
        "title": "iOS Notes",
        "excerpt":"iOS Training - Big Nerd Ranch Instructor: Zachary Waldowski (zachary@bignerdranch.com) General Notes   Xcode comes with an iOS simulator, not emulator . The difference between emulators and simulators is that emulators mimic the software and hardware environments found on actual devices. Simulators, on the other hand, only mimic the software environment; they otherwise have access to all of the host system’s (the laptop’s) hardware resources such as disk space, memory and processor speed.  Main.storyboard –&gt; description of UI in the application.  control + drag to activate layout constraints between 2 views  alt + click –&gt; see data type  To connect views to their references in the code, go to Controller View, and in the connections inspector, connect the variables declared in code to the UI elements.  To create actions for methods, drag the action from connections inspector to the code to create a new action. It’s easier to use the Assistant editor to see both the ViewController.swift and the Main.storyboard.  Vertical spacing is similar to relative positioning. It is relative to two views.  Swift is a statically typed and a strongly typed language.  Unlike Android, the app or the activity is not relaunched when the screen is rotated. This is because iOS has separate view heirarchy process and a separate view layout process. Layout constraints are applied during the view layout process.  Many iOS frameworks are still written in Objective-C even though we interact with them through Swift.  The @discardableResult annotation before the func keyword in the function definition means that a caller of this function is free to ignore the result of calling this function.  When writing iOS applications, it is important to treat each UIViewController as its own little world. The stuff that has already been implemented in Cocoa Touch will do the heavy lifting.  Instead of assigning a value to the property directly, the value is sometimes set using a closure. Using a closure like this allows you to set the value for a variable or constant that requires multiple lines of code, which can be very useful when configuring objects. This makes your code more maintainable because it keeps the property and the code needed to generate the property together.MVC iOS follows Model-View-Controller pattern. In the MVC design pattern, which iOS developers do their best to follow, each class falls into exactly one of the following categories:   model: holds data and knows nothing about the UI  view: is visible to the user and knows nothing about the model objects  controller: keeps the UI and the model objects in sync and controls the flow of the application Sample app code: ////  ViewController.swift//  Quiz////  Created by Parth Mehta on 3/18/19.//  Copyright © 2019 Big Nerd Ranch. All rights reserved.//import UIKitclass ViewController: UIViewController {        let questions: [String] = [        \"From what is congnac made?\",        \"What is 7 + 7?\",        \"What is the capital of Vermont?\"    ]    let answers: [String] = [        \"Who knows\",        \"14\",        \"Montepelier\"    ]        var currentQuestionIndex = 0;    @IBOutlet var questionLabel: UILabel?    @IBOutlet var answerLabel: UILabel?        override func viewDidLoad() {        super.viewDidLoad()                let question = questions[currentQuestionIndex]        questionLabel?.text = question    }    @IBAction func onTapShowAction(_ sender: Any) {        let answer = answers[currentQuestionIndex]        answerLabel?.text = answer    }        @IBAction func onnTapNextQuestion(_ sender: Any) {        answerLabel?.text = \"????\"        currentQuestionIndex = (currentQuestionIndex + 1) % questions.count                let question = questions[currentQuestionIndex]        questionLabel?.text = question    }} Only this much code to create the question answer app!! :D Swift Basics Optionals and Optional Binding   An optional lets you express the possibility that a variable may not store a value at all. The value of an optional will either be an instance of the specified type or nil.  Allows the developer to indicate that an instance of any data type may be nil.  Note that before using the optional variables like normal variables, you must unwrap the optional and address the possibility of it being nil.  Use ‘if let’ to check values and conditionally perform logic (optional binding).  Two ways of unwrapping an optional variable: optional binding and forced unwrapping.  Subscripting dictionaries: Recall that subscripting an array beyond its bounds causes a trap. Dictionaries are different. The result of subscripting a dictionary is an optional:let titles = [\"Leader\": \"Dear Leader\", \"Commandante\": \"Commandante\", \"Brightlord\": \"Brightlord\"]var optionalTitle: String? = titles[\"Leader\"]var greeting = \"Hello\"if let title = optionalTitle {    greeting += \" \\(title)\"} // Note that here, we convert the optional optionalTitle to a String// greeting += \" \\(optionalTitle!)\" // crash if optionalTitle  == nilCollections: Array var bros: [String] = [\"Matt\",\"Scott\",\"Josh\",\"Nick\"] // could also infer typebros += [\"Brian\"] // [\"Matt\",\"Scott\",\"Josh\",\"Nick\",\"Brian\"]bros[3] = \"Brandon\" // [\"Matt\",\"Scott\",\"Josh\",\"Brandon\",\"Brian\"]bros.removeAtIndex(4) // [\"Matt\",\"Scott\",\"Josh\",\"Brandon\"]Collections: Dictionary var etBroHome: [String: String] = [\"Matt\": \"GA\",\"Scott\": \"DC\"]etBroHome[\"Brian\"] = \"GA\" // [\"Matt\": \"GA\",\"Scott\": \"DC\",\"Brian: GA\"]if let oldMattSt = etBroHome.updateValue(\"CA\", forKey:\"Matt\") {    print(\"Old state: \\(oldMattSt)\")}Control Flow: Conditional Statements ‘if’ executes a set of statements if expression evalutates to true var swiftIsAwesome: Bool = trueif swiftIsAwesome {    print(\"Duh\")} else {    print(\"Something went wrong.\")}‘switch’ statements compare a value against a number of cases // Very imp thing to note is the absence of break statements. Swift break statements don't fall through by default. You can however, specify it to fall through. You can't fall through multiple cases though.let favoriteFood: String = \"Cookie Pie\"var comment: Stringswitch favoriteFood {    case \"Vegetables\":        comment = \"Ew\"    case \"Fruit\":        comment = \"Okay...\"    case let x where x.hasSuffix(\"Pie\"): // this assigns x = favoriteFood first        comment = \"\\(x) sounds good!\"    default:        comment = \"Tell me more...\"}Control Flow: For-in Loop // Note that there is not manual version of the for-loop. If we need to use a manual version, we can use a while loop.for index in 1..&lt;5 {    print(index) // 1 2 3 4}for index in 1...5 {    print(index) // 1 2 3 4 5}var things = [\"socks\",\"bannana\",\"ennui\"]for word in things {    print(word)}var etBroHome = [\"Matt\": \"GA\",\"Scott\": \"DC\"] // infers typefor (name, state) in etBroHome {    print(name, state) // (Matt, GA); (Scott, DC)}Functions // pay attention to the return type and the external parameter namefunc printNumber(number: Int) {    print(number)}printNumber(5) // logs 5 to consolefunc equalToTen(myNumber number: Int) -&gt; Bool {     // myNumber is an explicitly named external parameter    return number == 10}equalToTen(myNumber: 5) // falsefunc hasMatches(list: [Int], condition: (Int -&gt; Bool)) -&gt; (Bool, Int) {    var count = 0    var hasMatch = false    for item in list {        if condition(item) {\t\t\tcount += 1         }    }    hasMatch = count != 0    return (hasMatch, count)}var numbers = [10, 20, 21, 10]print(\"Has matches: \\(hasMatches(numbers, condition: equalToTen))\") // (true, 2)Closures var moreNumbers = [10,3,11,24]let newNumbers = moreNumbers.map {    (number) -&gt; Int in   \t\t\t// in is just a seperator that separates params from \t\t\t\t\t\t\t\t\t\tthe function body in closures    return number % 2 != 0 ? 0 : number * 3}print(newNumbers) // [30,0,0,72]Structs struct House {    var hotTubs: Int    func describeHouse() -&gt; String { return \"House has \\(hotTubs) hot tubs!\" }}var myHouse = House(hotTubs: 4)print(myHouse.describeHouse()) // House has 4 hot tubs!Classes class Parent: Person {    var hasChildren: Bool    static var hasStaticChildren: Bool \t\t// class level variable    init(hasChildren: Bool) {        // constructor. Note that all inits are functions.        // You can also have destructors called dinit()        self.hasChildren = hasChildren    }    class func exampleTypeMethod() {        // class level method        // like a static method in Java?    \t// stuff here    }    func exampleInstanceMethod() {        // instance level method    \t// stuff here    }}var john = Parent(hasChildren: true)Parent.exampleTypeMethod()john.exampleInstanceMethod()// The way we assign innitialisation values are safer in Swiftclass Parent: Person {    var hasChildren: Bool    init(name: String, heightInMeters: Double, hasChildren: Bool) {        self.hasChildren = hasChildren        super.init(name: name, heightInMeters: heightInMeters)    }}var john = Parent(name: \"John\", heightInMeters: 1.8, hasChildren: true)Differences between Classes and Structs in Swift   Class instances are shared in memory.  Class instances are copied by reference, struct instances are copied by value, i.e. Each copy of a struct is a new instance.  Contents of classes are mutable by all instances, irrespective of whether they are defined as let  or const, unlike in structs.  Structs have default initializers, unlike classes. Classes need initializers to be defined by us.Properties struct Meal {    var time: Int    var duration: Int}struct Day {    let name: String    var breakFast: Meal    var intervalBetweenMeals: Int    var lunch: Meal {\t\tget {            let time = breakFast.time + breakFast.duration + intervalBetweenMeals            let duration = breakFast.duration            return Meal(time: time, duration: duration)        }        set(newLunch) {            breakFast.time = newLunch.time - intervalBetweenMeals            breakFast.duration = newLunch.duration        }    }}let aMeal = Meal(time: 8, duration: 1)var aDay = Day(name: \"Monday\", breakFast: aMeal, intervalBetweenMeals: 3)aDay.lunch // name = Monday; time = 12; duration = 1Protocols // Protocols are similar to interfaces in Java and you can conform to multiple protocols (this is how you can achieve multiple inheritance in Swift).protocol ExampleProtocol {    mutating func doSomething()    var aReadonlyIntProperty: Int { get }    var aReadwriteStringProperty: String { get set }}class SomeClass: ExampleProtocol {    func doSomething     {         // code here    }    // getter for aReadOnlyIntProperty here    // getter and setter for aReadWriteStringProperty here}Extensions // add custom vars and methods to the basic types in Swift.// Note the visibility of these extensions is across the entire project.extension Int: ExampleProtocol {    var timesFive: Int {        return self * 5    }    mutating func doSomething {    // code here     }}5.doSomething5.timesFive // 25Generics func swapTwoValues&lt;T&gt;(inout a: T, inout b: T) { \tlet temporaryA = a\ta = b    b = temporaryA         // (a, b) = (b, a)}swapTwoValues(&amp;someInt, &amp;anotherInt)swapTwoValues(&amp;someString, &amp;anotherString)protocol RemoveInstance {    typealias ItemType    mutating func removeInstance(item: ItemType)}Views Basics Views Views are objects that are visible to the user, like buttons, text fields, and sliders. View objects make up an application’s UI. A view:   is an instance of UIView or one of its subclasses  knows how to draw itself  can handle events, like touches  exists within a hierarchy of views whose root is the application’s windowThe View Hierarchy Every application has a single instance of UIWindow that serves as the container for all the views in the application. UIWindow is a subclass of UIView, so the window is itself a view. The window is created when the application launches. Once the window is created, other views can be added to it.  Views and Frames When the application is launched, the view for the initial view controller is added to the root-level window. This view controller is represented by the ViewController class defined in ViewController.swift. Creating a view programmatically. let rect = CGRect(x: 0, y: 0, width: 20, height: 20)let squareView = UIView(frame: rect)someOtherView.addSubview(squareView)  Note: that these values are in points, not pixels. If the values were in pixels, then they would not be consistent across displays of different resolutions (i.e., Retina versus non-Retina). A point is a relative unit of a measure; it will be a different number of pixels depending on how many pixels are in the display. Sizes, positions, lines, and curves are always described in points to allow for differences in display resolution. Frame Vs. Bounds Frame boundaries are the boundaries of the view, from where to where the view is displayed. Bounds, on the other hand are the limits of the content of the view. Think about scrolling in a maps view. The alignment rectangle is very similar to the frame. In fact, these two rectangles are often the same. Whereas the frame encompasses the entire view, the alignment rectangle only encompasses the content that you wish to use for alignment purposes. You cannot define a view’s alignment rectangle directly. You do not have enough information (like screen size) to do that. Instead, you provide a set of constraints. Taken together, these constraints enable the system to determine the layout attributes, and thus the alignment rectangle, for each view in the view hierarchy.  What other information does a view have? // Hierarchy (Painter's method):var window: UIWindow? { get }var superview: UIView? { get }var subviews: [UIView] { get }func addSubview(_ view: UIView)func insertSubview(_ view: UIView, at index: Int)// Location of view:var frame: CGRectvar bounds: CGRect// Display properties:var backgroundColor: UIColor?var hidden: Boolvar alpha: CGFloatAuto Layout Auto Layout is a crucial technology for every iOS developer. It helps you create flexible layouts that work across a range of devices and interface sizes. It also takes a lot of practice to master.  Constraints Menu In addition to using cntrl+drag to create relative positioning between 2 views, we also define constraints to the view.   If a view does not have any siblings in the specified direction, then the nearest neighbor is its superview, also known as its container. Align Menu  View Controller A view controller is an instance of a subclass of UIViewController. A view controller manages a view hierarchy. It is responsible for creating view objects that make up the hierarchy and for handling events associated with the view objects in its hierarchy. Just think of a view controller as one view hierarchy. When an app switches between view controllers, it just means that it is switching between two different view heirarchies. The View of a View Controller As subclasses of UIViewController, all view controllers inherit an important property: var view: UIView!This property points to a UIView instance that is the root of the view controller’s view hierarchy. When the root  view of a view controller is added as a subview of the window, the view controller’s entire view hierarchy is added .  A view controller’s view is not created until it needs to appear on the screen. This optimization is called lazy loading, and it can conserve memory and improve performance. There are two ways that a view controller can create its view hierarchy:   in Interface Builder, by using an interface file such as a storyboard  programmatically, by overriding the UIViewController method loadView()  NOTE: Although a storyboard can have many view controllers, each storyboard file has exactly one initial view controller. The initial view controller acts as an entry point into the storyboard. How does UIWindow handle the view controllers? UIWindow has a rootViewController property. When a view controller is set as the window’s rootViewController, that view controller’s view gets added to the window’s view hierarchy. When this property is set, any existing subviews on the window are removed and the view controller’s view gets added to the window with the appropriate Auto Layout constraints. Each application has one main interface, a reference to a storyboard. When the application launches, the initial view controller for the main interface gets set as the rootViewController of the window. The main interface for an application is set in the project settings. In the General tab of the project settings, find the Deployment Info section. Here you will see the Main Interface setting. If it is set to Main, for example, it corresponds to Main.storyboard. Tab Bar Controllers UITabBarController keeps an array of view controllers. It also maintains a tab bar at the bottom of the screen with a tab for each view controller in its array. Tapping on a tab results in the presentation of the view of the view controller associated with that tab. UITabBarController is itself a subclass of UIViewController. A UITabBarController’s view is a UIView with twoprimary subviews: the tab bar and the view of the selected view controller  Tab bar items Each tab on the tab bar can display a title and an image, and each view controller maintains a tabBarItem property for this purpose. When a view controller is contained by a UITabBarController, its tab bar item appears in the tab bar. The order of the tabs is determined by the order of the view controllers within the tab bar controller’s viewControllers array. Accessing subviews Often, you will want to do some extra initialization or configuration of subviews defined in Interface Builder before they appear to the user. So where can you access a subview? There are two main options, depending on what you need to do. The first option is the viewDidLoad() method. This method is called after the view controller’s interface file is loaded, at which point all of the view controller’s outlets will reference the appropriate objects. The second option is another UIViewController method, viewWillAppear. This method is called just before a view controller’s view is added to the window. Which should you choose? Override viewDidLoad() if the configuration only needs to be done once during the run of the app. Override viewWillAppear if you need the configuration to be done each time the view controller’s view appears onscreen. Interacting with View Controllers and Their Views Let’s look at some methods that are called during the lifecycle of a view controller and its view. Some of these methods you have already seen, and some are new.       init(coder:) is the initializer for UIViewController instances created from a storyboard. When a view controller instance is created from a storyboard, its init(coder:) gets called once.         init(nibName:bundle:) is the designated initializer for UIViewController.     When a view controller instance is created without the use of a storyboard, its init(nibName:bundle:) gets called once. Note that in some apps, you may end up creating several instances of the same view controller class. This method will get called once on each view controller as it is created.         loadView() is overridden to create a view controller’s view programmatically.         viewDidLoad() is overridden to configure views created by loading an interface file. This method gets called after the view of a view controller is created.         viewWillAppear(_:) is overridden to configure views created by loading an interface file.     This method and viewDidAppear(:)** get called every time your view controller is moved onscreen. **viewWillDisappear(:) and viewDidDisappear(_:) get called every time your view controller is moved offscreen.   Programmatic View Composition UIView has an instance method addSubview(_:) which let’s you add a child view to its subviews collec4on. Other useful methods:   bringSubview(toFront:)  sendSubview(toBack:)  removeFromSuperview()  NOTE: When using bringSubview and sendSubview, remember that the view to be brought back or sent forward is also already loaded (no lazy loading here). Programmatic Constraints   Note:             Constraints need to be added to the most recent common ancestor for the views associated with the constraint.               Creating and activating constraints are two different steps.       let leadingAlignConstraint =    view1.leadingAnchor.constraint(equalTo: view2.leadingAnchor)leadingAlignConstraint.isActive = true Layout Margin Guides Every view has a layoutMargins property that denotes the default spacing to use when laying out content. This property is an instance of UIEdgeInsets, which you can think of as a type of frame. When adding constraints, you will use the layoutMarginsGuide, which exposes anchors that are tied to the edges of the layoutMargins. The primary advantage of using the margins is that the margins can change depending on the device type (iPad or iPhone) as well as the size of the device. Using the margins will give you content that looks good on any device. let margins = view.layoutMarginsGuidelet constraint =    someView.leadingAnchor.constraint(equalTo: margins.leadingAnchor)constraint.isActive = trueLayout Safe Area Guides View instances have a property to assist with layout content: the safeAreaLayoutGuide. This layout guide represents the rectangular extent to which the a view will be visible on screen. Using safeAreaLayoutGuide will allow your content to not underlap the status bar at the top of the screen or the tab bar at the bottom of the screen. Layout guides like safeAreaLayoutGuide expose anchors that you can use to add constraints, such as : topAnchor, bottomAnchor, heightAnchor and widthAnchor. Because you want the segmented control to be under the status bar and sensor housing, you will constrain the top anchor of the safe area layout guide to the top anchor of the segmented control. let constraint =    someView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor,constant: 20)constraint.isActive = trueControls func loadView() {    ...    let button = UIButton(type: .system)    // this is similar to what we do in the interface builder by dragging and dropping.    button.addTarget(self,           action: #selector(buttonTapped(_:)),           for: .touchUpInside)    ...}func buttonTapped(_ sender: UIButton) {    // do something}Control Events  Q. When exactly is the loadview() method called? When a view controller is created, its view property is nil. If a view controller is asked for its view and its view is nil, then the loadView() method is called.   NOTE:  Apple recommends that you create and constrain your views in Interface Builder whenever possible. However, if your views are created in code, then you will need to constrain them programmatically.   NOTE: Every view has an autoresizing mask. By default, iOS creates constraints that match the autoresizing mask and adds them to the view. These translated constraints will often conflict with explicit constraints in the layout and cause an unsatisfiable constraints problem. The fix is to turn off this default translation by setting the property translatesAutoresizingMaskIntoConstraints to false. Text Input &amp; Delegation Delegation is an object-oriented approach to callbacks. A callback is a function that is supplied in advance of an event and is called every time the event occurs. Some objects need to make a callback for more than one event. For instance, the text field needs to “callback” when the user enters text as well as when the user presses the Return key. However, there is no built-in way for two (or more) callback functions to coordinate and share information. This is the problem addressed by delegation – you supply a single delegate to receive all of the event-related callbacks for a particular object. This delegate object can then store, manipulate, act on, and relay the information from the callbacks as it sees fit.  textField.delegate = self // Our controller// In our controllerfunc textFieldShouldReturn(_ textField: UITextField) -&gt; Bool {    print(textField.text)    // dismisses the keyboard and gives up the first responder status    textField.resignFirstResponder()     return true // whether to perform the default action or not? default action is nothing  in this particular case.}  Conforming to this Protocol (it’s just like an interface in Java) class MyViewController: UIViewController, UITextFieldDelegate {}  NOTE: When the text field is tapped, the method becomeFirstResponder() is called on it. This is the methodthat, among other things, causes the keyboard to appear. To dismiss the keyboard, you call the methodresignFirstResponder() on the text field.   NOTE: A property observer, is a chunk of code that gets called whenever a property’s value changes. A property observer is declared using curly braces immediately after the property declaration. Inside the braces, you declare your observer using either willSet or didSet, depending on whether you want to be notified immediately before or immediately after the property value changes, respectively. Note that property observers are not triggered when the property value is changed from within an initializer. Internalization and Localization Internationalization is making sure your native cultural information (like language, currency, date format, number format, etc.) is not hardcoded into your application. Localization is the process of providing the appropriate data in your application based on the user’s Language and Region Format settings.   NOTE: Locale knows everything about local customs.   Some formatters to keep in Mind   Date Formatters  NumberFormatter  DateComponentsFormatter  DateIntervalFormatter  MassFormatter  EnergyFormatter  LengthFormatter  Address FormatterWhen internationalizing, you ask the instance of Locale questions. But the Locale only has a few region-specific variables. This is where localization – creating application-specific substitutions for different region and language settings – comes into play. Localization usually involves either generating multiple copies of resources (like images, sounds, and interface files) for different regions and languages or creating and accessing strings tables to translate text into different languages. When you build a target in Xcode, an application bundle is created. All of the resources that you added to the target in Xcode are copied into this bundle along with the executable itself. This bundle is represented at runtime by an instance of Bundle known as the main bundle. Many classes work with the Bundle to load resources. Localizing a resource puts another copy of the resource in the application bundle. These resources are organized into language-specific directories, known as lproj directories. Each one of these directories is the name of the localization suffixed with lproj. For example, the American English localization is en_US, where en is the English language code and US is the United States of America region code, so the directory for American English resources is en_US.lproj. (The region can be omitted if you do not need to make regional distinctions in your resource files.) These language and region codes are standard on all platforms, not just iOS. When a bundle is asked for the path of a resource file, it first looks at the root level of the bundle for a file of that name. If it does not find one, it looks at the locale and language settings of the device, finds the appropriate lproj directory, and looks for the file there. Thus, just by localizing resource files, your application will automatically load the correct file. One option for localizing resource files is to create separate storyboard files and manually edit each string in each file. However, this approach does not scale well if you are planning multiple localizations. What happens when you add a new label or button to your localized storyboard? You have to add this view to the storyboard for every language. Not fun. To simplify the process of localizing interface files, Xcode has a feature called base internationalization. Base internationalization creates the Base.lproj directory, which contains the main interface files. Localizing individual interface files can then be done by creating just the Localizable.strings files. It is still possible to create the full interface files, in case localization cannot be done by changing strings alone. NSLocalizedString and strings tables In many places in your applications, you create String instances dynamically or display string literals to the user. To display translated versions of these strings, you must create a strings table. A strings table is a file containing a list of key-value pairs for all of the strings that your application uses and their associated translations. It is a resource file that you add to your application, but you do not need to do a lot of work to get data from it. Table Views As a view object, a UITableView does not handle application logic or data. When using a UITableView, you must consider what else is necessary to get the table working in your application:   A UITableView typically needs a view controller to handle its appearance on the screen.  A UITableView needs a data source. A UITableView asks its data source for the number of rows to display, the data to be shown in those rows, and other tidbits that make a UITableView a useful UI. Without a data source, a table view is just an empty container. The dataSource for a UITableView can be any type of object as long as it conforms to the UITableViewDataSource protocol.  A UITableView typically needs a delegate that can inform other objects of events involving the UITableView. The delegate can be any object as long as it conforms to the UITableViewDelegate protocol.An instance of the class UITableViewController can fill all three roles: view controller, data source, and delegate. UITableViewController is a subclass of UIViewController and therefore has a view. A UITableViewController’s view is always an instance of UITableView, and the UITableViewController handles the preparation and presentation of the UITableView. When a UITableViewController creates its view, the dataSource and delegate properties of the UITableView are automatically set to point at the UITableViewController.  Custom Initializers for classes Classes can have two kinds of initializers: designated initializers and convenience initializers. A designated initializer is a primary initializer for the class. Every class has at least one designated initializer. A designated initializer ensures that all properties in the class have a value. Once it ensures that, a designated initializer calls a designated initializer on its superclass (if it has one). When you implement your own custom initializer, you lose the free initializer – init() – that classes have. The free initializer is useful when all of your class’s properties have default values and you do not need to do additional work to create the new instance. Every class must have at least one designated initializer, but convenience initializers are optional. You can think of convenience initializers as helpers. A convenience initializer always calls another initializer on the same class. Convenience initializers are indicated by the convenience keyword before the initializer name. Convenience initializers must call another initializer on the same type, whereas designated initializers must call a designated initializer on its superclass. Dependency Inversion Principle —&gt; V.IMP       The essential goal of this principle is to decouple objects in an application by inverting certain dependencies between them. This results in more robust and maintainable code.         The dependency inversion principle states that:     High-level objects should not depend on low-level objects. Both should depend on abstractions.  Abstractions should not depend on details. Details should depend on abstractions.Example - The abstraction required by the dependency inversion principle in LootLogger is the concept of a “store.” A store is a lower-level object that retrieves and saves Item instances through details that are only known to that class. ItemsViewController is a higher-level object that only knows that it will be provided with a utility object (the store) from which it can obtain a list of Item instances and to which it can pass new or updated Item instances to be stored persistently. This results in a decoupling because ItemsViewController is not dependent on ItemStore. In fact, as long as the store abstraction is respected, ItemStore could be replaced by another object that fetches Item instances differently (such as by using a web service) without any changes to ItemsViewController.   A common pattern used when implementing the dependency inversion principle is dependency injection. In its simplest form, higher-level objects do not assume which lower-level objects they need to use. Instead, those are passed to them through an initializer or property.  In our implementation of ItemsViewController, we used injection through a property to give it a store.Data Source Methods When a UITableView wants to know what to display, it calls methods from the set of methods declared in the UITableViewDataSource protocol. UITableViewCells   Each row of a table view is a view. These views are instances of UITableViewCell.  A cell itself has one subview – its contentView. The contentView is the superview for the content of the cell. The cell may also have an accessory view.  The accessory view shows an action-oriented icon, such as a checkmark, a disclosure icon, or an information button. These icons are accessed through predefined constants for the appearance of the accessory view. The default is UITableViewCellAccessoryType.none.  The real meat of a UITableViewCell is the contentView, which has three subviews of its own. Two of those subviews are UILabel instances that are properties of UITableViewCell named textLabel and detailTextLabel. The third subview is a UIImageView called imageView. In this chapter, you will use textLabel and detailTextLabel. Reusing UITableViewCells   iOS devices have a limited amount of memory. If you were displaying a list with thousands of entries in a UITableView, you would have thousands of instances of UITableViewCell. Most of these cells would take up memory needlessly. After all, if the user cannot see a cell onscreen, then there is no reason for that cell to have a claim on memory.  To conserve memory and improve performance, you can reuse table view cells. When the user scrolls the table, some cells move offscreen. Offscreen cells are put into a pool of cells available for reuse. Then, instead of creating a brand new cell for every request, the data source first checks the pool. If there is an unused cell, the data source configures it with new data and returns it to the table view.  There is one problem to be aware of: Sometimes a UITableView has different types of cells. Occasionally, you subclass UITableViewCell to create a special look or behavior. However, different subclasses floating around the pool of reusable cells create the possibility of getting back a cell of the wrong type. You must be sure of the type of the cell returned so that you can be sure of what properties and methods it has.  Note that you do not care about getting any specific cell out of the pool because you are going to change the cell content anyway. What you need is a cell of a specific type. The good news is that every cell has a reuseIdentifier property of type String. When a data source asks the table view for a reusable cell, it passes a string and says, “I need a cell with this reuse identifier.” By convention, the reuse identifier is typically the name of the cell class.  To reuse cells, you need to register either a prototype cell or a class with the table view for a specific reuse identifier. The reuse identifier is an arbitrary string.  The method dequeueReusableCell(withIdentifier:for:) will check the pool, or queue, of cells to see whether a cell with the correct reuse identifier already exists. If so, it will “dequeue” that cell. If there is not an existing cell, a new cell will be created and returned.Editing Table Views One of the great feature of table views is their built-in support for editing. This includes inserting new rows, deleting existing rows, and rearranging rows. In this section, you will add in support for all three of those features to LootLogger. Editing Mode UITableView has an editing property, and when this property is set to true, the UITableView enters editing mode. Once the table view is in editing mode, the rows of the table can be manipulated by the user. Depending on how the table view is configured, the user can change the order of the rows, add rows, or remove rows. (Editing mode does not allow the user to edit the content of a row.)  Adding and Deleting Items Remember that the role of a view object is to present model objects to the user; updating views without updating the model objects is not very useful. Design Patterns The consistent use of design patterns throughout the development process reduces the mental overhead in solving a problem so you can create complex applications more easily and rapidly. Here are some of the design patterns that Apple is very consistent with:   Delegation: One object delegates certain responsibilities to another object. We used delegation with the UITextField to be informed when the contents of the text field change.  Data source: A data source is similar to a delegate, but instead of reacting to another object, a data source is responsible for providing data to another object when requested. We used the data source pattern with table views: Each table view has a data source that is responsible for, at a minimum, telling the table view how many rows to display and which cell it should display at each index path.  Model-View-Controller: Each object in your applications fulfills one of three roles. Model objects are the data. Views display the UI. Controllers provide the glue that ties the models and views together.  Target-action pairs: One object calls a method on another object when a specific event occurs. The target is the object that has a method called on it, and the action is the method being called. For example, we used target- action pairs with buttons: When a touch event occurs, a method will be called on another object (often a view controller).Subclassing UITableViewCell A UITableView displays a list of UITableViewCell objects. For many applications, the basic cell with its textLabel, detailTextLabel, and imageView is sufficient. However, when you need a cell with more detail or a different layout, you subclass UITableViewCell. Customizing the Cell   You customize the appearance of UITableViewCell subclasses by adding subviews to its contentView. Adding subviews to the contentView instead of directly to the cell itself is important because the cell will resize the contentView inside it at certain times.  For example, when a table view enters editing mode, the contentView resizes itself to make room for the editing controls. If you added subviews directly to the UITableViewCell, the editing controls would obscure the subviews. The cell cannot adjust its size when entering edit mode (it must remain the width of the table view), but the contentView can and does. Dynamic Type Creating an interface that appeals to everyone can be daunting. Some people prefer more compact interfaces so they can see more information at once. Others might want to be able to easily see information at a glance, or perhaps they have poor eyesight. In short: People have different needs. Good developers strive to make apps that meet those needs. Dynamic Type is a technology that helps realize this goal by providing specifically designed text styles that are optimized for legibility. Users can select one of seven preferred text sizes from within Apple’s Settings application (plus a few additional larger sizes from within the Accessibility section), and apps that support Dynamic Type will have their fonts scaled appropriately. The Dynamic Type system is centered around text styles. When a font is requested for a given text style, the system will consider the user’s preferred text size in association with the text style to return an appropriately configured font.  Responding to user changes When the user changes the preferred text size and returns to the application, the table view will get reloaded. Unfortunately, the labels will not know about the new preferred text size. To fix this, you need to have the labels automatically adjust to content size changes. Open Main.storyboard and select all three ItemCell labels. Open the attributes inspector, and check the box for Automatically Adjusts Font Bad Cell Constraints  Since there are are no vertical constraints, the label will be centered with height 0 and would thus, be invisible. Better Cell constraints  Stack Views Auto Layout can be used to create flexible interfaces that scale across device types and sizes. Auto Layout is a very powerful technology, but with that power comes complexity. Laying out an interface well often needs a lot of constraints, and it can be difficult to create dynamic interfaces due to the need to constantly add and remove constraints. Interfaces that have a linear layout are great candidates for using a stack view. A stack view is an instance ofUIStackView that allows you to create a vertical or horizontal layout that is easy to lay out and manages most of the constraints that you would typically have to manage yourself. Perhaps best of all, you are able to nest stack views within other stack views, which allows you to create truly amazing interfaces in a fraction of the time.   Nesting stack views is very common when creating more complex layouts  A stack view’s “arranged views” are a subset of its “subviews”  –&gt; because views may be hidden.  Can dynamically add/remove views in a stack view  Can dynamically change any of the stack views propertiesProperties of StackView   Hiding Views inside Stackview class ViewController: UIViewController {    @IBAction func hideViewTapped(_ sender: UIButton) {        UIView.animate(withDuration: 1.0) {            sender.superview?.isHidden = true        }    }}Implicit Constraints A view has one of these priorities for each axis:   horizontal content hugging priority  vertical content hugging priority  horizontal content compression resistance priority  vertical content compression resistance priorityContent hugging priorities The content hugging priority is like a rubber band that is placed around a view. The rubber band makes the view not want to be bigger than its intrinsic content size in that dimension. Each priority is associated with a value from 0 to 1000. A value of 1000 means that a view cannot get bigger than its intrinsic content size on that dimension. Content compression resistance priorities The content compression resistance priorities determine how much a view resists getting smaller than its intrinsic content size. Segues   Most iOS applications have a number of view controllers that users navigate between. Storyboards allow you to set up these interactions as segues without having to write code.  A segue moves another view controller’s view onto the screen and is represented by an instance of UIStoryboardSegue.  Each segue has a style, an action item, and an identifier.  The style of a segue determines how the view controller will be presented.  The action item is the view object in the storyboard file that triggers the segue, like a button, a table view cell, or some other UIControl.  The identifier is used to programmatically access the segue. This is useful when you want to trigger a segue that does not come from an action item, like a shake or some other interface element that cannot be set up in the storyboard file.Passing Data Around Whenever a segue is triggered, the prepare(for:sender:) method is called on the view controller initiating the segue. This method has two arguments: the UIStoryboardSegue, which gives you information about which segue is happening, and the sender, which is the object that triggered the segue (a UITableViewCell or a UIButton, for example). The UIStoryboardSegue gives you three pieces of information: the source view controller (where the segue originates), the destination view controller (where the segue ends), and the identifier of the segue. The identifier lets you differentiate segues. Let’s give the segue a useful identifier. UINavigationController       A UINavigationController maintains an array of view controllers presenting related information in a stack. When a UIViewController is on top of the stack, its view is visible.         When you initialize an instance of UINavigationController, you give it a UIViewController. This UIViewController is added to the navigation controller’s viewControllers array and becomes the navigation controller’s root view controller. The root view controller is always on the bottom of the stack.           Note: While this view controller is referred to as the navigation controller’s “root view controller,” UINavigationController does not have a rootViewController property.             More view controllers can be pushed on top of theUINavigationController’s stack while the application is running. These view controllers are added to the end of the viewControllers array that corresponds to the top of the stack. UINavigationController’s topViewController property keeps a reference to the view controller at the top of the stack.         When a view controller is pushed onto the stack, its view slides onscreen from the right. When the stack is popped (i.e., the last item is removed), the top view controller is removed from the stack and its view slides off to the right, exposing the view of the next view controller on the stack, which becomes the top view controller.         The view of the topViewController is what the user sees.         UINavigationController is a subclass of UIViewController, so it has a view of its own. Its view always has two subviews: a UINavigationBar and the view of topViewController    Appearing and Disappearing Views   Whenever a UINavigationController is about to swap views, it calls two methods: viewWillDisappear(:) and viewWillAppear(:). The UIViewController that is about to be popped off the stack has viewWillDisappear(:) called. The UIViewController that will then be on top of the stack has viewWillAppear(:) called on it.  To hold on to changes in the data, when a DetailViewController is popped off the stack you will set the properties of its item to the contents of the text fields. When implementing these methods for views appearing and disappearing, it is important to call the superclass’s implementation – it might have some work to do and needs to be given the chance to do it.First Responder Status   For the shake and keyboard events, for example, there is no event location within your view hierarchy to determine which view will receive the event, so another mechanism must be used. This mechanism is the first responder status. Many views and controls can be a first responder within your view hierarchy – but only one at a time. Think of it as a flag that can be passed among views. Whichever view holds the flag will receive the shake or keyboard event.  Instances of UITextField and UITextView have an uncommon response to touch events. When touched, a text field or a text view becomes the first responder, which in turn triggers the system to put the keyboard onscreen and send the keyboard events to the text field or view. The keyboard and the text field or view have no direct connection, but they work together through the first responder status.  This is a neat way to ensure that the keyboard input is delivered to the correct text field. The concept of a first responder is part of the broader topic of event handling in Cocoa Touch programming that includes the UIResponder class and the responder chain. You can visit Apple’s Event Handling Guide for iOS for more information.UINavigationBar       Every UIViewController has a navigationItem property of type UINavigationItem. However, unlikeUINavigationBar, UINavigationItem is not a subclass of UIView, so it cannot appear on the screen.         Instead, the navigation item supplies the navigation bar with the content it needs to draw. When a UIViewController comes to the top of a UINavigationController’s stack, the UINavigationBar uses the UIViewController’s navigationItem to configure itself.         By default, a UINavigationItem is empty. At the most basic level, a UINavigationItem has a simple title string. When a UIViewController is moved to the top of the navigation stack and its navigationItem has a valid string for its title property, the navigation bar will display that string.              A navigation item can hold more than just a title string. There are three customizable areas for each UINavigationItem: a leftBarButtonItem, a rightBarButtonItem, and a titleView. The left and right bar button items are references to instances of UIBarButtonItem, which contain the information for a button that can only be displayed on a UINavigationBar or a UIToolbar.         Recall that UINavigationItem is not a subclass of UIView. Instead, UINavigationItem encapsulates information that UINavigationBar uses to configure itself. Similarly, UIBarButtonItem is not a view, but holds the information about how a single button on the UINavigationBar should be displayed. (A UIToolbar also uses instances of UIBarButtonItem to configure itself.)         The third customizable area of a UINavigationItem is its titleView. You can either use a basic string as the title or have a subclass of UIView sit in the center of the navigation item. You cannot have both. If it suits the context of a specific view controller to have a custom view (like a segmented control or a text field, for example), you would set the titleView of the navigation item to that custom view. Typically, however, a title string is sufficient.          When you initialize an instance of UINavigationController, you give it a UIViewController. ThisUIViewController is added to the navigation controller’s viewControllers array and becomes the navigation controller’s root view controller. The root view controller is always on the bottom of the stack.           Note: While this view controller is referred to as the navigation controller’s “root view controller,” UINavigationController does not have a rootViewController property.         More view controllers can be pushed on top of theUINavigationController’s stack while the application is running. These view controllers are added to the end of the viewControllers array that corresponds to the top of the stack. UINavigationController’s topViewController property keeps a reference to the view controller at the top of the stack.   Saving, Loading and Error Handling   NOTE: Saving and loading “data” almost always means saving and loading model objects.       To save and load model objects to and from the disk, we need to make them of type codable.         Types whose instances need to be codable conform to the Encodable and Decodable protocols and implement their two required methods, encode(to:) and init(from:), respectively.   protocol Decodable {    init(from decoder: Decoder) throws}protocol Encodable {    func encode(to encoder: Encoder) throws}Although your types can conform to just one of these protocols, it’s common for types to conform to both. Apple has a type alias for types that conform to both protocols called Codable. typealias Codable = Decodable &amp; Encodable Property Lists       A property list is a representation of some data that can be saved to disk and read back in at a later point. Property lists can represent hierarchies of data and so are a great tool for saving and loading lightweight object graphs.     Under the hood, property list data can be represented by a number of formats, they are frequently represented using an XML or binary format.  Property lists can hold the following types: Array, Dictionary, String, Data, Date, Int, Float, and Bool. As long as a given type is composed of those types, or a hierarchy of those types, then it can be represented as a property list.func saveChanges() -&gt; Bool {        let encoder = PropertyListEncoder()    // You will have an error on the next line, for not catching errors.    let data = encoder.encode(allItems)    return false}Error Handling   Optionals provide a simple way to represent failure when you do not care about the reason for failure. When you need to know why something failed, an optional will not provide enough information.  If a method could generate an error, its method signature needs to indicate this using the throws keyword. Error throwing and exception hanndling is ‘opt-in’ in Swift.  The throws keyword indicates that this method could throw an error. (If you are familiar with throwing exception in other languages, Swift’s error handling is not the same as throwing exception.)  By using this keyword, the compiler ensures that anyone who uses this method knows that this method can throw an error – and, more importantly, that the caller also handles any potential errors.  To call a method that can throw, you use a do-catch statement. Within the do block, you annotate any methods that might throw an error using the try keyword to reinforce the idea that the call might fail.  If a method does throw an error, then the program immediately exits the do block; no further code in the do block is executed. At that point, the error is passed to the catch block for it to be handled in some way.func deleteImage(at imageURL: URL) {    let fileManager = FileManager.default    do {        // need try for every statement that can fail        try fileManager.removeItem(at: imageURL) // this method might throw an error} catch {         print(\"Error removing image: \\(error)\")    }} Application Sandbox Every iOS application has its own application sandbox. An application sandbox is a directory on the filesystem that is barricaded from the rest of the filesystem. Your application must stay in its sandbox, and no other application can access its sandbox.  Constructing a file URL The instances of our model objects will be saved to a single file in the Documents directory. The store will handle writing to and reading from that file. To do this, the store needs to construct a URL to this file. // Adding a URL where the items will be saved tovar allItems = [Item]()let itemArchiveURL: URL = {    let documentsDirectories =        FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)    let documentDirectory = documentsDirectories.first!    return documentDirectory.appendingPathComponent(\"items.plist\")}()      The method urls(for:in:) searches the filesystem for a URL that meets the criteria given by the arguments.         In iOS, the last argument is always the same. (This method is borrowed from macOS, where there are significantly more options.) The first argument is a SearchPathDirectory enumeration that specifies the directory in the sandbox you want the URL for. For example, searching for .cachesDirectory will return the Caches directory in the application’s sandbox.   Persisting the Items You have a place to save data on the filesystem and a model object that can be saved to the filesystem. How do you kick off the saving and loading processes, and when do you do it? // Writing data to diskfunc saveChanges() -&gt; Bool {\tprint(\"Saving items to: \\(itemArchiveURL)\")    do {        let encoder = PropertyListEncoder()        let data = try encoder.encode(allItems)         try data.write(to: itemArchiveURL)         return true \t    } catch let encodingError {        print(\"Error encoding allItems: \\(encodingError)\")        return false     } }   NOTE: When the user leaves the application (often by swiping up on the Home indicator), the messageapplicationDidEnterBackground(_:) is sent to the AppDelegate. Loading the Items init() {     do {         let data = try Data(contentsOf: itemArchiveURL)        let unarchiver = PropertyListDecoder()        let items = try unarchiver.decode([Item].self, from: data)        allItems =  items\t} catch {         print(\"Error reading in saved items: \\(error)\")    }} Application States and Transitions When an application is not running, it is in the not running state and it does not execute any code or have any memory reserved in RAM. After the user launches an application, it enters the active state. When in the active state, an application’s interface is on the screen, it is accepting events, and its code is handling those events. While in the active state, an application can be temporarily interrupted by a system event like an SMS message, push notification, phone call, or alarm. An overlay will appear on top of your application to handle this event, and the application enters the inactive state. In the inactive state, an application is visible behind the overlay and is executing code, but it is not receiving events. Applications typically spend very little time in the inactive state. You can force an active application into the inactive state by pressing the Lock button at the top of the device. The application will stay inactive until the device is unlocked. When the user swipes up on the Home indicator or switches to another application in some other way, the application enters the background state. (Actually, it spends a brief moment in the inactive state before transitioning to the background state.) In the background state, an application’s interface is not visible or receiving events, but it can still execute code. By default, an application that enters the background state has about 10 seconds before it enters the suspended state. Your application should not rely on this number; instead, it should save user data and release any shared resources as quickly as possible. An application in the suspended state cannot execute code. You cannot see its interface, and any resources it does not need while suspended are destroyed. A suspended application is essentially flash-frozen and can be quickly thawed when the user relaunches it. Application states flow chart  Q. If the app cannot execute any code when in the suspended state, how do chat apps receive push notifications? These push notifications are generally coming from a web service. These web services push the data to Apple, and Apple then sends us the notification. The code for sending these push nontifications is not in our app. Q. How can we reply directly from the notification then? Such actions in response to notifications is possible when we have a separate small “app” bundled with our app. This small app generally has a single view controller. When we reply from the notification window, we are basically using this small app, as opposed to our main application. This app has it’s own separae application state and transitions. So, our app need not be made active for such actions to be performed. Q. What does the background app refresh option do? When background app refresh is enabled, the OS may decide to enable the app to load or refresh it’s data for a brief period of time, when the OS is not busy doing other things. So for this brief period, the app may be made active, and then back to inactive and suspended.   NOTE: You can see what applications are in the background or suspended by swiping up and pausing on the Home indicator to get to the task switcher An application in the suspended state will remain in that state as long as there is adequate system memory. When the OS decides memory is getting low, it will terminate suspended applications as needed. A suspended application gets no indication that it is about to be terminated. It is simply removed from memory. (An application may remain in the task switcher after it has been terminated, but it will have to relaunch when tapped.) The Application Bundle When you build an iOS application project in Xcode, you create an application bundle. The application bundle contains the application executable and any resources you have bundled with your application. Resources are things like storyboard files, images, and audio files – any files that will be used at runtime. When you add a resource file to a project, Xcode is smart enough to realize that it should be bundled with your application. How can you tell which files are being bundled with your application? Select the project name from the project navigator. Check out the Build Phases pane in the project target. Everything under Copy Bundle Resources will be added to the application bundle when it is built. Modals and Popovers For example, when adding a new contact to your phone, you are presented with a screen to fill out the contact’s details. We call this kind of presentation a modal presentation as the application is being put into a different mode where a certain set of actions become our focus. Modally presented view controllers often occupy the entire screen, but in certain contexts they might only take up aportion of the screen. This is especially true on iPad where there is more space to work with. In either case, the user is expected to interact with the modally presented view controller before proceeding. Alert controllers To allow the user to choose a photo source, you will present an alert with the possible choices. Alerts are often used to display information to the user on which they must act. When you want to display an alert, you create an instance of UIAlertController with a preferred style. The two available styles are UIAlertControllerStyle.actionSheet and UIAlertControllerStyle.alert Presenting programmatically class CalendarViewController: UIViewController {    func addNewEvent(_ sender: UIBarButtonItem) {        let viewController = NewCalendarEventViewController()        present(viewController, animated: true, completion: nil)    }}Dismissing class CalendarViewController: UIViewController {    func cancel(_ sender: UIBarButtonItem) {        dismiss(animated: true, completion: nil)    }}  Completion closure dismiss(animated: true, completion: {    print(\"View controller finished dismissing!\")})Permissions There are a number of capabilities on iOS that require user approval before use. Here are a subset of those capabilities:   Camera and photos  Location  Microphone  HealthKit data  Calendar  RemindersFor each of these, your application must supply a usage description that specifies the reason that your application wants to access this information. This description will be presented to the user whenever the application accesses that capability. Caching in the data store class ImageStore {     let cache = NSCache&lt;NSString,UIImage&gt;()    func setImage(_ image: UIImage, forKey key: String) {        cache.setObject(image, forKey: key as NSString)    }    func image(forKey key: String) -&gt; UIImage? {        return cache.object(forKey: key as NSString)    }    func deleteImage(forKey key: String) {        cache.removeObject(forKey: key as NSString)    }}Note that the cache is associating an instance of NSString with UIImage. NSString is Objective-C’s version ofString. Due to the way NSCache is implemented (it is an Objective-C class, like most of Apple’s classes that you have been working with), it requires you to use NSString instead of String. // MARK: As your classes get longer, it can get more difficult to find a method buried in a long list of methods. A good way to organize your methods is to use // MARK: comments. Two useful // MARK: comments are the divider and the label: // This is a divider // MARK: - // This is a label// MARK: My Awesome MethodsThe divider and label can be combined: // MARK: - View life cycleoverride func viewDidLoad() { ... }override func viewWillAppear(_ animated: Bool) { ... }// MARK: - Actionsfunc addNewItem(_ sender: UIBarButtonItem) {...} Size classes The relative sizes of screens are defined in size classes. A size class represents a relative amount of screen space in a given dimension. Each dimension (width and height) can either be compact or regular, so there are four possible combinations of size classes:  Notice that the size classes cover both screen sizes and orientations. Instead of thinking about interfaces in terms of orientation or device, it is better to think in terms of size classes. Modifying Traits for a Specific Size Class When editing the interface for a specific size class combination, you are able to change:   properties for many views  whether a specific subview is installed  whether a specific constraint is installed  the constant of a constraint  the font for subviews that display text  NOTE: To detect a change in device orientation, we can use viewWillTransition(to:with:). Varying constraints for different size classes       To activate constraints on only a particular size classes ,for a partiular trait, you can change things like the axis of the stack view, and it will be applied to only that particular device orientation. We can add size-class-specific options to do this.         You can also deactivate particular constraints for a particular trait variation (by disabling the install checkbox when in the trait variation).   Web Services Building the URL Communication with servers is done via requests. A request encapsulates information about the interaction between the application and the server, and its most important piece of information is the destination URL. Access Control You can control what can access the properties and methods on your own types. There are five levels of access control that can be applied to types, properties, and methods:   open – This is used only for classes, and mostly by framework or third-party library authors. Anything can access this class, property, or method. Additionally, classes marked as open can be subclassed and methods can be overridden outside of the module.  public – This is very similar to open; however, classes can only be subclassed and methods can only be overridden inside (not outside of) the module.  internal – This is the default. Anything in the current module can access this type, property, or method. For an app, only files within your project can access these. If you write a third-party library, then only files within that third-party library can access them – apps that use your third-party library cannot.  fileprivate – Anything in the same source file can see this type, property, or method.  private – Anything within the enclosing scope can access this type, property, or method.Sending the Request   A URL request encapsulates information about the communication from the application to the server. Mostimportantly, it specifies the URL of the server for the request, but it also has a timeout interval, a cache policy, and other metadata about the request. A request is represented by the URLRequest class.  The URLSession API is a collection of classes that use a request to communicate with a server in a number of ways. The URLSessionTask class is responsible for communicating with a server. The URLSession class is responsible for creating tasks that match a given configuration.  The class that communicates with the web service is an instance of URLSessionTask. There are three kinds of tasks: data tasks, download tasks, and upload tasks. URLSessionDataTask retrieves data from the server and returns it as Data in memory. URLSessionDownloadTask retrieves data from the server and returns it as a file saved to the filesystem. URLSessionUploadTask sends data to the server.  Often, you will have a group of requests that have many properties in common. For example, maybe some downloads should never happen over cellular data, or maybe certain requests should be cached differently than others. It can become tedious to configure related requests the same way.      This is where URLSession comes in handy. URLSession acts as a factory for URLSessionTask instances. The session is created with a configuration that specifies properties that are common across all of the tasks that it creates. Although many applications might only need to use a single instance of URLSession, having the power and flexibility of multiple sessions is a great tool to have at your disposal.     Fetching data from a web service is an asynchronous process: Once the request starts, it may take a nontrivial amount of time for a response to come back from the server. Because of this, the fetchInterestingPhotos(completion:) method cannot directly return an instance of PhotosResult. Instead, the caller of this method will supply a completion closure for the PhotoStore to call once the request is complete.  This follows the same pattern that URLSessionTask uses with its completion handler: The task is created with a closure for it to call once the web service request completes. Figure 20.6 describes the flow of data with the web service request. The Main Thread   Modern iOS devices have multicore processors that enable them to run multiple chunks of code simultaneously. A common way to express this is by representing each computation with a different thread of control.  When the web service completes, you want it to update the image view. But by default, URLSessionDataTask runs the completion handler on a background thread. You need a way to force code to run on the main thread to update the image view. You can do that easily using the OperationQueue class.Collection Views Creating a UICollectionView let layout = UICollectionViewFlowLayout()let cv = UICollectionView(frame: frame, collectionViewLayout: layout)cv.delegate = selfcv.dataSource = selfUICollectionViewDataSource var photos: [Photos] = ...func collectionView(_ collectionView: UICollectionView,        numberOfItemsInSection section: Int) -&gt; Int {    return photos.count}func collectionView(_ collectionView: UICollectionView,        cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {    let identifier = \"UICollectionViewCell\"    let cell =        collectionView.dequeueReusableCell(withReuseIdentifier: identifier,                                           for: indexPath)    // Configure the cell    return cell } Customizing a Collection Layout   The display of cells is not driven by the collection view itself but by the collection view’s layout. The layout object is responsible for the placement of cells onscreen. Layouts, in turn, are driven by a subclass of UICollectionViewLayout. The flow layout that Photorama is currently using is UICollectionViewFlowLayout, which is the only concrete UICollectionViewLayout subclass provided by the UIKit framework. Some of the properties you can customize on UICollectionViewFlowLayout are:   scrollDirection – Do you want to scroll vertically or horizontally?  minimumLineSpacing – What is the minimum spacing between lines?  minimumInteritemSpacing – What is the minimum spacing between items in a row (or column, if scrolling horizontally)?  itemSize – What is the size of each item?  sectionInset – What are the margins used to lay out content for each section?","categories": ["Tech"],
        "tags": [],
        "url": "http://localhost:4000/tech/iOS-Notes/",
        "teaser":null}]
