var store = [{
        "title": "Java Trivia Questions",
        "excerpt":"Notes taken from: JavaTpoint Side Notes:   No need to remove unreferenced objects because there is Automatic Garbage Collection in java.  Java is secured because:          No explicit pointer      Java Programs run inside virtual machine sandbox      There is exception handling and type checking mechanism in java (Java is a statically typed language).        In C programming, int data type occupies 2 bytes of memory for 32-bit architecture and 4 bytes of memory for 64-bit architecture. But in java, it occupies 4 bytes of memory for both 32 and 64 bit architectures.  Whenever you write java command on the command prompt to run the java class, an instance of JVM is created.  Java Stack stores frames.It holds local variables and partial results, and plays a part in method invocation and return. Each thread has a private JVM stack, created at the same time as thread. A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes.  There are three types of variables in java: local, instance and static.  In java programming, multiple and hybrid inheritance is supported through interface only  super() can be used to invoke immediate parent class constructor.  super() is added in each class constructor automatically by compiler if there is no super() or this().  Runtime polymorphism can’t be achieved by data members.  An object is an instance of particular java class, but it is also an instance of its superclass.  If there is any abstract method in a class, that class must be abstract.  If you are extending any abstract class that have abstract method, you must either provide the implementation of the method or make this class abstract.  Abstraction in Java can be achieved through abstract classes or interfaces. Interface provides full abstraction because it is just a blueprint and all methods are abstract. In an abstract class, some methods may not be abstract.  Since Java 8, interface can have default and static methods  The java compiler adds public and abstract keywords before the interface method. More, it adds public, static and final keywords before data members.  Since Java 8, we can have method body in interface. But we need to make it default method.  Since Java 8, we can have static method in interface.  If you don’t handle exception, before terminating the program, JVM executes finally block(if any).  For each try block there can be zero or more catch blocks, but only one finally block.  The finally block will not be executed if program exits(either by calling System.exit() or by causing a fatal error that causes the process to abort).  String objects are stored in a special memory area known as string constant pool.  To create the singleton class, we need to have static member of class, private constructor and static factory method.Object-oriented Object-oriented means we organize our software as a combination of different types of objects that incorporates both data and behaviour.Object-oriented programming(OOPs) is a methodology that simplify software development and maintenance by providing some rules. Basic concepts of OOPs are:   Object  Class  Inheritance  Polymorphism  Abstraction  EncapsulationPlatform-Independent A platform is the hardware or software environment in which a program runs. There are two types of platforms software-based and hardware-based. Java provides software-based platform. The Java platform differs from most other platforms in the sense that it is a software-based platform that runs on the top of other hardware-based platforms. It has two components:   Runtime Environment  API(Application Programming Interface)Java code can be run on multiple platforms e.g. Windows, Linux, Sun Solaris, Mac/OS etc. Java code is compiled by the compiler and converted into bytecode. This bytecode is a platform-independent code because it can be run on multiple platforms i.e. Write Once and Run Anywhere(WORA). Multi-threading in Java A thread is like a separate program, executing concurrently. We can write Java programs that deal with many tasks at once by defining multiple threads. The main advantage of multi-threading is that it doesn’t occupy memory for each thread. It shares a common memory area. Diff between C++ and Java https://www.javatpoint.com/cpp-vs-java Q.  What happens at runtime and compile time? Q. **Comparison of JRE, JDK, JVM Q. Why char uses 2 byte in java and what is \\u0000 ? It is because java uses Unicode system than ASCII code system. The \\u0000 is the lowest range of Unicode system. What is difference between object oriented programming language and object based programming language? Object based programming languages follow all the features of OOPs except Inheritance. Examples of object based programming languages are JavaScript, VBScript etc. What is constructor? Constructor is just like a method that is used to initialize the state of an object. It is invoked at the time of object creation. **Does constructor return any value? Yes, that is current class instance (You cannot use return type yet it returns a value). **What is a Java static block? Is used to initialize the static data member.It is executed before main method at the time of classloading. What is Inheritance?   Inheritance in java is a mechanism in which one object acquires all the properties and behaviors of parent object.  The idea behind inheritance in java is that you can create new classes that are built upon existing classes. When you inherit from an existing class, you can reuse methods and fields of parent class, and you can add new methods and fields also.  Inheritance represents the IS-A relationship, also known as parent-child relationship.What is Aggregation? Has-A relationship. When an object of one class is instantiated in another class. When use Aggregation? Code reuse is best achieved by aggregation when there is no is-a relationship.Inheritance should be used only if the relationship is-a is maintained throughout the lifetime of the objects involved; otherwise, aggregation is the best choice. Method Overriding If subclass (child class) has the same method as declared in the parent class, it is known as method overriding in java. Can we override static method? No, you can’t override the static method because they are the part of class not object. What is covariant return type?   overriding a method by just changing the return type. (when return type is non-primitive).Java final variable If you make any variable as final, you cannot change the value of final variable(It will be constant). Java final method If you make any method as final, you cannot override it. Java final class If you make any class as final, you cannot extend it. **What is blank or uninitialized final variable? A final variable that is not initialized at the time of declaration is known as blank final variable. If you want to create a variable that is initialized at the time of creating object and once initialized may not be changed, it is useful. For example PAN CARD number of an employee. It can be initialized only in constructor. **What is static blank final variable A static final variable that is not initialized at the time of declaration is known as static blank final variable. It can be initialized only in static block. What is Polymorphism? Polymorphism in java is a concept by which we can perform a single action by different ways. There are two types of polymorphism in java: compile time polymorphism and runtime polymorphism. We can perform polymorphism in java by method overloading and method overriding. ** If you overload static method in java, it is the example of compile time polymorphism. Here, we will focus on runtime polymorphism in java Runtime polymorphism or Dynamic Method Dispatch is a process in which a call to an overridden method is resolved at runtime rather than compile-time Upcasting When reference variable of Parent class refers to the object of Child class, it is known as upcasting Upcasting + overriding = runtime polymorphism Java Runtime Polymorphism with Data Member ** Method is overridden not the datamembers, so runtime polymorphism can’t be achieved by data members.In the example given below, both the classes have a datamember speedlimit, we are accessing the datamember by the reference variable of Parent class which refers to the subclass object. Since we are accessing the datamember which is not overridden, hence it will access the datamember of Parent class always. Static binding When type of the object is determined at compiled time(by the compiler), it is known as static binding. If there is any private, final or static method in a class, there is static binding. Dynamic binding When type of the object is determined at run-time, it is known as dynamic binding. Abstract class in Java A class that is declared with abstract keyword, is known as abstract class in java. It can have abstract and non-abstract methods (method with body). It needs to be extended and its method implemented. It cannot be instantiated. Abstract method A method that is declared as abstract and does not have implementation is known as abstract method. Interface in Java   An interface in java is a blueprint of a class. It has static constants and abstract methods.  The interface in java is a mechanism to achieve abstraction.  There can be only abstract methods in the java interface not method body.  It is used to achieve abstraction and multiple inheritance in Java.  Java Interface also represents IS-A relationship.-** It cannot be instantiated just like abstract class.**Q. Why use Java interface? There are mainly three reasons to use interface:   It is used to achieve abstraction.  By using interface, we can support the functionality of multiple inheritance.  It can be used to achieve loose coupling.Q. Can you declare an interface method static? No, because methods of an interface is abstract by default, and static and abstract keywords can’t be used together. Multiple inheritance in Java by interface If a class implements multiple interfaces, or an interface extends multiple interfaces i.e. known as multiple inheritance. Multiple inheritance is not supported through class in java but it is possible by interface, why? As we have explained in the inheritance chapter, multiple inheritance is not supported in case of class because of ambiguity. But it is supported in case of interface because there is no ambiguity as implementation is provided by the implementation class. Q. **Can we define private and protected modifiers for variables in interfaces? No, they are implicitly public. Q. When can an object reference be cast to an interface reference? An object reference can be cast to an interface reference when the object implements the referenced interface. Q. What is package? A package is a group of similar type of classes, interfaces and sub-packages. It provides access protection and removes naming collision. **What is the difference between import and static import? The import allows the java programmer to access classes of a package without package qualification whereas the static import feature allows to access the static members of a class without the class qualification. The import provides accessibility to classes and interface whereas static import provides accessibility to static members of the class. Q. What is Exception Handling? Exception Handling is a mechanism to handle runtime errors. Java finally block   Java finally block follows try or catch block.  Java finally block is always executed whether exception occurs or not and whether it is handled or not.  Java finally block is a block that is used to execute important code such as closing connection, stream etc.Q. **Why are string objects immutable in Java? Because java uses the concept of string literal. Suppose there are 5 reference variables, all refer to one object “sachin”.If one reference variable changes the value of the object, it will be affected to all the reference variables. That is why string objects are immutable in java. Each time you create a string literal, the JVM checks the string constant pool first. If the string already exists in the pool, a reference to the pooled instance is returned. If string doesn’t exist in the pool, a new string instance is created and placed in the pool. For example: String s1=”Welcome”;String s2=”Welcome”;//will not create new instance Q. Why java uses concept of string literal? To make Java more memory efficient By new keyword String s=new String(“Welcome”); //creates two objects and one reference variable In such case, JVM will create a new string object in normal(non pool) heap memory and the literal “Welcome” will be placed in the string constant pool. The variable s will refer to the object in heap(non pool). StringBuffer Java StringBuffer class is thread-safe i.e. multiple threads cannot access it simultaneously (synchronized). So it is safe and will result in an order. StringBuilder The Java StringBuilder class is same as StringBuffer class except that it is non-synchronized. It is also more efficient than StringBuffer. **Multi-threading Multithreading in java is a process of executing multiple threads simultaneously. Thread is basically a lightweight sub-process, a smallest unit of processing. Multiprocessing and multithreading, both are used to achieve multitasking. But we use multithreading than multiprocessing because threads share a common memory area. They don’t allocate separate memory area so saves memory, and context-switching between the threads takes less time than process. Life-cycle of threads The life cycle of the thread in java is controlled by JVM. The java thread states are as follows:   New  Runnable  Non-Runnable (Blocked)  TerminatedHow to create thread There are two ways to create a thread:   By extending Thread class  By implementing Runnable interface. (If you are not extending the Thread class,your class object would not be treated as a thread object.So you need to explicitely create Thread class object.We are passing the object of your class that implements Runnable so that your class run() method may execute)**What if we call run() method directly instead start() method? Each thread starts in a separate call stack.Invoking the run() method from main thread, the run() method goes onto the current call stack rather than at the beginning of a new call stack. refer this: https://www.javatpoint.com/what-if-we-call-run()-method-directly Points to remember for Daemon Thread in Java   It provides services to user threads for background supporting tasks.  It has no role in life than to serve user threads.  Its life depends on user threads.  It is a low priority thread.  If you want to make a user thread as Daemon, it must not be started otherwise it will throw IllegalThreadStateException.Java Thread pool represents a group of worker threads that are waiting for the job and reuse many times. In case of thread pool, a group of fixed size threads are created. A thread from the thread pool is pulled out and assigned a job by the service provider. After completion of the job, thread is contained in the thread pool again. Advantage of Java Thread Pool Better performance It saves time because there is no need to create new thread. Java Garbage Collection   In java, garbage means unreferenced objects.  Garbage Collection is process of reclaiming the runtime unused memory automatically.      In other words, it is a way to destroy the unused objects.     The finalize() method is invoked each time before the object is garbage collected. This method can be used to perform cleanup processing.  The Garbage collector of JVM collects only those objects that are created by new keyword. So if you have created any object without new, you can use finalize method to perform cleanup processing  The gc() method is used to invoke the garbage collector to perform cleanup processing.Synchronization in Java Synchronization in java is the capability to control the access of multiple threads to any shared resource. Java Synchronization is better option where we want to allow only one thread to access the shared resource.   Mutual Exclusive  Mutual Exclusive helps keep threads from interfering with one another while sharing data. This can be done by three ways in java:          by synchronized method      by synchronized block      by static synchronization      Concept of Lock in Java Synchronization is built around an internal entity known as the lock or monitor. Every object has an lock associated with it. By convention, a thread that needs consistent access to an object’s fields has to acquire the object’s lock before accessing them, and then release the lock when it’s done with them. Synchronized block in java Synchronized block can be used to perform synchronization on any specific resource of the method. Suppose you have 50 lines of code in your method, but you want to synchronize only 5 lines, you can use synchronized block. Advantage of static synchronization method If you make any static method as synchronized, the lock will be on the class not on object. Suppose there are two objects of a shared class(e.g. Table) named object1 and object2.In case of synchronized method and synchronized block there cannot be interference between t1 and t2 or t3 and t4 because t1 and t2 both refers to a common object that have a single lock.But there can be interference between t1 and t3 or t2 and t4 because t1 acquires another lock and t3 acquires another lock.I want no interference between t1 and t3 or t2 and t4.Static synchronization solves this problem. *Enums in Java https://www.javatpoint.com/enum-in-java Garbage Collection in Java   Garbage collection is the phrase used to describe automatic memory management in Java.  it’s typical for memory to be used to create a stack, a heap, in Java’s case constant pools, and method areas. The heap is that part of memory where Java objects live, and it’s the one and only part of memory that is in any way involved in the garbage collection process.  When the garbage collector runs, its purpose is to find and delete objects that cannot be reached.  An object is eligible for garbage collection when no live thread can access it.","categories": [],
        "tags": [],
        "url": "http://localhost:4000/portfolio/2017-09-25-java-trivia",
        "teaser":"http://localhost:4000/images/avatar.jpg"},{
        "title": "System Design and Scalability",
        "excerpt":"  The idea of these questions is to have a discussion about the problem at hand. What’s important for the interviewer is the process, which you use to tackle the problem. Remember that there is no one right answer. A system can be built in different ways. The important thing is to be able to justify your ideas. System design questions require a combination of the right strategy and knowledge. By strategy we mean a way to approach the problem at an interview. Important Links       Harvard Video         Extensive Prep         Differential Synchronization         Scalability for Dummies         REST principles         HiredInTech         Database sharding         Database Indexing   System Design Process Constraints and Use Cases   The very first thing you should do with any system design question is to clarify the system’s constraints and to identify what use cases the system needs to satisfy.  Usually, part of what the interviewer wants to see is if you can gather the requirements about the problem at hand, and design a solution that covers them well. Never assume things that were not explicitly stated.  Constraints consist of either the amount of traffic or the amount of data that our system needs to handle      Find the data per second(read and written), and memory required           Imagine this is your startup idea and you are designing your system. This way, you would eliminate many assumptions that you would normally make when you try and replicate a well-established system like bit.ly or Google.       Abstract Design   Once you’ve scoped the system you’re about to design, you should continue by outlining a high-level abstract design. The goal of this is to outline all the important components that your architecture will need.  Sketch your main components and the connections between them. If you do this, very quickly you will be able to get feedback if you are moving in the right direction. Of course, you must be able to justify the high-level design that you just drew.  Don’t get lured to dive deep into some particular aspect of the abstract design. Not yet. Rather, make sure you sketch the important components and the connections between them. Justify your ideas in front of the interviewer and try to address every constraint and use case.  Usually, this sort of high-level design is a combination of well-known techniques, which people have developed. You have to make sure you are familiar with what’s out there and feel comfortable using this knowledge.Understanding Bottlenecks   Most likely your high-level design will have one or more bottlenecks given the constraints of the problem. This is perfectly ok. You are not expected to design a system from the ground up, which immediately handles all the load in the world. It just needs to be scalable, in order for you to be able to improve it using some standard tools and techniques.  Now that you have your high-level design, start thinking about what bottlenecks it has. Perhaps your system needs a load balancer and many machines behind it to handle the user requests. Or maybe the data is so huge that you need to distribute your database on multiple machines. What are some of the downsides that occur from doing that? Is the database too slow and does it need some in-memory caching?  It may be the case that the interviewer wants to direct the discussion in one particular direction. Then, maybe you won’t need to address all the bottlenecks but rather talk in more depth about one particular area. In any case, you need to be able to identify the weak spots in a system and be able to resolve them.  Remember, usually each solution is a trade-off of some kind. Changing something will worsen something else. However, the important thing is to be able to talk about these trade-offs, and to measure their impact on the system given the constraints and use cases defined.Scaling the Abstract Design   There is a common set of scalability principles that you need to know. Knowing what they are, understanding how they are used, and being able to discuss their pros and cons is what scalability at interviews is all about.","categories": ["Tech"],
        "tags": [],
        "url": "http://localhost:4000/portfolio/2017-10-27-system-design-and-scalability",
        "teaser":"http://localhost:4000/images/avatar.jpg"},{
        "title": "Android Notes",
        "excerpt":"Notes taken during Grow with google Android Dev course on Udacity General Notes       Important project settings can be found in File —&gt; Project Structure —&gt; app —&gt; flavors         HAXM is the kernel driver used for hardware virtualization by AVDs on Windows and Mac     ​   Lesson 2 What happens when you hit run in Android Studio? When you hit run in Android studio, first the code is compiled into byte code that can be run in the run time on the device. Gradle builds this code and packages this byte code along with the application’s resources into an android application package (.apk) file (apk is a specialized zip format). Android studio then signs it and pushes it to the device using the android debug bridge (adb). What is Gradle? Gradle is the build system of choice for Android Studio. Because of that, there’s various functionality available within the platform. When you make a project, there are a few gradle build scripts automatically generated for you. Gradle scripts are also run before running the project, if anything has changed since the last build. A gradle task represents a single, atomic piece of work for a build. Components An Android Application is a collection of components that interact with each other. There are 4 types of components that make up an app:   Activity - window that your app uses to receive events from the system  Service  Content Providers  Broadcast ReceiversAndroid knows about each of these because they are registered in the **android manifest.** Activity   An activity is a single focused thing that the user can do. Activities are responsible for creating the window that your application uses to draw and receive events from the system.  From the user’s perspective, an application is a series of linked activities, starting from the one that is started from the launcher.  An activity is registered with the launcher by specifying an intent filter in the application —&gt; activity tag in the android manifest file.  An activity creates views to show the user information, and to let the user interact with the activity. An activity determines what views to create (and where to put them), by reading an XML layout file. setContentView(R.layout.activity_main) causes the XML layout to be inflated, converting everything in the XML file to a heirarchy of view objects in memory.Views       Views are a class in the Android UI framework. They occupy a rectangular area on the screen and are responsible for drawing and handling events.         There are two major categories of views: UI Components and Container Views.         Examples of Container Views:        How do the XML Layouts relate to the Java Activites? After you create your XML Layout you need to associate it with your activity. This is done in the onCreate method of the Activity using the method setContentView. You pass a reference to the layout file as R.layout.name_of_layout The R Class When your application is compiled the R class is generated. It creates constants that allow you to dynamically identify the various contents of the res folder, including layouts. setContentView() So what is the setContentView method doing? It inflates the layout. Essentially what happens is that Android reads your XML file and generates Java objects for each of the tags in your layout file. You can then edit these objects in the Java code by calling methods on the Java objects. Responsive Design The android UI needs to scale to different resolutions and device widths used by various devices. FrameLayout, ConstraintLayout and LinearLayout are the 3 basic layouts we should be using. Always use the simplest layout that gets the job done.   FrameLayout: use for simple layouts when we have only one child view. (example a list view which would fill the entire screen content area)  LinearLayout: use for stacking views horizontally or vertically against each other, and to break up the display proporationally between them.  ConstraintLayout: This is a more complicated, but a very powerful layout. We can position each child view relative to the parent or relative to each other.ConstraintLayout Basics Useful links: google codelabs building responsive UI with constraint layout a. Use a baseline constraint By using a baseline constraint, you can vertically align elements that have text, such as a TextView, EditText, or Button, so that the text baselines are aligned. Use baseline constraints to align elements that use different text sizes. Baseline constraints are also useful for aligning the text baselines of elements of different sizes.  Click the ab button to show the text baseline. Then click and drag from the TextView’s baseline, which is blinking in green, to the baseline of the Plain Text element, as shown in the following animated figure b. The Infer Constraints tool The Infer Constraints tool infers, or figures out, the constraints you need to match a rough layout of elements. It works by taking into account the positions and sizes of the elements. Drag elements to the layout in the positions you want them, and use the Infer Constraints tool to automatically create the constraint connections. - What’s the difference between Inference and Autoconnect? The Infer Constraints  tool calculates and sets constraints for all of the elements in a layout, rather than just the selected element. It bases its calculations on inferred relationships between the elements.The Autoconnect  tool creates constraint connections for a selected element to the element’s parent. c. Use ratios to size elements You can quickly resize elements by aspect ratio if at least one of the element’s dimensions is set to match constraints. d. Constrain to a guideline You can add a vertical or horizontal guideline to which you can constrain views, and the guideline will be invisible to app users. You can position the guideline within the layout based on either dp units or percent, relative to the layout’s edge. To create a guideline, click Guidelines in the toolbar, and then click either Add Vertical Guideline or Add Horizontal Guideline. Drag the dotted line to reposition it and click the circle at the edge of the guideline to toggle the measurement mode. e. Use barriers to align elements that dynamically vary in size Barriers allow you to specify a constraint based on multiple UI elements. You’ll want to use barriers any time that multiple elements could dynamically change their size based on user input or language. The barrierDirection is an attribute that controls how the barrier is positioned relative to the referenced views. A constraint to a barrier is just like a constraint to another element. However, users don’t see barriers, and barriers don’t add a level to the app’s view hierarchy, which means they don’t affect performance. f. Use chains to position multiple elements A chain is a group of elements that are linked to each other with bi-directional position constraints. When you create a chain, you can position all of the elements as a group. For example, you can center all of your chained elements as if they were a single element. Some chain modes:   Packed: The elements are packed together, as shown above.  Spread: The elements are spread out over the available space.  Spread inside: Similar to Spread, but the endpoints of the chain are not spread out.Lesson 3 Logging A good practice is to have the class name as the TAG in logs. Log levels: WTF, ERROR, WARN, INFO, DEBUG, VERBOSE ","categories": ["Tech"],
        "tags": [],
        "url": "http://localhost:4000/portfolio/2018-01-17-android-notes",
        "teaser":"http://localhost:4000/images/avatar.jpg"},{
        "title": "iOS Notes",
        "excerpt":"iOS Training - Big Nerd Ranch Instructor: Zachary Waldowski (zachary@bignerdranch.com) General Notes   Xcode comes with an iOS simulator, not emulator . The difference between emulators and simulators is that emulators mimic the software and hardware environments found on actual devices. Simulators, on the other hand, only mimic the software environment; they otherwise have access to all of the host system’s (the laptop’s) hardware resources such as disk space, memory and processor speed.  Main.storyboard –&gt; description of UI in the application.  control + drag to activate layout constraints between 2 views  alt + click –&gt; see data type  To connect views to their references in the code, go to Controller View, and in the connections inspector, connect the variables declared in code to the UI elements.  To create actions for methods, drag the action from connections inspector to the code to create a new action. It’s easier to use the Assistant editor to see both the ViewController.swift and the Main.storyboard.  Vertical spacing is similar to relative positioning. It is relative to two views.  Swift is a statically typed and a strongly typed language.  Unlike Android, the app or the activity is not relaunched when the screen is rotated. This is because iOS has separate view heirarchy process and a separate view layout process. Layout constraints are applied during the view layout process.  Many iOS frameworks are still written in Objective-C even though we interact with them through Swift.  The @discardableResult annotation before the func keyword in the function definition means that a caller of this function is free to ignore the result of calling this function.  When writing iOS applications, it is important to treat each UIViewController as its own little world. The stuff that has already been implemented in Cocoa Touch will do the heavy lifting.  Instead of assigning a value to the property directly, the value is sometimes set using a closure. Using a closure like this allows you to set the value for a variable or constant that requires multiple lines of code, which can be very useful when configuring objects. This makes your code more maintainable because it keeps the property and the code needed to generate the property together.MVC iOS follows Model-View-Controller pattern. In the MVC design pattern, which iOS developers do their best to follow, each class falls into exactly one of the following categories:   model: holds data and knows nothing about the UI  view: is visible to the user and knows nothing about the model objects  controller: keeps the UI and the model objects in sync and controls the flow of the application Sample app code: ////  ViewController.swift//  Quiz////  Created by Parth Mehta on 3/18/19.//  Copyright © 2019 Big Nerd Ranch. All rights reserved.//import UIKitclass ViewController: UIViewController {        let questions: [String] = [        \"From what is congnac made?\",        \"What is 7 + 7?\",        \"What is the capital of Vermont?\"    ]    let answers: [String] = [        \"Who knows\",        \"14\",        \"Montepelier\"    ]        var currentQuestionIndex = 0;    @IBOutlet var questionLabel: UILabel?    @IBOutlet var answerLabel: UILabel?        override func viewDidLoad() {        super.viewDidLoad()                let question = questions[currentQuestionIndex]        questionLabel?.text = question    }    @IBAction func onTapShowAction(_ sender: Any) {        let answer = answers[currentQuestionIndex]        answerLabel?.text = answer    }        @IBAction func onnTapNextQuestion(_ sender: Any) {        answerLabel?.text = \"????\"        currentQuestionIndex = (currentQuestionIndex + 1) % questions.count                let question = questions[currentQuestionIndex]        questionLabel?.text = question    }} Only this much code to create the question answer app!! :D Swift Basics Optionals and Optional Binding   An optional lets you express the possibility that a variable may not store a value at all. The value of an optional will either be an instance of the specified type or nil.  Allows the developer to indicate that an instance of any data type may be nil.  Note that before using the optional variables like normal variables, you must unwrap the optional and address the possibility of it being nil.  Use ‘if let’ to check values and conditionally perform logic (optional binding).  Two ways of unwrapping an optional variable: optional binding and forced unwrapping.  Subscripting dictionaries: Recall that subscripting an array beyond its bounds causes a trap. Dictionaries are different. The result of subscripting a dictionary is an optional:let titles = [\"Leader\": \"Dear Leader\", \"Commandante\": \"Commandante\", \"Brightlord\": \"Brightlord\"]var optionalTitle: String? = titles[\"Leader\"]var greeting = \"Hello\"if let title = optionalTitle {    greeting += \" \\(title)\"} // Note that here, we convert the optional optionalTitle to a String// greeting += \" \\(optionalTitle!)\" // crash if optionalTitle  == nilCollections: Array var bros: [String] = [\"Matt\",\"Scott\",\"Josh\",\"Nick\"] // could also infer typebros += [\"Brian\"] // [\"Matt\",\"Scott\",\"Josh\",\"Nick\",\"Brian\"]bros[3] = \"Brandon\" // [\"Matt\",\"Scott\",\"Josh\",\"Brandon\",\"Brian\"]bros.removeAtIndex(4) // [\"Matt\",\"Scott\",\"Josh\",\"Brandon\"]Collections: Dictionary var etBroHome: [String: String] = [\"Matt\": \"GA\",\"Scott\": \"DC\"]etBroHome[\"Brian\"] = \"GA\" // [\"Matt\": \"GA\",\"Scott\": \"DC\",\"Brian: GA\"]if let oldMattSt = etBroHome.updateValue(\"CA\", forKey:\"Matt\") {    print(\"Old state: \\(oldMattSt)\")}Control Flow: Conditional Statements ‘if’ executes a set of statements if expression evalutates to true var swiftIsAwesome: Bool = trueif swiftIsAwesome {    print(\"Duh\")} else {    print(\"Something went wrong.\")}‘switch’ statements compare a value against a number of cases // Very imp thing to note is the absence of break statements. Swift break statements don't fall through by default. You can however, specify it to fall through. You can't fall through multiple cases though.let favoriteFood: String = \"Cookie Pie\"var comment: Stringswitch favoriteFood {    case \"Vegetables\":        comment = \"Ew\"    case \"Fruit\":        comment = \"Okay...\"    case let x where x.hasSuffix(\"Pie\"): // this assigns x = favoriteFood first        comment = \"\\(x) sounds good!\"    default:        comment = \"Tell me more...\"}Control Flow: For-in Loop // Note that there is not manual version of the for-loop. If we need to use a manual version, we can use a while loop.for index in 1..&lt;5 {    print(index) // 1 2 3 4}for index in 1...5 {    print(index) // 1 2 3 4 5}var things = [\"socks\",\"bannana\",\"ennui\"]for word in things {    print(word)}var etBroHome = [\"Matt\": \"GA\",\"Scott\": \"DC\"] // infers typefor (name, state) in etBroHome {    print(name, state) // (Matt, GA); (Scott, DC)}Functions // pay attention to the return type and the external parameter namefunc printNumber(number: Int) {    print(number)}printNumber(5) // logs 5 to consolefunc equalToTen(myNumber number: Int) -&gt; Bool {     // myNumber is an explicitly named external parameter    return number == 10}equalToTen(myNumber: 5) // falsefunc hasMatches(list: [Int], condition: (Int -&gt; Bool)) -&gt; (Bool, Int) {    var count = 0    var hasMatch = false    for item in list {        if condition(item) {\t\t\tcount += 1         }    }    hasMatch = count != 0    return (hasMatch, count)}var numbers = [10, 20, 21, 10]print(\"Has matches: \\(hasMatches(numbers, condition: equalToTen))\") // (true, 2)Closures var moreNumbers = [10,3,11,24]let newNumbers = moreNumbers.map {    (number) -&gt; Int in   \t\t\t// in is just a seperator that separates params from \t\t\t\t\t\t\t\t\t\tthe function body in closures    return number % 2 != 0 ? 0 : number * 3}print(newNumbers) // [30,0,0,72]Structs struct House {    var hotTubs: Int    func describeHouse() -&gt; String { return \"House has \\(hotTubs) hot tubs!\" }}var myHouse = House(hotTubs: 4)print(myHouse.describeHouse()) // House has 4 hot tubs!Classes class Parent: Person {    var hasChildren: Bool    static var hasStaticChildren: Bool \t\t// class level variable    init(hasChildren: Bool) {        // constructor. Note that all inits are functions.        // You can also have destructors called dinit()        self.hasChildren = hasChildren    }    class func exampleTypeMethod() {        // class level method        // like a static method in Java?    \t// stuff here    }    func exampleInstanceMethod() {        // instance level method    \t// stuff here    }}var john = Parent(hasChildren: true)Parent.exampleTypeMethod()john.exampleInstanceMethod()// The way we assign innitialisation values are safer in Swiftclass Parent: Person {    var hasChildren: Bool    init(name: String, heightInMeters: Double, hasChildren: Bool) {        self.hasChildren = hasChildren        super.init(name: name, heightInMeters: heightInMeters)    }}var john = Parent(name: \"John\", heightInMeters: 1.8, hasChildren: true)Differences between Classes and Structs in Swift   Class instances are shared in memory.  Class instances are copied by reference, struct instances are copied by value, i.e. Each copy of a struct is a new instance.  Contents of classes are mutable by all instances, irrespective of whether they are defined as let  or const, unlike in structs.  Structs have default initializers, unlike classes. Classes need initializers to be defined by us.Properties struct Meal {    var time: Int    var duration: Int}struct Day {    let name: String    var breakFast: Meal    var intervalBetweenMeals: Int    var lunch: Meal {\t\tget {            let time = breakFast.time + breakFast.duration + intervalBetweenMeals            let duration = breakFast.duration            return Meal(time: time, duration: duration)        }        set(newLunch) {            breakFast.time = newLunch.time - intervalBetweenMeals            breakFast.duration = newLunch.duration        }    }}let aMeal = Meal(time: 8, duration: 1)var aDay = Day(name: \"Monday\", breakFast: aMeal, intervalBetweenMeals: 3)aDay.lunch // name = Monday; time = 12; duration = 1Protocols // Protocols are similar to interfaces in Java and you can conform to multiple protocols (this is how you can achieve multiple inheritance in Swift).protocol ExampleProtocol {    mutating func doSomething()    var aReadonlyIntProperty: Int { get }    var aReadwriteStringProperty: String { get set }}class SomeClass: ExampleProtocol {    func doSomething     {         // code here    }    // getter for aReadOnlyIntProperty here    // getter and setter for aReadWriteStringProperty here}Extensions // add custom vars and methods to the basic types in Swift.// Note the visibility of these extensions is across the entire project.extension Int: ExampleProtocol {    var timesFive: Int {        return self * 5    }    mutating func doSomething {    // code here     }}5.doSomething5.timesFive // 25Generics func swapTwoValues&lt;T&gt;(inout a: T, inout b: T) { \tlet temporaryA = a\ta = b    b = temporaryA         // (a, b) = (b, a)}swapTwoValues(&amp;someInt, &amp;anotherInt)swapTwoValues(&amp;someString, &amp;anotherString)protocol RemoveInstance {    typealias ItemType    mutating func removeInstance(item: ItemType)}Views Basics Views Views are objects that are visible to the user, like buttons, text fields, and sliders. View objects make up an application’s UI. A view:   is an instance of UIView or one of its subclasses  knows how to draw itself  can handle events, like touches  exists within a hierarchy of views whose root is the application’s windowThe View Hierarchy Every application has a single instance of UIWindow that serves as the container for all the views in the application. UIWindow is a subclass of UIView, so the window is itself a view. The window is created when the application launches. Once the window is created, other views can be added to it.  Views and Frames When the application is launched, the view for the initial view controller is added to the root-level window. This view controller is represented by the ViewController class defined in ViewController.swift. Creating a view programmatically. let rect = CGRect(x: 0, y: 0, width: 20, height: 20)let squareView = UIView(frame: rect)someOtherView.addSubview(squareView)  Note: that these values are in points, not pixels. If the values were in pixels, then they would not be consistent across displays of different resolutions (i.e., Retina versus non-Retina). A point is a relative unit of a measure; it will be a different number of pixels depending on how many pixels are in the display. Sizes, positions, lines, and curves are always described in points to allow for differences in display resolution. Frame Vs. Bounds Frame boundaries are the boundaries of the view, from where to where the view is displayed. Bounds, on the other hand are the limits of the content of the view. Think about scrolling in a maps view. The alignment rectangle is very similar to the frame. In fact, these two rectangles are often the same. Whereas the frame encompasses the entire view, the alignment rectangle only encompasses the content that you wish to use for alignment purposes. You cannot define a view’s alignment rectangle directly. You do not have enough information (like screen size) to do that. Instead, you provide a set of constraints. Taken together, these constraints enable the system to determine the layout attributes, and thus the alignment rectangle, for each view in the view hierarchy.  What other information does a view have? // Hierarchy (Painter's method):var window: UIWindow? { get }var superview: UIView? { get }var subviews: [UIView] { get }func addSubview(_ view: UIView)func insertSubview(_ view: UIView, at index: Int)// Location of view:var frame: CGRectvar bounds: CGRect// Display properties:var backgroundColor: UIColor?var hidden: Boolvar alpha: CGFloatAuto Layout Auto Layout is a crucial technology for every iOS developer. It helps you create flexible layouts that work across a range of devices and interface sizes. It also takes a lot of practice to master.  Constraints Menu In addition to using cntrl+drag to create relative positioning between 2 views, we also define constraints to the view.   If a view does not have any siblings in the specified direction, then the nearest neighbor is its superview, also known as its container. Align Menu  View Controller A view controller is an instance of a subclass of UIViewController. A view controller manages a view hierarchy. It is responsible for creating view objects that make up the hierarchy and for handling events associated with the view objects in its hierarchy. Just think of a view controller as one view hierarchy. When an app switches between view controllers, it just means that it is switching between two different view heirarchies. The View of a View Controller As subclasses of UIViewController, all view controllers inherit an important property: var view: UIView!This property points to a UIView instance that is the root of the view controller’s view hierarchy. When the root  view of a view controller is added as a subview of the window, the view controller’s entire view hierarchy is added .  A view controller’s view is not created until it needs to appear on the screen. This optimization is called lazy loading, and it can conserve memory and improve performance. There are two ways that a view controller can create its view hierarchy:   in Interface Builder, by using an interface file such as a storyboard  programmatically, by overriding the UIViewController method loadView()  NOTE: Although a storyboard can have many view controllers, each storyboard file has exactly one initial view controller. The initial view controller acts as an entry point into the storyboard. How does UIWindow handle the view controllers? UIWindow has a rootViewController property. When a view controller is set as the window’s rootViewController, that view controller’s view gets added to the window’s view hierarchy. When this property is set, any existing subviews on the window are removed and the view controller’s view gets added to the window with the appropriate Auto Layout constraints. Each application has one main interface, a reference to a storyboard. When the application launches, the initial view controller for the main interface gets set as the rootViewController of the window. The main interface for an application is set in the project settings. In the General tab of the project settings, find the Deployment Info section. Here you will see the Main Interface setting. If it is set to Main, for example, it corresponds to Main.storyboard. Tab Bar Controllers UITabBarController keeps an array of view controllers. It also maintains a tab bar at the bottom of the screen with a tab for each view controller in its array. Tapping on a tab results in the presentation of the view of the view controller associated with that tab. UITabBarController is itself a subclass of UIViewController. A UITabBarController’s view is a UIView with twoprimary subviews: the tab bar and the view of the selected view controller  Tab bar items Each tab on the tab bar can display a title and an image, and each view controller maintains a tabBarItem property for this purpose. When a view controller is contained by a UITabBarController, its tab bar item appears in the tab bar. The order of the tabs is determined by the order of the view controllers within the tab bar controller’s viewControllers array. Accessing subviews Often, you will want to do some extra initialization or configuration of subviews defined in Interface Builder before they appear to the user. So where can you access a subview? There are two main options, depending on what you need to do. The first option is the viewDidLoad() method. This method is called after the view controller’s interface file is loaded, at which point all of the view controller’s outlets will reference the appropriate objects. The second option is another UIViewController method, viewWillAppear. This method is called just before a view controller’s view is added to the window. Which should you choose? Override viewDidLoad() if the configuration only needs to be done once during the run of the app. Override viewWillAppear if you need the configuration to be done each time the view controller’s view appears onscreen. Interacting with View Controllers and Their Views Let’s look at some methods that are called during the lifecycle of a view controller and its view. Some of these methods you have already seen, and some are new.       init(coder:) is the initializer for UIViewController instances created from a storyboard. When a view controller instance is created from a storyboard, its init(coder:) gets called once.         init(nibName:bundle:) is the designated initializer for UIViewController.     When a view controller instance is created without the use of a storyboard, its init(nibName:bundle:) gets called once. Note that in some apps, you may end up creating several instances of the same view controller class. This method will get called once on each view controller as it is created.         loadView() is overridden to create a view controller’s view programmatically.         viewDidLoad() is overridden to configure views created by loading an interface file. This method gets called after the view of a view controller is created.         viewWillAppear(_:) is overridden to configure views created by loading an interface file.     This method and viewDidAppear(:)** get called every time your view controller is moved onscreen. **viewWillDisappear(:) and viewDidDisappear(_:) get called every time your view controller is moved offscreen.   Programmatic View Composition UIView has an instance method addSubview(_:) which let’s you add a child view to its subviews collec4on. Other useful methods:   bringSubview(toFront:)  sendSubview(toBack:)  removeFromSuperview()  NOTE: When using bringSubview and sendSubview, remember that the view to be brought back or sent forward is also already loaded (no lazy loading here). Programmatic Constraints   Note:             Constraints need to be added to the most recent common ancestor for the views associated with the constraint.               Creating and activating constraints are two different steps.       let leadingAlignConstraint =    view1.leadingAnchor.constraint(equalTo: view2.leadingAnchor)leadingAlignConstraint.isActive = true Layout Margin Guides Every view has a layoutMargins property that denotes the default spacing to use when laying out content. This property is an instance of UIEdgeInsets, which you can think of as a type of frame. When adding constraints, you will use the layoutMarginsGuide, which exposes anchors that are tied to the edges of the layoutMargins. The primary advantage of using the margins is that the margins can change depending on the device type (iPad or iPhone) as well as the size of the device. Using the margins will give you content that looks good on any device. let margins = view.layoutMarginsGuidelet constraint =    someView.leadingAnchor.constraint(equalTo: margins.leadingAnchor)constraint.isActive = trueLayout Safe Area Guides View instances have a property to assist with layout content: the safeAreaLayoutGuide. This layout guide represents the rectangular extent to which the a view will be visible on screen. Using safeAreaLayoutGuide will allow your content to not underlap the status bar at the top of the screen or the tab bar at the bottom of the screen. Layout guides like safeAreaLayoutGuide expose anchors that you can use to add constraints, such as : topAnchor, bottomAnchor, heightAnchor and widthAnchor. Because you want the segmented control to be under the status bar and sensor housing, you will constrain the top anchor of the safe area layout guide to the top anchor of the segmented control. let constraint =    someView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor,constant: 20)constraint.isActive = trueControls func loadView() {    ...    let button = UIButton(type: .system)    // this is similar to what we do in the interface builder by dragging and dropping.    button.addTarget(self,           action: #selector(buttonTapped(_:)),           for: .touchUpInside)    ...}func buttonTapped(_ sender: UIButton) {    // do something}Control Events  Q. When exactly is the loadview() method called? When a view controller is created, its view property is nil. If a view controller is asked for its view and its view is nil, then the loadView() method is called.   NOTE:  Apple recommends that you create and constrain your views in Interface Builder whenever possible. However, if your views are created in code, then you will need to constrain them programmatically.   NOTE: Every view has an autoresizing mask. By default, iOS creates constraints that match the autoresizing mask and adds them to the view. These translated constraints will often conflict with explicit constraints in the layout and cause an unsatisfiable constraints problem. The fix is to turn off this default translation by setting the property translatesAutoresizingMaskIntoConstraints to false. Text Input &amp; Delegation Delegation is an object-oriented approach to callbacks. A callback is a function that is supplied in advance of an event and is called every time the event occurs. Some objects need to make a callback for more than one event. For instance, the text field needs to “callback” when the user enters text as well as when the user presses the Return key. However, there is no built-in way for two (or more) callback functions to coordinate and share information. This is the problem addressed by delegation – you supply a single delegate to receive all of the event-related callbacks for a particular object. This delegate object can then store, manipulate, act on, and relay the information from the callbacks as it sees fit.  textField.delegate = self // Our controller// In our controllerfunc textFieldShouldReturn(_ textField: UITextField) -&gt; Bool {    print(textField.text)    // dismisses the keyboard and gives up the first responder status    textField.resignFirstResponder()     return true // whether to perform the default action or not? default action is nothing  in this particular case.}  Conforming to this Protocol (it’s just like an interface in Java) class MyViewController: UIViewController, UITextFieldDelegate {}  NOTE: When the text field is tapped, the method becomeFirstResponder() is called on it. This is the methodthat, among other things, causes the keyboard to appear. To dismiss the keyboard, you call the methodresignFirstResponder() on the text field.   NOTE: A property observer, is a chunk of code that gets called whenever a property’s value changes. A property observer is declared using curly braces immediately after the property declaration. Inside the braces, you declare your observer using either willSet or didSet, depending on whether you want to be notified immediately before or immediately after the property value changes, respectively. Note that property observers are not triggered when the property value is changed from within an initializer. Internalization and Localization Internationalization is making sure your native cultural information (like language, currency, date format, number format, etc.) is not hardcoded into your application. Localization is the process of providing the appropriate data in your application based on the user’s Language and Region Format settings.   NOTE: Locale knows everything about local customs.   Some formatters to keep in Mind   Date Formatters  NumberFormatter  DateComponentsFormatter  DateIntervalFormatter  MassFormatter  EnergyFormatter  LengthFormatter  Address FormatterWhen internationalizing, you ask the instance of Locale questions. But the Locale only has a few region-specific variables. This is where localization – creating application-specific substitutions for different region and language settings – comes into play. Localization usually involves either generating multiple copies of resources (like images, sounds, and interface files) for different regions and languages or creating and accessing strings tables to translate text into different languages. When you build a target in Xcode, an application bundle is created. All of the resources that you added to the target in Xcode are copied into this bundle along with the executable itself. This bundle is represented at runtime by an instance of Bundle known as the main bundle. Many classes work with the Bundle to load resources. Localizing a resource puts another copy of the resource in the application bundle. These resources are organized into language-specific directories, known as lproj directories. Each one of these directories is the name of the localization suffixed with lproj. For example, the American English localization is en_US, where en is the English language code and US is the United States of America region code, so the directory for American English resources is en_US.lproj. (The region can be omitted if you do not need to make regional distinctions in your resource files.) These language and region codes are standard on all platforms, not just iOS. When a bundle is asked for the path of a resource file, it first looks at the root level of the bundle for a file of that name. If it does not find one, it looks at the locale and language settings of the device, finds the appropriate lproj directory, and looks for the file there. Thus, just by localizing resource files, your application will automatically load the correct file. One option for localizing resource files is to create separate storyboard files and manually edit each string in each file. However, this approach does not scale well if you are planning multiple localizations. What happens when you add a new label or button to your localized storyboard? You have to add this view to the storyboard for every language. Not fun. To simplify the process of localizing interface files, Xcode has a feature called base internationalization. Base internationalization creates the Base.lproj directory, which contains the main interface files. Localizing individual interface files can then be done by creating just the Localizable.strings files. It is still possible to create the full interface files, in case localization cannot be done by changing strings alone. NSLocalizedString and strings tables In many places in your applications, you create String instances dynamically or display string literals to the user. To display translated versions of these strings, you must create a strings table. A strings table is a file containing a list of key-value pairs for all of the strings that your application uses and their associated translations. It is a resource file that you add to your application, but you do not need to do a lot of work to get data from it. Table Views As a view object, a UITableView does not handle application logic or data. When using a UITableView, you must consider what else is necessary to get the table working in your application:   A UITableView typically needs a view controller to handle its appearance on the screen.  A UITableView needs a data source. A UITableView asks its data source for the number of rows to display, the data to be shown in those rows, and other tidbits that make a UITableView a useful UI. Without a data source, a table view is just an empty container. The dataSource for a UITableView can be any type of object as long as it conforms to the UITableViewDataSource protocol.  A UITableView typically needs a delegate that can inform other objects of events involving the UITableView. The delegate can be any object as long as it conforms to the UITableViewDelegate protocol.An instance of the class UITableViewController can fill all three roles: view controller, data source, and delegate. UITableViewController is a subclass of UIViewController and therefore has a view. A UITableViewController’s view is always an instance of UITableView, and the UITableViewController handles the preparation and presentation of the UITableView. When a UITableViewController creates its view, the dataSource and delegate properties of the UITableView are automatically set to point at the UITableViewController.  Custom Initializers for classes Classes can have two kinds of initializers: designated initializers and convenience initializers. A designated initializer is a primary initializer for the class. Every class has at least one designated initializer. A designated initializer ensures that all properties in the class have a value. Once it ensures that, a designated initializer calls a designated initializer on its superclass (if it has one). When you implement your own custom initializer, you lose the free initializer – init() – that classes have. The free initializer is useful when all of your class’s properties have default values and you do not need to do additional work to create the new instance. Every class must have at least one designated initializer, but convenience initializers are optional. You can think of convenience initializers as helpers. A convenience initializer always calls another initializer on the same class. Convenience initializers are indicated by the convenience keyword before the initializer name. Convenience initializers must call another initializer on the same type, whereas designated initializers must call a designated initializer on its superclass. Dependency Inversion Principle —&gt; V.IMP       The essential goal of this principle is to decouple objects in an application by inverting certain dependencies between them. This results in more robust and maintainable code.         The dependency inversion principle states that:     High-level objects should not depend on low-level objects. Both should depend on abstractions.  Abstractions should not depend on details. Details should depend on abstractions.Example - The abstraction required by the dependency inversion principle in LootLogger is the concept of a “store.” A store is a lower-level object that retrieves and saves Item instances through details that are only known to that class. ItemsViewController is a higher-level object that only knows that it will be provided with a utility object (the store) from which it can obtain a list of Item instances and to which it can pass new or updated Item instances to be stored persistently. This results in a decoupling because ItemsViewController is not dependent on ItemStore. In fact, as long as the store abstraction is respected, ItemStore could be replaced by another object that fetches Item instances differently (such as by using a web service) without any changes to ItemsViewController.   A common pattern used when implementing the dependency inversion principle is dependency injection. In its simplest form, higher-level objects do not assume which lower-level objects they need to use. Instead, those are passed to them through an initializer or property.  In our implementation of ItemsViewController, we used injection through a property to give it a store.Data Source Methods When a UITableView wants to know what to display, it calls methods from the set of methods declared in the UITableViewDataSource protocol. UITableViewCells   Each row of a table view is a view. These views are instances of UITableViewCell.  A cell itself has one subview – its contentView. The contentView is the superview for the content of the cell. The cell may also have an accessory view.  The accessory view shows an action-oriented icon, such as a checkmark, a disclosure icon, or an information button. These icons are accessed through predefined constants for the appearance of the accessory view. The default is UITableViewCellAccessoryType.none.  The real meat of a UITableViewCell is the contentView, which has three subviews of its own. Two of those subviews are UILabel instances that are properties of UITableViewCell named textLabel and detailTextLabel. The third subview is a UIImageView called imageView. In this chapter, you will use textLabel and detailTextLabel. Reusing UITableViewCells   iOS devices have a limited amount of memory. If you were displaying a list with thousands of entries in a UITableView, you would have thousands of instances of UITableViewCell. Most of these cells would take up memory needlessly. After all, if the user cannot see a cell onscreen, then there is no reason for that cell to have a claim on memory.  To conserve memory and improve performance, you can reuse table view cells. When the user scrolls the table, some cells move offscreen. Offscreen cells are put into a pool of cells available for reuse. Then, instead of creating a brand new cell for every request, the data source first checks the pool. If there is an unused cell, the data source configures it with new data and returns it to the table view.  There is one problem to be aware of: Sometimes a UITableView has different types of cells. Occasionally, you subclass UITableViewCell to create a special look or behavior. However, different subclasses floating around the pool of reusable cells create the possibility of getting back a cell of the wrong type. You must be sure of the type of the cell returned so that you can be sure of what properties and methods it has.  Note that you do not care about getting any specific cell out of the pool because you are going to change the cell content anyway. What you need is a cell of a specific type. The good news is that every cell has a reuseIdentifier property of type String. When a data source asks the table view for a reusable cell, it passes a string and says, “I need a cell with this reuse identifier.” By convention, the reuse identifier is typically the name of the cell class.  To reuse cells, you need to register either a prototype cell or a class with the table view for a specific reuse identifier. The reuse identifier is an arbitrary string.  The method dequeueReusableCell(withIdentifier:for:) will check the pool, or queue, of cells to see whether a cell with the correct reuse identifier already exists. If so, it will “dequeue” that cell. If there is not an existing cell, a new cell will be created and returned.Editing Table Views One of the great feature of table views is their built-in support for editing. This includes inserting new rows, deleting existing rows, and rearranging rows. In this section, you will add in support for all three of those features to LootLogger. Editing Mode UITableView has an editing property, and when this property is set to true, the UITableView enters editing mode. Once the table view is in editing mode, the rows of the table can be manipulated by the user. Depending on how the table view is configured, the user can change the order of the rows, add rows, or remove rows. (Editing mode does not allow the user to edit the content of a row.)  Adding and Deleting Items Remember that the role of a view object is to present model objects to the user; updating views without updating the model objects is not very useful. Design Patterns The consistent use of design patterns throughout the development process reduces the mental overhead in solving a problem so you can create complex applications more easily and rapidly. Here are some of the design patterns that Apple is very consistent with:   Delegation: One object delegates certain responsibilities to another object. We used delegation with the UITextField to be informed when the contents of the text field change.  Data source: A data source is similar to a delegate, but instead of reacting to another object, a data source is responsible for providing data to another object when requested. We used the data source pattern with table views: Each table view has a data source that is responsible for, at a minimum, telling the table view how many rows to display and which cell it should display at each index path.  Model-View-Controller: Each object in your applications fulfills one of three roles. Model objects are the data. Views display the UI. Controllers provide the glue that ties the models and views together.  Target-action pairs: One object calls a method on another object when a specific event occurs. The target is the object that has a method called on it, and the action is the method being called. For example, we used target- action pairs with buttons: When a touch event occurs, a method will be called on another object (often a view controller).Subclassing UITableViewCell A UITableView displays a list of UITableViewCell objects. For many applications, the basic cell with its textLabel, detailTextLabel, and imageView is sufficient. However, when you need a cell with more detail or a different layout, you subclass UITableViewCell. Customizing the Cell   You customize the appearance of UITableViewCell subclasses by adding subviews to its contentView. Adding subviews to the contentView instead of directly to the cell itself is important because the cell will resize the contentView inside it at certain times.  For example, when a table view enters editing mode, the contentView resizes itself to make room for the editing controls. If you added subviews directly to the UITableViewCell, the editing controls would obscure the subviews. The cell cannot adjust its size when entering edit mode (it must remain the width of the table view), but the contentView can and does. Dynamic Type Creating an interface that appeals to everyone can be daunting. Some people prefer more compact interfaces so they can see more information at once. Others might want to be able to easily see information at a glance, or perhaps they have poor eyesight. In short: People have different needs. Good developers strive to make apps that meet those needs. Dynamic Type is a technology that helps realize this goal by providing specifically designed text styles that are optimized for legibility. Users can select one of seven preferred text sizes from within Apple’s Settings application (plus a few additional larger sizes from within the Accessibility section), and apps that support Dynamic Type will have their fonts scaled appropriately. The Dynamic Type system is centered around text styles. When a font is requested for a given text style, the system will consider the user’s preferred text size in association with the text style to return an appropriately configured font.  Responding to user changes When the user changes the preferred text size and returns to the application, the table view will get reloaded. Unfortunately, the labels will not know about the new preferred text size. To fix this, you need to have the labels automatically adjust to content size changes. Open Main.storyboard and select all three ItemCell labels. Open the attributes inspector, and check the box for Automatically Adjusts Font Bad Cell Constraints  Since there are are no vertical constraints, the label will be centered with height 0 and would thus, be invisible. Better Cell constraints  Stack Views Auto Layout can be used to create flexible interfaces that scale across device types and sizes. Auto Layout is a very powerful technology, but with that power comes complexity. Laying out an interface well often needs a lot of constraints, and it can be difficult to create dynamic interfaces due to the need to constantly add and remove constraints. Interfaces that have a linear layout are great candidates for using a stack view. A stack view is an instance ofUIStackView that allows you to create a vertical or horizontal layout that is easy to lay out and manages most of the constraints that you would typically have to manage yourself. Perhaps best of all, you are able to nest stack views within other stack views, which allows you to create truly amazing interfaces in a fraction of the time.   Nesting stack views is very common when creating more complex layouts  A stack view’s “arranged views” are a subset of its “subviews”  –&gt; because views may be hidden.  Can dynamically add/remove views in a stack view  Can dynamically change any of the stack views propertiesProperties of StackView   Hiding Views inside Stackview class ViewController: UIViewController {    @IBAction func hideViewTapped(_ sender: UIButton) {        UIView.animate(withDuration: 1.0) {            sender.superview?.isHidden = true        }    }}Implicit Constraints A view has one of these priorities for each axis:   horizontal content hugging priority  vertical content hugging priority  horizontal content compression resistance priority  vertical content compression resistance priorityContent hugging priorities The content hugging priority is like a rubber band that is placed around a view. The rubber band makes the view not want to be bigger than its intrinsic content size in that dimension. Each priority is associated with a value from 0 to 1000. A value of 1000 means that a view cannot get bigger than its intrinsic content size on that dimension. Content compression resistance priorities The content compression resistance priorities determine how much a view resists getting smaller than its intrinsic content size. Segues   Most iOS applications have a number of view controllers that users navigate between. Storyboards allow you to set up these interactions as segues without having to write code.  A segue moves another view controller’s view onto the screen and is represented by an instance of UIStoryboardSegue.  Each segue has a style, an action item, and an identifier.  The style of a segue determines how the view controller will be presented.  The action item is the view object in the storyboard file that triggers the segue, like a button, a table view cell, or some other UIControl.  The identifier is used to programmatically access the segue. This is useful when you want to trigger a segue that does not come from an action item, like a shake or some other interface element that cannot be set up in the storyboard file.Passing Data Around Whenever a segue is triggered, the prepare(for:sender:) method is called on the view controller initiating the segue. This method has two arguments: the UIStoryboardSegue, which gives you information about which segue is happening, and the sender, which is the object that triggered the segue (a UITableViewCell or a UIButton, for example). The UIStoryboardSegue gives you three pieces of information: the source view controller (where the segue originates), the destination view controller (where the segue ends), and the identifier of the segue. The identifier lets you differentiate segues. Let’s give the segue a useful identifier. UINavigationController       A UINavigationController maintains an array of view controllers presenting related information in a stack. When a UIViewController is on top of the stack, its view is visible.         When you initialize an instance of UINavigationController, you give it a UIViewController. This UIViewController is added to the navigation controller’s viewControllers array and becomes the navigation controller’s root view controller. The root view controller is always on the bottom of the stack.           Note: While this view controller is referred to as the navigation controller’s “root view controller,” UINavigationController does not have a rootViewController property.             More view controllers can be pushed on top of theUINavigationController’s stack while the application is running. These view controllers are added to the end of the viewControllers array that corresponds to the top of the stack. UINavigationController’s topViewController property keeps a reference to the view controller at the top of the stack.         When a view controller is pushed onto the stack, its view slides onscreen from the right. When the stack is popped (i.e., the last item is removed), the top view controller is removed from the stack and its view slides off to the right, exposing the view of the next view controller on the stack, which becomes the top view controller.         The view of the topViewController is what the user sees.         UINavigationController is a subclass of UIViewController, so it has a view of its own. Its view always has two subviews: a UINavigationBar and the view of topViewController    Appearing and Disappearing Views   Whenever a UINavigationController is about to swap views, it calls two methods: viewWillDisappear(:) and viewWillAppear(:). The UIViewController that is about to be popped off the stack has viewWillDisappear(:) called. The UIViewController that will then be on top of the stack has viewWillAppear(:) called on it.  To hold on to changes in the data, when a DetailViewController is popped off the stack you will set the properties of its item to the contents of the text fields. When implementing these methods for views appearing and disappearing, it is important to call the superclass’s implementation – it might have some work to do and needs to be given the chance to do it.First Responder Status   For the shake and keyboard events, for example, there is no event location within your view hierarchy to determine which view will receive the event, so another mechanism must be used. This mechanism is the first responder status. Many views and controls can be a first responder within your view hierarchy – but only one at a time. Think of it as a flag that can be passed among views. Whichever view holds the flag will receive the shake or keyboard event.  Instances of UITextField and UITextView have an uncommon response to touch events. When touched, a text field or a text view becomes the first responder, which in turn triggers the system to put the keyboard onscreen and send the keyboard events to the text field or view. The keyboard and the text field or view have no direct connection, but they work together through the first responder status.  This is a neat way to ensure that the keyboard input is delivered to the correct text field. The concept of a first responder is part of the broader topic of event handling in Cocoa Touch programming that includes the UIResponder class and the responder chain. You can visit Apple’s Event Handling Guide for iOS for more information.UINavigationBar       Every UIViewController has a navigationItem property of type UINavigationItem. However, unlikeUINavigationBar, UINavigationItem is not a subclass of UIView, so it cannot appear on the screen.         Instead, the navigation item supplies the navigation bar with the content it needs to draw. When a UIViewController comes to the top of a UINavigationController’s stack, the UINavigationBar uses the UIViewController’s navigationItem to configure itself.         By default, a UINavigationItem is empty. At the most basic level, a UINavigationItem has a simple title string. When a UIViewController is moved to the top of the navigation stack and its navigationItem has a valid string for its title property, the navigation bar will display that string.              A navigation item can hold more than just a title string. There are three customizable areas for each UINavigationItem: a leftBarButtonItem, a rightBarButtonItem, and a titleView. The left and right bar button items are references to instances of UIBarButtonItem, which contain the information for a button that can only be displayed on a UINavigationBar or a UIToolbar.         Recall that UINavigationItem is not a subclass of UIView. Instead, UINavigationItem encapsulates information that UINavigationBar uses to configure itself. Similarly, UIBarButtonItem is not a view, but holds the information about how a single button on the UINavigationBar should be displayed. (A UIToolbar also uses instances of UIBarButtonItem to configure itself.)         The third customizable area of a UINavigationItem is its titleView. You can either use a basic string as the title or have a subclass of UIView sit in the center of the navigation item. You cannot have both. If it suits the context of a specific view controller to have a custom view (like a segmented control or a text field, for example), you would set the titleView of the navigation item to that custom view. Typically, however, a title string is sufficient.          When you initialize an instance of UINavigationController, you give it a UIViewController. ThisUIViewController is added to the navigation controller’s viewControllers array and becomes the navigation controller’s root view controller. The root view controller is always on the bottom of the stack.           Note: While this view controller is referred to as the navigation controller’s “root view controller,” UINavigationController does not have a rootViewController property.         More view controllers can be pushed on top of theUINavigationController’s stack while the application is running. These view controllers are added to the end of the viewControllers array that corresponds to the top of the stack. UINavigationController’s topViewController property keeps a reference to the view controller at the top of the stack.   Saving, Loading and Error Handling   NOTE: Saving and loading “data” almost always means saving and loading model objects.       To save and load model objects to and from the disk, we need to make them of type codable.         Types whose instances need to be codable conform to the Encodable and Decodable protocols and implement their two required methods, encode(to:) and init(from:), respectively.   protocol Decodable {    init(from decoder: Decoder) throws}protocol Encodable {    func encode(to encoder: Encoder) throws}Although your types can conform to just one of these protocols, it’s common for types to conform to both. Apple has a type alias for types that conform to both protocols called Codable. typealias Codable = Decodable &amp; Encodable Property Lists       A property list is a representation of some data that can be saved to disk and read back in at a later point. Property lists can represent hierarchies of data and so are a great tool for saving and loading lightweight object graphs.     Under the hood, property list data can be represented by a number of formats, they are frequently represented using an XML or binary format.  Property lists can hold the following types: Array, Dictionary, String, Data, Date, Int, Float, and Bool. As long as a given type is composed of those types, or a hierarchy of those types, then it can be represented as a property list.func saveChanges() -&gt; Bool {        let encoder = PropertyListEncoder()    // You will have an error on the next line, for not catching errors.    let data = encoder.encode(allItems)    return false}Error Handling   Optionals provide a simple way to represent failure when you do not care about the reason for failure. When you need to know why something failed, an optional will not provide enough information.  If a method could generate an error, its method signature needs to indicate this using the throws keyword. Error throwing and exception hanndling is ‘opt-in’ in Swift.  The throws keyword indicates that this method could throw an error. (If you are familiar with throwing exception in other languages, Swift’s error handling is not the same as throwing exception.)  By using this keyword, the compiler ensures that anyone who uses this method knows that this method can throw an error – and, more importantly, that the caller also handles any potential errors.  To call a method that can throw, you use a do-catch statement. Within the do block, you annotate any methods that might throw an error using the try keyword to reinforce the idea that the call might fail.  If a method does throw an error, then the program immediately exits the do block; no further code in the do block is executed. At that point, the error is passed to the catch block for it to be handled in some way.func deleteImage(at imageURL: URL) {    let fileManager = FileManager.default    do {        // need try for every statement that can fail        try fileManager.removeItem(at: imageURL) // this method might throw an error} catch {         print(\"Error removing image: \\(error)\")    }} Application Sandbox Every iOS application has its own application sandbox. An application sandbox is a directory on the filesystem that is barricaded from the rest of the filesystem. Your application must stay in its sandbox, and no other application can access its sandbox.  Constructing a file URL The instances of our model objects will be saved to a single file in the Documents directory. The store will handle writing to and reading from that file. To do this, the store needs to construct a URL to this file. // Adding a URL where the items will be saved tovar allItems = [Item]()let itemArchiveURL: URL = {    let documentsDirectories =        FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)    let documentDirectory = documentsDirectories.first!    return documentDirectory.appendingPathComponent(\"items.plist\")}()      The method urls(for:in:) searches the filesystem for a URL that meets the criteria given by the arguments.         In iOS, the last argument is always the same. (This method is borrowed from macOS, where there are significantly more options.) The first argument is a SearchPathDirectory enumeration that specifies the directory in the sandbox you want the URL for. For example, searching for .cachesDirectory will return the Caches directory in the application’s sandbox.   Persisting the Items You have a place to save data on the filesystem and a model object that can be saved to the filesystem. How do you kick off the saving and loading processes, and when do you do it? // Writing data to diskfunc saveChanges() -&gt; Bool {\tprint(\"Saving items to: \\(itemArchiveURL)\")    do {        let encoder = PropertyListEncoder()        let data = try encoder.encode(allItems)         try data.write(to: itemArchiveURL)         return true \t    } catch let encodingError {        print(\"Error encoding allItems: \\(encodingError)\")        return false     } }   NOTE: When the user leaves the application (often by swiping up on the Home indicator), the messageapplicationDidEnterBackground(_:) is sent to the AppDelegate. Loading the Items init() {     do {         let data = try Data(contentsOf: itemArchiveURL)        let unarchiver = PropertyListDecoder()        let items = try unarchiver.decode([Item].self, from: data)        allItems =  items\t} catch {         print(\"Error reading in saved items: \\(error)\")    }} Application States and Transitions When an application is not running, it is in the not running state and it does not execute any code or have any memory reserved in RAM. After the user launches an application, it enters the active state. When in the active state, an application’s interface is on the screen, it is accepting events, and its code is handling those events. While in the active state, an application can be temporarily interrupted by a system event like an SMS message, push notification, phone call, or alarm. An overlay will appear on top of your application to handle this event, and the application enters the inactive state. In the inactive state, an application is visible behind the overlay and is executing code, but it is not receiving events. Applications typically spend very little time in the inactive state. You can force an active application into the inactive state by pressing the Lock button at the top of the device. The application will stay inactive until the device is unlocked. When the user swipes up on the Home indicator or switches to another application in some other way, the application enters the background state. (Actually, it spends a brief moment in the inactive state before transitioning to the background state.) In the background state, an application’s interface is not visible or receiving events, but it can still execute code. By default, an application that enters the background state has about 10 seconds before it enters the suspended state. Your application should not rely on this number; instead, it should save user data and release any shared resources as quickly as possible. An application in the suspended state cannot execute code. You cannot see its interface, and any resources it does not need while suspended are destroyed. A suspended application is essentially flash-frozen and can be quickly thawed when the user relaunches it. Application states flow chart  Q. If the app cannot execute any code when in the suspended state, how do chat apps receive push notifications? These push notifications are generally coming from a web service. These web services push the data to Apple, and Apple then sends us the notification. The code for sending these push nontifications is not in our app. Q. How can we reply directly from the notification then? Such actions in response to notifications is possible when we have a separate small “app” bundled with our app. This small app generally has a single view controller. When we reply from the notification window, we are basically using this small app, as opposed to our main application. This app has it’s own separae application state and transitions. So, our app need not be made active for such actions to be performed. Q. What does the background app refresh option do? When background app refresh is enabled, the OS may decide to enable the app to load or refresh it’s data for a brief period of time, when the OS is not busy doing other things. So for this brief period, the app may be made active, and then back to inactive and suspended.   NOTE: You can see what applications are in the background or suspended by swiping up and pausing on the Home indicator to get to the task switcher An application in the suspended state will remain in that state as long as there is adequate system memory. When the OS decides memory is getting low, it will terminate suspended applications as needed. A suspended application gets no indication that it is about to be terminated. It is simply removed from memory. (An application may remain in the task switcher after it has been terminated, but it will have to relaunch when tapped.) The Application Bundle When you build an iOS application project in Xcode, you create an application bundle. The application bundle contains the application executable and any resources you have bundled with your application. Resources are things like storyboard files, images, and audio files – any files that will be used at runtime. When you add a resource file to a project, Xcode is smart enough to realize that it should be bundled with your application. How can you tell which files are being bundled with your application? Select the project name from the project navigator. Check out the Build Phases pane in the project target. Everything under Copy Bundle Resources will be added to the application bundle when it is built. Modals and Popovers For example, when adding a new contact to your phone, you are presented with a screen to fill out the contact’s details. We call this kind of presentation a modal presentation as the application is being put into a different mode where a certain set of actions become our focus. Modally presented view controllers often occupy the entire screen, but in certain contexts they might only take up aportion of the screen. This is especially true on iPad where there is more space to work with. In either case, the user is expected to interact with the modally presented view controller before proceeding. Alert controllers To allow the user to choose a photo source, you will present an alert with the possible choices. Alerts are often used to display information to the user on which they must act. When you want to display an alert, you create an instance of UIAlertController with a preferred style. The two available styles are UIAlertControllerStyle.actionSheet and UIAlertControllerStyle.alert Presenting programmatically class CalendarViewController: UIViewController {    func addNewEvent(_ sender: UIBarButtonItem) {        let viewController = NewCalendarEventViewController()        present(viewController, animated: true, completion: nil)    }}Dismissing class CalendarViewController: UIViewController {    func cancel(_ sender: UIBarButtonItem) {        dismiss(animated: true, completion: nil)    }}  Completion closure dismiss(animated: true, completion: {    print(\"View controller finished dismissing!\")})Permissions There are a number of capabilities on iOS that require user approval before use. Here are a subset of those capabilities:   Camera and photos  Location  Microphone  HealthKit data  Calendar  RemindersFor each of these, your application must supply a usage description that specifies the reason that your application wants to access this information. This description will be presented to the user whenever the application accesses that capability. Caching in the data store class ImageStore {     let cache = NSCache&lt;NSString,UIImage&gt;()    func setImage(_ image: UIImage, forKey key: String) {        cache.setObject(image, forKey: key as NSString)    }    func image(forKey key: String) -&gt; UIImage? {        return cache.object(forKey: key as NSString)    }    func deleteImage(forKey key: String) {        cache.removeObject(forKey: key as NSString)    }}Note that the cache is associating an instance of NSString with UIImage. NSString is Objective-C’s version ofString. Due to the way NSCache is implemented (it is an Objective-C class, like most of Apple’s classes that you have been working with), it requires you to use NSString instead of String. // MARK: As your classes get longer, it can get more difficult to find a method buried in a long list of methods. A good way to organize your methods is to use // MARK: comments. Two useful // MARK: comments are the divider and the label: // This is a divider // MARK: - // This is a label// MARK: My Awesome MethodsThe divider and label can be combined: // MARK: - View life cycleoverride func viewDidLoad() { ... }override func viewWillAppear(_ animated: Bool) { ... }// MARK: - Actionsfunc addNewItem(_ sender: UIBarButtonItem) {...} Size classes The relative sizes of screens are defined in size classes. A size class represents a relative amount of screen space in a given dimension. Each dimension (width and height) can either be compact or regular, so there are four possible combinations of size classes:  Notice that the size classes cover both screen sizes and orientations. Instead of thinking about interfaces in terms of orientation or device, it is better to think in terms of size classes. Modifying Traits for a Specific Size Class When editing the interface for a specific size class combination, you are able to change:   properties for many views  whether a specific subview is installed  whether a specific constraint is installed  the constant of a constraint  the font for subviews that display text  NOTE: To detect a change in device orientation, we can use viewWillTransition(to:with:). Varying constraints for different size classes       To activate constraints on only a particular size classes ,for a partiular trait, you can change things like the axis of the stack view, and it will be applied to only that particular device orientation. We can add size-class-specific options to do this.         You can also deactivate particular constraints for a particular trait variation (by disabling the install checkbox when in the trait variation).   Web Services Building the URL Communication with servers is done via requests. A request encapsulates information about the interaction between the application and the server, and its most important piece of information is the destination URL. Access Control You can control what can access the properties and methods on your own types. There are five levels of access control that can be applied to types, properties, and methods:   open – This is used only for classes, and mostly by framework or third-party library authors. Anything can access this class, property, or method. Additionally, classes marked as open can be subclassed and methods can be overridden outside of the module.  public – This is very similar to open; however, classes can only be subclassed and methods can only be overridden inside (not outside of) the module.  internal – This is the default. Anything in the current module can access this type, property, or method. For an app, only files within your project can access these. If you write a third-party library, then only files within that third-party library can access them – apps that use your third-party library cannot.  fileprivate – Anything in the same source file can see this type, property, or method.  private – Anything within the enclosing scope can access this type, property, or method.Sending the Request   A URL request encapsulates information about the communication from the application to the server. Mostimportantly, it specifies the URL of the server for the request, but it also has a timeout interval, a cache policy, and other metadata about the request. A request is represented by the URLRequest class.  The URLSession API is a collection of classes that use a request to communicate with a server in a number of ways. The URLSessionTask class is responsible for communicating with a server. The URLSession class is responsible for creating tasks that match a given configuration.  The class that communicates with the web service is an instance of URLSessionTask. There are three kinds of tasks: data tasks, download tasks, and upload tasks. URLSessionDataTask retrieves data from the server and returns it as Data in memory. URLSessionDownloadTask retrieves data from the server and returns it as a file saved to the filesystem. URLSessionUploadTask sends data to the server.  Often, you will have a group of requests that have many properties in common. For example, maybe some downloads should never happen over cellular data, or maybe certain requests should be cached differently than others. It can become tedious to configure related requests the same way.      This is where URLSession comes in handy. URLSession acts as a factory for URLSessionTask instances. The session is created with a configuration that specifies properties that are common across all of the tasks that it creates. Although many applications might only need to use a single instance of URLSession, having the power and flexibility of multiple sessions is a great tool to have at your disposal.     Fetching data from a web service is an asynchronous process: Once the request starts, it may take a nontrivial amount of time for a response to come back from the server. Because of this, the fetchInterestingPhotos(completion:) method cannot directly return an instance of PhotosResult. Instead, the caller of this method will supply a completion closure for the PhotoStore to call once the request is complete.  This follows the same pattern that URLSessionTask uses with its completion handler: The task is created with a closure for it to call once the web service request completes. Figure 20.6 describes the flow of data with the web service request. The Main Thread   Modern iOS devices have multicore processors that enable them to run multiple chunks of code simultaneously. A common way to express this is by representing each computation with a different thread of control.  When the web service completes, you want it to update the image view. But by default, URLSessionDataTask runs the completion handler on a background thread. You need a way to force code to run on the main thread to update the image view. You can do that easily using the OperationQueue class.Collection Views Creating a UICollectionView let layout = UICollectionViewFlowLayout()let cv = UICollectionView(frame: frame, collectionViewLayout: layout)cv.delegate = selfcv.dataSource = selfUICollectionViewDataSource var photos: [Photos] = ...func collectionView(_ collectionView: UICollectionView,        numberOfItemsInSection section: Int) -&gt; Int {    return photos.count}func collectionView(_ collectionView: UICollectionView,        cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {    let identifier = \"UICollectionViewCell\"    let cell =        collectionView.dequeueReusableCell(withReuseIdentifier: identifier,                                           for: indexPath)    // Configure the cell    return cell } Customizing a Collection Layout   The display of cells is not driven by the collection view itself but by the collection view’s layout. The layout object is responsible for the placement of cells onscreen. Layouts, in turn, are driven by a subclass of UICollectionViewLayout. The flow layout that Photorama is currently using is UICollectionViewFlowLayout, which is the only concrete UICollectionViewLayout subclass provided by the UIKit framework. Some of the properties you can customize on UICollectionViewFlowLayout are:   scrollDirection – Do you want to scroll vertically or horizontally?  minimumLineSpacing – What is the minimum spacing between lines?  minimumInteritemSpacing – What is the minimum spacing between items in a row (or column, if scrolling horizontally)?  itemSize – What is the size of each item?  sectionInset – What are the margins used to lay out content for each section?","categories": ["Tech"],
        "tags": [],
        "url": "http://localhost:4000/portfolio/2019-03-22-ios-notes",
        "teaser":"http://localhost:4000/images/image-20190318104116297.png"},{
        "title": "Java Trivia Questions",
        "excerpt":"Notes taken from: JavaTpoint Side Notes:   No need to remove unreferenced objects because there is Automatic Garbage Collection in java.  Java is secured because:          No explicit pointer      Java Programs run inside virtual machine sandbox      There is exception handling and type checking mechanism in java (Java is a statically typed language).        In C programming, int data type occupies 2 bytes of memory for 32-bit architecture and 4 bytes of memory for 64-bit architecture. But in java, it occupies 4 bytes of memory for both 32 and 64 bit architectures.  Whenever you write java command on the command prompt to run the java class, an instance of JVM is created.  Java Stack stores frames.It holds local variables and partial results, and plays a part in method invocation and return. Each thread has a private JVM stack, created at the same time as thread. A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes.  There are three types of variables in java: local, instance and static.  In java programming, multiple and hybrid inheritance is supported through interface only  super() can be used to invoke immediate parent class constructor.  super() is added in each class constructor automatically by compiler if there is no super() or this().  Runtime polymorphism can’t be achieved by data members.  An object is an instance of particular java class, but it is also an instance of its superclass.  If there is any abstract method in a class, that class must be abstract.  If you are extending any abstract class that have abstract method, you must either provide the implementation of the method or make this class abstract.  Abstraction in Java can be achieved through abstract classes or interfaces. Interface provides full abstraction because it is just a blueprint and all methods are abstract. In an abstract class, some methods may not be abstract.  Since Java 8, interface can have default and static methods  The java compiler adds public and abstract keywords before the interface method. More, it adds public, static and final keywords before data members.  Since Java 8, we can have method body in interface. But we need to make it default method.  Since Java 8, we can have static method in interface.  If you don’t handle exception, before terminating the program, JVM executes finally block(if any).  For each try block there can be zero or more catch blocks, but only one finally block.  The finally block will not be executed if program exits(either by calling System.exit() or by causing a fatal error that causes the process to abort).  String objects are stored in a special memory area known as string constant pool.  To create the singleton class, we need to have static member of class, private constructor and static factory method.Object-oriented Object-oriented means we organize our software as a combination of different types of objects that incorporates both data and behaviour.Object-oriented programming(OOPs) is a methodology that simplify software development and maintenance by providing some rules. Basic concepts of OOPs are:   Object  Class  Inheritance  Polymorphism  Abstraction  EncapsulationPlatform-Independent A platform is the hardware or software environment in which a program runs. There are two types of platforms software-based and hardware-based. Java provides software-based platform. The Java platform differs from most other platforms in the sense that it is a software-based platform that runs on the top of other hardware-based platforms. It has two components:   Runtime Environment  API(Application Programming Interface)Java code can be run on multiple platforms e.g. Windows, Linux, Sun Solaris, Mac/OS etc. Java code is compiled by the compiler and converted into bytecode. This bytecode is a platform-independent code because it can be run on multiple platforms i.e. Write Once and Run Anywhere(WORA). Multi-threading in Java A thread is like a separate program, executing concurrently. We can write Java programs that deal with many tasks at once by defining multiple threads. The main advantage of multi-threading is that it doesn’t occupy memory for each thread. It shares a common memory area. Diff between C++ and Java https://www.javatpoint.com/cpp-vs-java Q.  What happens at runtime and compile time? Q. **Comparison of JRE, JDK, JVM Q. Why char uses 2 byte in java and what is \\u0000 ? It is because java uses Unicode system than ASCII code system. The \\u0000 is the lowest range of Unicode system. What is difference between object oriented programming language and object based programming language? Object based programming languages follow all the features of OOPs except Inheritance. Examples of object based programming languages are JavaScript, VBScript etc. What is constructor? Constructor is just like a method that is used to initialize the state of an object. It is invoked at the time of object creation. **Does constructor return any value? Yes, that is current class instance (You cannot use return type yet it returns a value). **What is a Java static block? Is used to initialize the static data member.It is executed before main method at the time of classloading. What is Inheritance?   Inheritance in java is a mechanism in which one object acquires all the properties and behaviors of parent object.  The idea behind inheritance in java is that you can create new classes that are built upon existing classes. When you inherit from an existing class, you can reuse methods and fields of parent class, and you can add new methods and fields also.  Inheritance represents the IS-A relationship, also known as parent-child relationship.What is Aggregation? Has-A relationship. When an object of one class is instantiated in another class. When use Aggregation? Code reuse is best achieved by aggregation when there is no is-a relationship.Inheritance should be used only if the relationship is-a is maintained throughout the lifetime of the objects involved; otherwise, aggregation is the best choice. Method Overriding If subclass (child class) has the same method as declared in the parent class, it is known as method overriding in java. Can we override static method? No, you can’t override the static method because they are the part of class not object. What is covariant return type?   overriding a method by just changing the return type. (when return type is non-primitive).Java final variable If you make any variable as final, you cannot change the value of final variable(It will be constant). Java final method If you make any method as final, you cannot override it. Java final class If you make any class as final, you cannot extend it. **What is blank or uninitialized final variable? A final variable that is not initialized at the time of declaration is known as blank final variable. If you want to create a variable that is initialized at the time of creating object and once initialized may not be changed, it is useful. For example PAN CARD number of an employee. It can be initialized only in constructor. **What is static blank final variable A static final variable that is not initialized at the time of declaration is known as static blank final variable. It can be initialized only in static block. What is Polymorphism? Polymorphism in java is a concept by which we can perform a single action by different ways. There are two types of polymorphism in java: compile time polymorphism and runtime polymorphism. We can perform polymorphism in java by method overloading and method overriding. ** If you overload static method in java, it is the example of compile time polymorphism. Here, we will focus on runtime polymorphism in java Runtime polymorphism or Dynamic Method Dispatch is a process in which a call to an overridden method is resolved at runtime rather than compile-time Upcasting When reference variable of Parent class refers to the object of Child class, it is known as upcasting Upcasting + overriding = runtime polymorphism Java Runtime Polymorphism with Data Member ** Method is overridden not the datamembers, so runtime polymorphism can’t be achieved by data members.In the example given below, both the classes have a datamember speedlimit, we are accessing the datamember by the reference variable of Parent class which refers to the subclass object. Since we are accessing the datamember which is not overridden, hence it will access the datamember of Parent class always. Static binding When type of the object is determined at compiled time(by the compiler), it is known as static binding. If there is any private, final or static method in a class, there is static binding. Dynamic binding When type of the object is determined at run-time, it is known as dynamic binding. Abstract class in Java A class that is declared with abstract keyword, is known as abstract class in java. It can have abstract and non-abstract methods (method with body). It needs to be extended and its method implemented. It cannot be instantiated. Abstract method A method that is declared as abstract and does not have implementation is known as abstract method. Interface in Java   An interface in java is a blueprint of a class. It has static constants and abstract methods.  The interface in java is a mechanism to achieve abstraction.  There can be only abstract methods in the java interface not method body.  It is used to achieve abstraction and multiple inheritance in Java.  Java Interface also represents IS-A relationship.-** It cannot be instantiated just like abstract class.**Q. Why use Java interface? There are mainly three reasons to use interface:   It is used to achieve abstraction.  By using interface, we can support the functionality of multiple inheritance.  It can be used to achieve loose coupling.Q. Can you declare an interface method static? No, because methods of an interface is abstract by default, and static and abstract keywords can’t be used together. Multiple inheritance in Java by interface If a class implements multiple interfaces, or an interface extends multiple interfaces i.e. known as multiple inheritance. Multiple inheritance is not supported through class in java but it is possible by interface, why? As we have explained in the inheritance chapter, multiple inheritance is not supported in case of class because of ambiguity. But it is supported in case of interface because there is no ambiguity as implementation is provided by the implementation class. Q. **Can we define private and protected modifiers for variables in interfaces? No, they are implicitly public. Q. When can an object reference be cast to an interface reference? An object reference can be cast to an interface reference when the object implements the referenced interface. Q. What is package? A package is a group of similar type of classes, interfaces and sub-packages. It provides access protection and removes naming collision. **What is the difference between import and static import? The import allows the java programmer to access classes of a package without package qualification whereas the static import feature allows to access the static members of a class without the class qualification. The import provides accessibility to classes and interface whereas static import provides accessibility to static members of the class. Q. What is Exception Handling? Exception Handling is a mechanism to handle runtime errors. Java finally block   Java finally block follows try or catch block.  Java finally block is always executed whether exception occurs or not and whether it is handled or not.  Java finally block is a block that is used to execute important code such as closing connection, stream etc.Q. **Why are string objects immutable in Java? Because java uses the concept of string literal. Suppose there are 5 reference variables, all refer to one object “sachin”.If one reference variable changes the value of the object, it will be affected to all the reference variables. That is why string objects are immutable in java. Each time you create a string literal, the JVM checks the string constant pool first. If the string already exists in the pool, a reference to the pooled instance is returned. If string doesn’t exist in the pool, a new string instance is created and placed in the pool. For example: String s1=”Welcome”;String s2=”Welcome”;//will not create new instance Q. Why java uses concept of string literal? To make Java more memory efficient By new keyword String s=new String(“Welcome”); //creates two objects and one reference variable In such case, JVM will create a new string object in normal(non pool) heap memory and the literal “Welcome” will be placed in the string constant pool. The variable s will refer to the object in heap(non pool). StringBuffer Java StringBuffer class is thread-safe i.e. multiple threads cannot access it simultaneously (synchronized). So it is safe and will result in an order. StringBuilder The Java StringBuilder class is same as StringBuffer class except that it is non-synchronized. It is also more efficient than StringBuffer. **Multi-threading Multithreading in java is a process of executing multiple threads simultaneously. Thread is basically a lightweight sub-process, a smallest unit of processing. Multiprocessing and multithreading, both are used to achieve multitasking. But we use multithreading than multiprocessing because threads share a common memory area. They don’t allocate separate memory area so saves memory, and context-switching between the threads takes less time than process. Life-cycle of threads The life cycle of the thread in java is controlled by JVM. The java thread states are as follows:   New  Runnable  Non-Runnable (Blocked)  TerminatedHow to create thread There are two ways to create a thread:   By extending Thread class  By implementing Runnable interface. (If you are not extending the Thread class,your class object would not be treated as a thread object.So you need to explicitely create Thread class object.We are passing the object of your class that implements Runnable so that your class run() method may execute)**What if we call run() method directly instead start() method? Each thread starts in a separate call stack.Invoking the run() method from main thread, the run() method goes onto the current call stack rather than at the beginning of a new call stack. refer this: https://www.javatpoint.com/what-if-we-call-run()-method-directly Points to remember for Daemon Thread in Java   It provides services to user threads for background supporting tasks.  It has no role in life than to serve user threads.  Its life depends on user threads.  It is a low priority thread.  If you want to make a user thread as Daemon, it must not be started otherwise it will throw IllegalThreadStateException.Java Thread pool represents a group of worker threads that are waiting for the job and reuse many times. In case of thread pool, a group of fixed size threads are created. A thread from the thread pool is pulled out and assigned a job by the service provider. After completion of the job, thread is contained in the thread pool again. Advantage of Java Thread Pool Better performance It saves time because there is no need to create new thread. Java Garbage Collection   In java, garbage means unreferenced objects.  Garbage Collection is process of reclaiming the runtime unused memory automatically.      In other words, it is a way to destroy the unused objects.     The finalize() method is invoked each time before the object is garbage collected. This method can be used to perform cleanup processing.  The Garbage collector of JVM collects only those objects that are created by new keyword. So if you have created any object without new, you can use finalize method to perform cleanup processing  The gc() method is used to invoke the garbage collector to perform cleanup processing.Synchronization in Java Synchronization in java is the capability to control the access of multiple threads to any shared resource. Java Synchronization is better option where we want to allow only one thread to access the shared resource.   Mutual Exclusive  Mutual Exclusive helps keep threads from interfering with one another while sharing data. This can be done by three ways in java:          by synchronized method      by synchronized block      by static synchronization      Concept of Lock in Java Synchronization is built around an internal entity known as the lock or monitor. Every object has an lock associated with it. By convention, a thread that needs consistent access to an object’s fields has to acquire the object’s lock before accessing them, and then release the lock when it’s done with them. Synchronized block in java Synchronized block can be used to perform synchronization on any specific resource of the method. Suppose you have 50 lines of code in your method, but you want to synchronize only 5 lines, you can use synchronized block. Advantage of static synchronization method If you make any static method as synchronized, the lock will be on the class not on object. Suppose there are two objects of a shared class(e.g. Table) named object1 and object2.In case of synchronized method and synchronized block there cannot be interference between t1 and t2 or t3 and t4 because t1 and t2 both refers to a common object that have a single lock.But there can be interference between t1 and t3 or t2 and t4 because t1 acquires another lock and t3 acquires another lock.I want no interference between t1 and t3 or t2 and t4.Static synchronization solves this problem. *Enums in Java https://www.javatpoint.com/enum-in-java Garbage Collection in Java   Garbage collection is the phrase used to describe automatic memory management in Java.  it’s typical for memory to be used to create a stack, a heap, in Java’s case constant pools, and method areas. The heap is that part of memory where Java objects live, and it’s the one and only part of memory that is in any way involved in the garbage collection process.  When the garbage collector runs, its purpose is to find and delete objects that cannot be reached.  An object is eligible for garbage collection when no live thread can access it.","categories": ["Tech"],
        "tags": [],
        "url": "http://localhost:4000/Java-Trivia/",
        "teaser":"http://localhost:4000/images/avatar.jpg"},{
        "title": "System Design and Scalability",
        "excerpt":"  The idea of these questions is to have a discussion about the problem at hand. What’s important for the interviewer is the process, which you use to tackle the problem. Remember that there is no one right answer. A system can be built in different ways. The important thing is to be able to justify your ideas. System design questions require a combination of the right strategy and knowledge. By strategy we mean a way to approach the problem at an interview. Important Links       Harvard Video         Extensive Prep         Differential Synchronization         Scalability for Dummies         REST principles         HiredInTech         Database sharding         Database Indexing   System Design Process Constraints and Use Cases   The very first thing you should do with any system design question is to clarify the system’s constraints and to identify what use cases the system needs to satisfy.  Usually, part of what the interviewer wants to see is if you can gather the requirements about the problem at hand, and design a solution that covers them well. Never assume things that were not explicitly stated.  Constraints consist of either the amount of traffic or the amount of data that our system needs to handle      Find the data per second(read and written), and memory required           Imagine this is your startup idea and you are designing your system. This way, you would eliminate many assumptions that you would normally make when you try and replicate a well-established system like bit.ly or Google.       Abstract Design   Once you’ve scoped the system you’re about to design, you should continue by outlining a high-level abstract design. The goal of this is to outline all the important components that your architecture will need.  Sketch your main components and the connections between them. If you do this, very quickly you will be able to get feedback if you are moving in the right direction. Of course, you must be able to justify the high-level design that you just drew.  Don’t get lured to dive deep into some particular aspect of the abstract design. Not yet. Rather, make sure you sketch the important components and the connections between them. Justify your ideas in front of the interviewer and try to address every constraint and use case.  Usually, this sort of high-level design is a combination of well-known techniques, which people have developed. You have to make sure you are familiar with what’s out there and feel comfortable using this knowledge.Understanding Bottlenecks   Most likely your high-level design will have one or more bottlenecks given the constraints of the problem. This is perfectly ok. You are not expected to design a system from the ground up, which immediately handles all the load in the world. It just needs to be scalable, in order for you to be able to improve it using some standard tools and techniques.  Now that you have your high-level design, start thinking about what bottlenecks it has. Perhaps your system needs a load balancer and many machines behind it to handle the user requests. Or maybe the data is so huge that you need to distribute your database on multiple machines. What are some of the downsides that occur from doing that? Is the database too slow and does it need some in-memory caching?  It may be the case that the interviewer wants to direct the discussion in one particular direction. Then, maybe you won’t need to address all the bottlenecks but rather talk in more depth about one particular area. In any case, you need to be able to identify the weak spots in a system and be able to resolve them.  Remember, usually each solution is a trade-off of some kind. Changing something will worsen something else. However, the important thing is to be able to talk about these trade-offs, and to measure their impact on the system given the constraints and use cases defined.Scaling the Abstract Design   There is a common set of scalability principles that you need to know. Knowing what they are, understanding how they are used, and being able to discuss their pros and cons is what scalability at interviews is all about.","categories": ["Tech"],
        "tags": [],
        "url": "http://localhost:4000/System-Design-and-Scalability/",
        "teaser":"http://localhost:4000/images/avatar.jpg"},{
        "title": "Search at scale",
        "excerpt":"A collection of insights and resources that could help you to build search experiences [TOC] Search is an inherently messy problem:       Queries are highly variable.         The search problems are highly variable based on product needs.         Think about how different Facebook search (searching a graph of people),     YouTube search (searching individual videos), Or how different both of those are are from Kayak (air travel planning is a really hairy problem).         Google Maps (making sense of geo-spacial data).         Pinterest (pictures of a brunch you might cook one day).   **Note:**   Search is not just about building software that does ranking or retrieval for a specific domain. Search systems are usually an evolving pipeline of components that are tuned and evolve over time and that build up to a cohesive experience.  The key to success in search is building processes for evaluation and tuning into the product and development cycles. A search system architect should think about processes and metrics, not just technologies.  ❗️Even if you are using an existing open source or commercial solution, you should have some sense of the complexity of the search problem and where there are likely to be pitfalls.  Named-entity recognitionNamed-entity recognition (NER) (also known as entity identification, entity chunking and entity extraction) is a subtask of information extraction that seeks to locate and classify named entities in text into pre-defined categories such as the names of persons, organizations, locations, expressions of times, quantities, monetary values, percentages, etc.  Locality-sensitive hashing (LSH) reduces the dimensionality of high-dimensional data. LSH hashes input items so that similar items map to the same “buckets” with high probability (the number of buckets being much smaller than the universe of possible input items). LSH differs from conventional and cryptographic hash functions because it aims to maximize the probability of a “collision” for similar items.Search is different for every product, and choices depend on many technical details of the requirements. It helps to identify the key parameters of your search problem:   Size: How big is the corpus (a complete set of documents that need to be searched)? Is it thousands or billions of documents?  Media: Are you searching through text, images, graphical relationships, or geospatial data?  🔷 Corpus control and quality: Are the sources for the documents under your control, or coming from a (potentially adversarial) third party? Are all the documents ready to be indexed or need to be cleaned up and selected?  Indexing speed: Do you need real-time indexing, or is building indices in batch is fine?  Query language: Are the queries structured, or you need to support unstructured ones?  Query structure: Are your queries textual, images, sounds? Street addresses, record ids, people’s faces?  Context-dependence: Do the results depend on who the user is, what is their history with the product, their geographical location, time of the day etc?  Suggest support: Do you need to support incomplete queries?  Latency: What are the serving latency requirements? 100 milliseconds or 100 seconds?  Access control: Is it entirely public or should users only see a restricted subset of the documents?  Compliance: Are there compliance or organizational limitations?  Internationalization: Do you need to support documents with multilingual character sets or Unicode? (Hint: Always use UTF-8 unless you really know what you’re doing.) Do you need to support a multilingual corpus? Multilingual queries?Search Pipeline problems 1. Index selection: given a set of documents (e.g. the entirety of the Internet, all the Twitter posts, all the pictures on Instagram), select a potentially smaller subset of documents that may be worthy for consideration as search results and only include those in the index, discarding the rest. This is done to keep your indexes compact, and is almost orthogonal to selecting the documents to show to the user. Examples of particular classes of documents that don’t make the cut may include: a. Spam: oh, all the different shapes and sizes of search spam! A giant topic in itself, worthy of a separate guide. A good web spam taxonomy overview. b. Undesirable documents: domain constraints might require filtering: porn, illegal content, etc. The techniques are similar to spam filtering, probably with extra heuristics. c. Duplicates: Or near-duplicates and redundant documents. Can be done with Locality-sensitive hashing, similarity measures, clustering techniques or even clickthrough data. A good overview of techniques. d. Low-utility documents: The definition of utility depends highly on the problem domain, so it’s hard to recommend the approaches here. Some ideas are: it might be possible to build a utility function for your documents; heuristics might work, or example an image that contains only black pixels is not a useful document; utility might be learned from user behavior. 2. Index construction: For most search systems, document retrieval is performed using an inverted index — often just called the index.       The index is a mapping of search terms to documents. A search term could be a word, an image feature or any other document derivative useful for query-to-document matching. The list of the documents for a given term is called a posting list. It can be sorted by some metric, like document quality.         Figure out whether you need to index the data in real time.❗️Many companies with large corpora of documents use a batch-oriented indexing approach, but then find this is unsuited to a product where users expect results to be current.         With text documents, term extraction usually involves using NLP techniques, such as stop lists, stemming and entity extraction; for images or videos computer vision methods are used etc.         In addition, documents are mined for statistical and meta information, such as references to other documents (used in the famous PageRank ranking signal), topics, counts of term occurrences, document size, entities A mentioned etc. That information can be later used in ranking signal construction or document clustering. Some larger systems might contain several indexes, e.g. for documents of different types.         Index formats. The actual structure and layout of the index is a complex topic, since it can be optimized in many ways. For instance there are posting lists compression methods, one could target mmap()able data representation or use LSM-tree for continuously updated index.   Query analysis and document retrieval: Most popular search systems allow non-structured queries. That means the system has to extract structure out of the query itself. In the case of an inverted index, you need to extract search terms using NLP techniques.The extracted terms can be used to retrieve relevant documents. Unfortunately, most queries are not very well formulated, so it pays to do additional query expansion and rewriting, like:   Term re-weighting.  Spell checking. Historical query logs are very useful as a dictionary.  Synonym matching. Another survey.  Named entity recognition. A good approach is to use HMM-based language modeling.  Query classification. Detect queries of particular type. For example, Google Search detects queries that contain a geographical entity, a porny query, or a query about something in the news. The retrieval algorithm can then make a decision about which corpora or indexes to look at.  Expansion through personalization or local context. Useful for queries like “gas stations around me”.Ranking: Given a list of documents (retrieved in the previous step), their signals, and a processed query, create an optimal ordering (ranking) for those documents.   Originally, most ranking models in use were hand-tuned weighted combinations of all the document signals. Signal sets might include PageRank, clickthrough data, topicality information and others.  To further complicate things, many of those signals, such as PageRank, or ones generated by statistical language models contain parameters that greatly affect the performance of a signal. Those have to be hand-tuned too.  Lately, 🔷 learning to rank, signal-based discriminative supervised approaches are becoming more and more popular. Some popular examples of LtR are McRank and LambdaRank from Microsoft, and MatrixNet from Yandex.  A new, vector space based approach for semantic retrieval and ranking is gaining popularity lately. The idea is to learn individual low-dimensional vector document representations, then build a model which maps queries into the same vector space.  Then, retrieval is just finding several documents that are closest by some metric (e.g. Eucledian distance) to the query vector. Ranking is the distance itself. If the mapping of both the documents and queries is built well, the documents are chosen not by a fact of presence of some simple pattern (like a word), but how close the documents are to the query by meaning.Indexing pipeline operation Usually, each of the above pieces of the pipeline must be operated on a regular basis to keep the search index and search experience current.   ❗️Operating a search pipeline can be complex and involve a lot of moving pieces. Not only is the data moving through the pipeline, but the code for each module and the formats and assumptions embedded in the data will change over time.  A pipeline can be run in “batch” or based on a regular or occasional basis (if indexing speed does not need to be real time) or in a streamed way (if real-time indexing is needed) or based on certain triggers.  Some complex search engines (like Google) have several layers of pipelines operating on different time scales — for example, a page that changes often (like cnn.com) is indexed with a higher frequency than a static page that hasn’t changed in years.==Serving systems== Ultimately, the goal of a search system is to accept queries, and use the index to return appropriately ranked results. While this subject can be incredibly complex and technical, we mention a few of the key aspects to this part of the system.   Performance: users notice when the system they interact with is laggy. ❗️Google has done extensive research, and they have noticed that number of searches falls 0.6%, when serving is slowed by 300ms. They recommend to serve results under 200 ms for most of your queries. A good article on the topic. This is the hard part: the system needs to collect documents from, possibly, many computers, than merge them into possible a very long list and then sort that list in the ranking order. To complicate things further, ranking might be query-dependent, so, while sorting, the system is not just comparing 2 numbers, but performing computation.  🔷 Caching results: is often necessary to achieve decent performance. ❗️ But caches are just one large gotcha. The might show stale results when indices are updated or some results are blacklisted. Purging caches is a can of worms of itself: a search system might not have the capacity to serve the entire query stream with an empty (cold) cache, so the cache needs to be pre-warmed before the queries start arriving. Overall, caches complicate a system’s performance profile. Choosing a cache size and a replacement algorithm is also a challenge.  Availability: is often defined by an uptime/(uptime + downtime) metric. When the index is distributed, in order to serve any search results, the system often needs to query all the shards for their share of results. ❗️That means, that if one shard is unavailable, the entire search system is compromised. The more machines are involved in serving the index — the higher the probability of one of them becoming defunct and bringing the whole system down.  Managing multiple indices: Indices for large systems may separated into shards (pieces) or divided by media type or indexing cadence (fresh versus long-term indices). Results can then be merged.  Merging results of different kinds: e.g. Google showing results from Maps, News etc.Quality, evaluation, and improvement So you’ve launched your indexing pipeline and search servers, and it’s all running nicely. Unfortunately the road to a solid search experience only begins with running infrastructure. Next, you’ll need to build a set of processes around continuous search quality evaluation and improvement. In fact, this is actually most of the work and the hardest problem you’ll have to solve. 🔷 What is quality? First, you’ll need to determine (and get your boss or the product lead to agree), what quality means in your case:   Self-reported user satisfaction (includes UX)  Perceived relevance of the returned results (not including UX)  Satisfaction relative to competitors  Satisfaction relative performance of the previous version of the search engine (e.g. last week)  User engagementMetrics: Some of these concepts can be quite hard to quantify. On the other hand, it’s incredibly useful to be able to express how well a search engine is performing in a single number, a quality metric.Continuously computing such a metric for your (and your competitors’) system you can both track your progress and explain how well you are doing to your boss. Here are some classical ways to quantify quality, that can help you construct your magic quality metric formula:   Precision and recall measure how well the retrieved set of documents corresponds to the set you expected to see.  F score (specifically F1 score) is a single number, that represents both precision and recall well.  Mean Average Precision (MAP) allows to quantify the relevance of the top returned results.  🔷 Normalized Discounted Cumulative Gain (nDCG) is like MAP, but weights the relevance of the result by its position.  Long and short clicks — Allow to quantify how useful the results are to the real users.  A good detailed overview.🔷 Human evaluations: Quality metrics might seem like statistical calculations, but they can’t all be done by automated calculations. Ultimately, metrics need to represent subjective human evaluation, and this is where a “human in the loop” comes into play.❗️==Skipping human evaluation is probably the most spread reason of sub-par search experiences.== Usually, at early stages the developers themselves evaluate the results manually. At later point human raters (or assessors) may get involved. Raters typically use custom tools to look at returned search results and provide feedback on the quality of the results. Subsequently, you can use the feedback signals to guide development, help make launch decisions or even feed them back into the index selection, retrieval or ranking systems. Here is the list of some other types of human-driven evaluation, that can be done on a search system:       Basic user evaluation: The user ranks their satisfaction with the whole experience     Comparative evaluation: Compare with other search results (compare with search results from earlier versions of the system or competitors)  Retrieval evaluation: The query analysis and retrieval quality is often evaluated using manually constructed query-document sets. A user is shown a query and the list of the retrieved documents. She can then mark all the documents that are relevant to the query, and the ones that are not. The resulting pairs of (query, [relevant docs]) are called a “golden set”. Golden sets are remarkably useful. For one, an engineer can set up automatic retrieval regression tests using those sets. The selection signal from golden sets can also be fed back as ground truth to term re-weighting and other query re-writing models.  Ranking evaluation: Raters are presented with a query and two documents side-by-side. The rater must choose the document that fits the query better. This creates a partial ordering on the documents for a given query. That ordering can be later be compared to the output of the ranking system. The usual ranking quality measures used are MAP and nDCG.Evaluation datasets:One should start thinking about the datasets used for evaluation (like “golden sets” mentioned above) early in the search experience design process. How you collect and update them? How you push them to the production eval pipeline? Is there a built-in bias? Live experiments:After your search engine catches on and gains enough users, you might want to start conducting live search experiments on a portion of your traffic. The basic idea is to turn some optimization on for a group of people, and then compare the outcome with that of a “control” group — a similar sample of your users that did not have the experiment feature on for them. How you would measure the outcome is, once again, very product specific: it could be clicks on results, clicks on ads etc. Evaluation cycle time: How fast you improve your search quality is directly related to how fast you can complete the above cycle of measurement and improvement. It is essential from the beginning to ask yourself, “how fast can we measure and improve our performance?” Will it take days, hours, minutes or seconds to make changes and see if they improve quality? ❗️Running evaluation should also be as easy as possible for the engineers and should not take too much hands-on time. ","categories": ["Tech"],
        "tags": [],
        "url": "http://localhost:4000/Search-at-Scale/",
        "teaser":"http://localhost:4000/images/avatar.jpg"},{
        "title": "Intro to React and Redux",
        "excerpt":"[TOC] General Notes:   By default, React DOM escapes any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that’s not explicitly written in your application. Everything is converted to a string before being rendered. This helps prevent XSS (cross-site-scripting) attacks.  React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state.  Arrow Functions: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions  Remember that whenever conditions become too complex, it might be a good time to extract a component.  Keys only make sense in the context of the surrounding array. If you extract a ListItem component, you should keep the key on the &lt;ListItem /&gt; elements in the array rather than on the &lt;li&gt; element in the ListItem itself.  A good rule of thumb is that elements inside the map() call need keys.  When you see something wrong in the UI, you can use React Developer Tools to inspect the props and move up the tree until you find the component responsible for updating the state. This lets you trace the bugs to their source.  Spread syntax (eg. …payload)allows an iterable such as an array expression or string to be expanded in places where zero or more arguments (for function calls) or elements (for array literals) are expected, or an object expression to be expanded in places where zero or more key-value pairs (for object literals) are expected.Embedding Expressions in JSX You can embed any JavaScript expression in JSX by wrapping it in curly braces. JSX is an Expression Too After compilation, JSX expressions become regular JavaScript function calls and evaluate to JavaScript objects. This means that you can use JSX inside of if statements and for loops, assign it to variables, accept it as arguments, and return it from functions: Components Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen. Props When React sees an element representing a user-defined component, it passes JSX attributes to this component as a single object. We call this object “props”. Whether you declare a component as a function or a class, it must never modify its own props. Extracting and Reusing Components A good rule of thumb is that if a part of your UI is used several times (Button, Panel, Avatar), or is complex enough on its own (App, FeedStory, Comment), it is a good candidate to be a reusable component. State State is similar to props, but it is private and fully controlled by the component. components defined as classes have some additional features. Local state is exactly that: a feature available only to classes. Class Constructor   constructor(props) {    super(props);    this.state = {date: new Date()};  }Using State Correctly There are three things you should know about setState(). Do Not Modify State Directly For example, this will not re-render a component: // Wrongthis.state.comment = 'Hello';Instead, use setState(): // Correctthis.setState({comment: 'Hello'});The only place where you can assign this.state is the constructor. State Updates May Be Asynchronous React may batch multiple setState() calls into a single update for performance. Because this.props and this.state may be updated asynchronously, you should not rely on their values for calculating the next state. For example, this code may fail to update the counter: // Wrongthis.setState({  counter: this.state.counter + this.props.increment,});To fix it, use a second form of setState() that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument: // Correctthis.setState((prevState, props) =&gt; ({  counter: prevState.counter + props.increment}));We used an arrow function above, but it also works with regular functions: // Correctthis.setState(function(prevState, props) {  return {    counter: prevState.counter + props.increment  };});State Updates are Merged When you call setState(), React merges the object you provide into the current state. For example, your state may contain several independent variables:   constructor(props) {    super(props);    this.state = {      posts: [],      comments: []    };  }Then you can update them independently with separate setState() calls:   componentDidMount() {    fetchPosts().then(response =&gt; {      this.setState({        posts: response.posts      });    });    fetchComments().then(response =&gt; {      this.setState({        comments: response.comments      });    });  }The merging is shallow, so this.setState({comments}) leaves this.state.posts intact, but completely replaces this.state.comments. The Data Flows Down Neither parent nor child components can know if a certain component is stateful or stateless, and they shouldn’t care whether it is defined as a function or a class. This is why state is often called local or encapsulated. It is not accessible to any component other than the one that owns and sets it. A component may choose to pass its state down as props to its child components. This also works for user-defined components. The FormattedDate component would receive the date in its props and wouldn’t know whether it came from the Clock’s state, from the Clock’s props, or was typed by hand: This is commonly called a “top-down” or “unidirectional” data flow. Any state is always owned by some specific component, and any data or UI derived from that state can only affect components “below” them in the tree. If you imagine a component tree as a waterfall of props, each component’s state is like an additional water source that joins it at an arbitrary point but also flows down. Event Handling When you define a component using an ES6 class, a common pattern is for an event handler to be a method on the class. For example, this Toggle component renders a button that lets the user toggle between “ON” and “OFF” states: class Toggle extends React.Component {  constructor(props) {    super(props);    this.state = {isToggleOn: true};    // This binding is necessary to make `this` work in the callback    // this.handleClick = this.handleClick.bind(this);  }  // Warning: this is *experimental* syntax.  handleClick = () =&gt; {    console.log('this is:', this);  }  render() {    return (      &lt;button onClick={this.handleClick}&gt;        {this.state.isToggleOn ? 'ON' : 'OFF'}      &lt;/button&gt;    );  }}ReactDOM.render(  &lt;Toggle /&gt;,  document.getElementById('root'));  Side Note:   You have to be careful about the meaning of this in JSX callbacks. In JavaScript, class methods are not bound by default. If you forget to bind this.handleClick and pass it to onClick, this will be undefined when the function is actually called.   This is not React-specific behavior; it is a part of how functions work in JavaScript. Generally, if you refer to a method without () after it, such as onClick={this.handleClick}, you should bind that method.   If calling bind annoys you, there are two ways you can get around this. If you are using the experimental public class fields syntax, you can use class fields to correctly bind callbacks. Lists and Keys First, let’s review how you transform lists in JavaScript. Given the code below, we use the map() function to take an array of numbers and double their values. We assign the new array returned by map() to the variable doubled and log it: const numbers = [1, 2, 3, 4, 5];const doubled = numbers.map((number) =&gt; number * 2);console.log(doubled);This code logs [2, 4, 6, 8, 10] to the console. In React, transforming arrays into lists of elements is nearly identical. Rendering Multiple Components You can build collections of elements and include them in JSX using curly braces {}. Below, we loop through the numbers array using the JavaScript map() function. We return an &lt;li&gt; element for each item. Finally, we assign the resulting array of elements to listItems: const numbers = [1, 2, 3, 4, 5];const listItems = numbers.map((number) =&gt;  &lt;li&gt;{number}&lt;/li&gt;);We include the entire listItems array inside a &lt;ul&gt; element, and render it to the DOM: ReactDOM.render(  &lt;ul&gt;{listItems}&lt;/ul&gt;,  document.getElementById('root'));Try it on CodePen. This code displays a bullet list of numbers between 1 and 5. Basic List Component Usually you would render lists inside a component. We can refactor the previous example into a component that accepts an array of numbers and outputs an unordered list of elements. A “key” is a special string attribute you need to include when creating lists of elements. We’ll discuss why it’s important in the next section. Let’s assign a key to our list items inside numbers.map() and fix the missing key issue. function NumberList(props) {  const numbers = props.numbers;  const listItems = numbers.map((number) =&gt;    &lt;li key={number.toString()}&gt;      {number}    &lt;/li&gt;  );  return (    &lt;ul&gt;{listItems}&lt;/ul&gt;  );}const numbers = [1, 2, 3, 4, 5];ReactDOM.render(  &lt;NumberList numbers={numbers} /&gt;,  document.getElementById('root'));Try it on CodePen. Keys Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity: const numbers = [1, 2, 3, 4, 5];const listItems = numbers.map((number) =&gt;  &lt;li key={number.toString()}&gt;    {number}  &lt;/li&gt;);The best way to pick a key is to use a string that uniquely identifies a list item among its siblings. Most often you would use IDs from your data as keys: const todoItems = todos.map((todo) =&gt;  &lt;li key={todo.id}&gt;    {todo.text}  &lt;/li&gt;);VERY IMPORTANT: Keys serve as a hint to React but they don’t get passed to your components. If you need the same value in your component, pass it explicitly as a prop with a different name: const content = posts.map((post) =&gt;  &lt;Post    key={post.id}    id={post.id}    title={post.title} /&gt;);With the example above, the Post component can read props.id, but not props.key. Overall, this makes it so that &lt;input type=\"text\"&gt;, &lt;textarea&gt;, and &lt;select&gt; all work very similarly - they all accept a value attribute that you can use to implement a controlled component.   Note   You can pass an array into the value attribute, allowing you to select multiple options in a select tag:   &lt;select multiple={true} value={['B', 'C']}&gt;  Lifting State Up There should be a single “source of truth” for any data that changes in a React application. Usually, the state is first added to the component that needs it for rendering. Then, if other components also need it, you can lift it up to their closest common ancestor. Instead of trying to sync the state between different components, you should rely on the top-down data flow. Lifting state involves writing more “boilerplate” code than two-way binding approaches, but as a benefit, it takes less work to find and isolate bugs. Since any state “lives” in some component and that component alone can change it, the surface area for bugs is greatly reduced. Additionally, you can implement any custom logic to reject or transform user input. If something can be derived from either props or state, it probably shouldn’t be in the state. For example, instead of storing both celsiusValue and fahrenheitValue, we store just the last edited temperature and its scale. The value of the other input can always be calculated from them in the render() method. This lets us clear or apply rounding to the other field without losing any precision in the user input. Containment Some components don’t know their children ahead of time. This is especially common for components like Sidebar or Dialog that represent generic “boxes”. We recommend that such components use the special children prop to pass children elements directly into their output: function FancyBorder(props) {  return (    &lt;div className={'FancyBorder FancyBorder-' + props.color}&gt;      {props.children}    &lt;/div&gt;  );}This lets other components pass arbitrary children to them by nesting the JSX: function WelcomeDialog() {  return (    &lt;FancyBorder color=\"blue\"&gt;      &lt;h1 className=\"Dialog-title\"&gt;        Welcome      &lt;/h1&gt;      &lt;p className=\"Dialog-message\"&gt;        Thank you for visiting our spacecraft!      &lt;/p&gt;    &lt;/FancyBorder&gt;  );}Try it on CodePen. Anything inside the &lt;FancyBorder&gt; JSX tag gets passed into the FancyBordercomponent as a children prop. Since FancyBorder renders {props.children}inside a &lt;div&gt;, the passed elements appear in the final output. Build A Static Version in React See the Pen Thinking In React: Step 2 on CodePen. Now that you have your component hierarchy, it’s time to implement your app. The easiest way is to build a version that takes your data model and renders the UI but has no interactivity. It’s best to decouple these processes because building a static version requires a lot of typing and no thinking, and adding interactivity requires a lot of thinking and not a lot of typing. We’ll see why. To build a static version of your app that renders your data model, you’ll want to build components that reuse other components and pass data using props. props are a way of passing data from parent to child. If you’re familiar with the concept of state, don’t use state at all to build this static version. State is reserved only for interactivity, that is, data that changes over time. Since this is a static version of the app, you don’t need it. You can build top-down or bottom-up. That is, you can either start with building the components higher up in the hierarchy (i.e. starting with FilterableProductTable) or with the ones lower in it (ProductRow). In simpler examples, it’s usually easier to go top-down, and on larger projects, it’s easier to go bottom-up and write tests as you build. At the end of this step, you’ll have a library of reusable components that render your data model. The components will only have render() methods since this is a static version of your app. The component at the top of the hierarchy (FilterableProductTable) will take your data model as a prop. If you make a change to your underlying data model and call ReactDOM.render() again, the UI will be updated. It’s easy to see how your UI is updated and where to make changes since there’s nothing complicated going on. React’s one-way data flow (also called one-way binding) keeps everything modular and fast. Simply refer to the React docs if you need help executing this step. React Lifecycle Methods constructor() constructor(props)The constructor for a React component is called before it is mounted. When implementing the constructor for a React.Component subclass, you should call super(props) before any other statement. Otherwise, this.props will be undefined in the constructor, which can lead to bugs. Avoid introducing any side-effects or subscriptions in the constructor. For those use cases, use componentDidMount() instead. The constructor is the right place to initialize state. To do so, just assign an object to this.state; don’t try to call setState() from the constructor. The constructor is also often used to bind event handlers to the class instance. If you don’t initialize state and you don’t bind methods, you don’t need to implement a constructor for your React component. static getDerivedStateFromProps() static getDerivedStateFromProps(nextProps, prevState)getDerivedStateFromProps is invoked after a component is instantiated as well as when it receives new props. It should return an object to update state, or null to indicate that the new props do not require any state updates. Note that if a parent component causes your component to re-render, this method will be called even if props have not changed. You may want to compare new and previous values if you only want to handle changes. Calling this.setState() generally doesn’t trigger getDerivedStateFromProps(). UNSAFE_componentWillMount() UNSAFE_componentWillMount()UNSAFE_componentWillMount() is invoked just before mounting occurs. It is called before render(), therefore calling setState() synchronously in this method will not trigger an extra rendering. Generally, we recommend using the constructor() instead for initializing state. Avoid introducing any side-effects or subscriptions in this method. For those use cases, use componentDidMount() instead. This is the only lifecycle hook called on server rendering.   Note   This lifecycle was previously named componentWillMount. That name will continue to work until version 17. Use the rename-unsafe-lifecycles codemod to automatically update your components. componentDidMount() componentDidMount()componentDidMount() is invoked immediately after a component is mounted. Initialization that requires DOM nodes should go here. If you need to load data from a remote endpoint, this is a good place to instantiate the network request. This method is a good place to set up any subscriptions. If you do that, don’t forget to unsubscribe in componentWillUnmount(). Calling setState() in this method will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the render() will be called twice in this case, the user won’t see the intermediate state. Use this pattern with caution because it often causes performance issues. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position. UNSAFE_componentWillReceiveProps() UNSAFE_componentWillReceiveProps(nextProps)  Note   It is recommended that you use the static getDerivedStateFromProps lifecycle instead of UNSAFE_componentWillReceiveProps. Learn more about this recommendation here. UNSAFE_componentWillReceiveProps() is invoked before a mounted component receives new props. If you need to update the state in response to prop changes (for example, to reset it), you may compare this.props and nextProps and perform state transitions using this.setState() in this method. Note that if a parent component causes your component to re-render, this method will be called even if props have not changed. Make sure to compare the current and next values if you only want to handle changes. React doesn’t call UNSAFE_componentWillReceiveProps() with initial props during mounting. It only calls this method if some of component’s props may update. Calling this.setState() generally doesn’t trigger UNSAFE_componentWillReceiveProps().   Note   This lifecycle was previously named componentWillReceiveProps. That name will continue to work until version 17. Use the rename-unsafe-lifecycles codemod to automatically update your components. shouldComponentUpdate() shouldComponentUpdate(nextProps, nextState)Use shouldComponentUpdate() to let React know if a component’s output is not affected by the current change in state or props. The default behavior is to re-render on every state change, and in the vast majority of cases you should rely on the default behavior. shouldComponentUpdate() is invoked before rendering when new props or state are being received. Defaults to true. This method is not called for the initial render or when forceUpdate() is used. Returning false does not prevent child components from re-rendering when their state changes. Currently, if shouldComponentUpdate() returns false, then UNSAFE_componentWillUpdate(), render(), and componentDidUpdate() will not be invoked. Note that in the future React may treat shouldComponentUpdate() as a hint rather than a strict directive, and returning false may still result in a re-rendering of the component. If you determine a specific component is slow after profiling, you may change it to inherit from React.PureComponent which implements shouldComponentUpdate() with a shallow prop and state comparison. If you are confident you want to write it by hand, you may compare this.props with nextProps and this.state with nextState and return false to tell React the update can be skipped. We do not recommend doing deep equality checks or using JSON.stringify() in shouldComponentUpdate(). It is very inefficient and will harm performance. UNSAFE_componentWillUpdate() UNSAFE_componentWillUpdate(nextProps, nextState)UNSAFE_componentWillUpdate() is invoked just before rendering when new props or state are being received. Use this as an opportunity to perform preparation before an update occurs. This method is not called for the initial render. Note that you cannot call this.setState() here; nor should you do anything else (e.g. dispatch a Redux action) that would trigger an update to a React component before UNSAFE_componentWillUpdate() returns. If you need to update state in response to props changes, use getDerivedStateFromProps() instead.   Note   This lifecycle was previously named componentWillUpdate. That name will continue to work until version 17. Use the rename-unsafe-lifecycles codemod to automatically update your components.   Note   UNSAFE_componentWillUpdate() will not be invoked if shouldComponentUpdate()returns false. getSnapshotBeforeUpdate() getSnapshotBeforeUpdate() is invoked right before the most recently rendered output is committed to e.g. the DOM. It enables your component to capture current values (e.g. scroll position) before they are potentially changed. Any value returned by this lifecycle will be passed as a parameter to componentDidUpdate(). For example: class ScrollingList extends React.Component {  listRef = React.createRef();  getSnapshotBeforeUpdate(prevProps, prevState) {    // Are we adding new items to the list?    // Capture the current height of the list so we can adjust scroll later.    if (prevProps.list.length &lt; this.props.list.length) {      return this.listRef.current.scrollHeight;    }    return null;  }  componentDidUpdate(prevProps, prevState, snapshot) {    // If we have a snapshot value, we've just added new items.    // Adjust scroll so these new items don't push the old ones out of view.    if (snapshot !== null) {      this.listRef.current.scrollTop +=        this.listRef.current.scrollHeight - snapshot;    }  }  render() {    return (      &lt;div ref={this.listRef}&gt;{/* ...contents... */}&lt;/div&gt;    );  }}In the above examples, it is important to read the scrollHeight property in getSnapshotBeforeUpdate rather than componentWillUpdate in order to support async rendering. With async rendering, there may be delays between “render” phase lifecycles (like componentWillUpdate and render) and “commit” phase lifecycles (like getSnapshotBeforeUpdate and componentDidUpdate). If a user does something like resize the browser during this time, a scrollHeight value read from componentWillUpdate will be stale. componentDidUpdate() componentDidUpdate(prevProps, prevState, snapshot)componentDidUpdate() is invoked immediately after updating occurs. This method is not called for the initial render. Use this as an opportunity to operate on the DOM when the component has been updated. This is also a good place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed). If your component implements the getSnapshotBeforeUpdate() lifecycle, the value it returns will be passed as a third “snapshot” parameter to componentDidUpdate(). (Otherwise this parameter will be undefined.)   Note   componentDidUpdate() will not be invoked if shouldComponentUpdate() returns false. componentWillUnmount() componentWillUnmount()componentWillUnmount() is invoked immediately before a component is unmounted and destroyed. Perform any necessary cleanup in this method, such as invalidating timers, canceling network requests, or cleaning up any subscriptions that were created in componentDidMount(). componentDidCatch() componentDidCatch(error, info)Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed. Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them. A class component becomes an error boundary if it defines this lifecycle method. Calling setState() in it lets you capture an unhandled JavaScript error in the below tree and display a fallback UI. Only use error boundaries for recovering from unexpected exceptions; don’t try to use them for control flow. For more details, see Error Handling in React 16.   Note   Error boundaries only catch errors in the components below them in the tree. An error boundary can’t catch an error within itself. setState() setState(updater[, callback])setState() enqueues changes to the component state and tells React that this component and its children need to be re-rendered with the updated state. This is the primary method you use to update the user interface in response to event handlers and server responses. Think of setState() as a request rather than an immediate command to update the component. For better perceived performance, React may delay it, and then update several components in a single pass. React does not guarantee that the state changes are applied immediately. setState() does not always immediately update the component. It may batch or defer the update until later. This makes reading this.state right after calling setState() a potential pitfall. Instead, use componentDidUpdate or a setState callback (setState(updater, callback)), either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, read about the updater argument below. setState() will always lead to a re-render unless shouldComponentUpdate() returns false. If mutable objects are being used and conditional rendering logic cannot be implemented in shouldComponentUpdate(), calling setState() only when the new state differs from the previous state will avoid unnecessary re-renders. The first argument is an updater function with the signature: (prevState, props) =&gt; stateChangeprevState is a reference to the previous state. It should not be directly mutated. Instead, changes should be represented by building a new object based on the input from prevState and props. For instance, suppose we wanted to increment a value in state by props.step: this.setState((prevState, props) =&gt; {  return {counter: prevState.counter + props.step};});Both prevState and props received by the updater function are guaranteed to be up-to-date. The output of the updater is shallowly merged with prevState. The second parameter to setState() is an optional callback function that will be executed once setState is completed and the component is re-rendered. Generally we recommend using componentDidUpdate() for such logic instead. You may optionally pass an object as the first argument to setState() instead of a function: setState(stateChange[, callback])This performs a shallow merge of stateChange into the new state, e.g., to adjust a shopping cart item quantity: this.setState({quantity: 2})This form of setState() is also asynchronous, and multiple calls during the same cycle may be batched together. For example, if you attempt to increment an item quantity more than once in the same cycle, that will result in the equivalent of: Object.assign(  previousState,  {quantity: state.quantity + 1},  {quantity: state.quantity + 1},  ...)Subsequent calls will override values from previous calls in the same cycle, so the quantity will only be incremented once. If the next state depends on the previous state, we recommend using the updater function form, instead: this.setState((prevState) =&gt; {  return {quantity: prevState.quantity + 1};});For more detail, see:   State and Lifecycle guide  In depth: When and why are setState() calls batched?  In depth: Why isn’t this.state updated immediately?forceUpdate() component.forceUpdate(callback)By default, when your component’s state or props change, your component will re-render. If your render() method depends on some other data, you can tell React that the component needs re-rendering by calling forceUpdate(). Calling forceUpdate() will cause render() to be called on the component, skipping shouldComponentUpdate(). This will trigger the normal lifecycle methods for child components, including the shouldComponentUpdate() method of each child. React will still only update the DOM if the markup changes. Normally you should try to avoid all uses of forceUpdate() and only read from this.props and this.state in render(). Portals Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component. ReactDOM.createPortal(child, container)The first argument (child) is any renderable React child, such as an element, string, or fragment. The second argument (container) is a DOM element. Usage Normally, when you return an element from a component’s render method, it’s mounted into the DOM as a child of the nearest parent node: render() {  // React mounts a new div and renders the children into it  return (    &lt;div&gt;      {this.props.children}    &lt;/div&gt;  );}However, sometimes it’s useful to insert a child into a different location in the DOM: render() {  // React does *not* create a new div. It renders the children into `domNode`.  // `domNode` is any valid DOM node, regardless of its location in the DOM.  return ReactDOM.createPortal(    this.props.children,    domNode  );}A typical use case for portals is when a parent component has an overflow: hidden or z-index style, but you need the child to visually “break out” of its container. For example, dialogs, hovercards, and tooltips.   Note:   It is important to remember, when working with portals, you’ll need to make sure to follow the proper accessibility guidelines. Try it on CodePen. Event Bubbling Through Portals Even though a portal can be anywhere in the DOM tree, it behaves like a normal React child in every other way. Features like context work exactly the same regardless of whether the child is a portal, as the portal still exists in the React tree regardless of position in the DOM tree. This includes event bubbling. An event fired from inside a portal will propagate to ancestors in the containing React tree, even if those elements are not ancestors in the DOM tree. Assuming the following HTML structure: &lt;html&gt;  &lt;body&gt;    &lt;div id=\"app-root\"&gt;&lt;/div&gt;    &lt;div id=\"modal-root\"&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;A Parent component in #app-root would be able to catch an uncaught, bubbling event from the sibling node #modal-root. // These two containers are siblings in the DOMconst appRoot = document.getElementById('app-root');const modalRoot = document.getElementById('modal-root');class Modal extends React.Component {  constructor(props) {    super(props);    this.el = document.createElement('div');  }  componentDidMount() {    // The portal element is inserted in the DOM tree after    // the Modal's children are mounted, meaning that children    // will be mounted on a detached DOM node. If a child    // component requires to be attached to the DOM tree    // immediately when mounted, for example to measure a    // DOM node, or uses 'autoFocus' in a descendant, add    // state to Modal and only render the children when Modal    // is inserted in the DOM tree.    modalRoot.appendChild(this.el);  }  componentWillUnmount() {    modalRoot.removeChild(this.el);  }  render() {    return ReactDOM.createPortal(      this.props.children,      this.el,    );  }}class Parent extends React.Component {  constructor(props) {    super(props);    this.state = {clicks: 0};    this.handleClick = this.handleClick.bind(this);  }  handleClick() {    // This will fire when the button in Child is clicked,    // updating Parent's state, even though button    // is not direct descendant in the DOM.    this.setState(prevState =&gt; ({      clicks: prevState.clicks + 1    }));  }  render() {    return (      &lt;div onClick={this.handleClick}&gt;        &lt;p&gt;Number of clicks: {this.state.clicks}&lt;/p&gt;        &lt;p&gt;          Open up the browser DevTools          to observe that the button          is not a child of the div          with the onClick handler.        &lt;/p&gt;        &lt;Modal&gt;          &lt;Child /&gt;        &lt;/Modal&gt;      &lt;/div&gt;    );  }}function Child() {  // The click event on this button will bubble up to parent,  // because there is no 'onClick' attribute defined  return (    &lt;div className=\"modal\"&gt;      &lt;button&gt;Click&lt;/button&gt;    &lt;/div&gt;  );}ReactDOM.render(&lt;Parent /&gt;, appRoot);Try it on CodePen. Catching an event bubbling up from a portal in a parent component allows the development of more flexible abstractions that are not inherently reliant on portals. For example, if you render a &lt;Modal /&gt; component, the parent can capture its events regardless of whether it’s implemented using portals. Redux - Three Principles Single source of truth The state of your whole application is stored in an object tree within a single store. This makes it easy to create universal apps, as the state from your server can be serialized and hydrated into the client with no extra coding effort. A single state tree also makes it easier to debug or inspect an application; it also enables you to persist your app’s state in development, for a faster development cycle. Some functionality which has been traditionally difficult to implement - Undo/Redo, for example - can suddenly become trivial to implement, if all of your state is stored in a single tree. State is read-only: The only way to change the state is to emit an action, an object describing what happened. This ensures that neither the views nor the network callbacks will ever write directly to the state. Instead, they express an intent to transform the state. Because all changes are centralized and happen one by one in a strict order, there are no subtle race conditions to watch out for. As actions are just plain objects, they can be logged, serialized, stored, and later replayed for debugging or testing purposes. store.dispatch({  type: 'COMPLETE_TODO',  index: 1}) store.dispatch({  type: 'SET_VISIBILITY_FILTER',  filter: 'SHOW_COMPLETED'})Changes are made with pure functions: To specify how the state tree is transformed by actions, you write pure reducers. Reducers are just pure functions that take the previous state and an action, and return the next state. Remember to return new state objects, instead of mutating the previous state. You can start with a single reducer, and as your app grows, split it off into smaller reducers that manage specific parts of the state tree. Because reducers are just functions, you can control the order in which they are called, pass additional data, or even make reusable reducers for common tasks such as pagination. function visibilityFilter(state = 'SHOW_ALL', action) {  switch (action.type) {    case 'SET_VISIBILITY_FILTER':      return action.filter    default:      return state  }} function todos(state = [], action) {  switch (action.type) {    case 'ADD_TODO':      return [        ...state,        {          text: action.text,          completed: false        }      ]    case 'COMPLETE_TODO':      return state.map((todo, index) =&gt; {        if (index === action.index) {          return Object.assign({}, todo, {            completed: true          })        }        return todo      })    default:      return state  }} import { combineReducers, createStore } from 'redux'const reducer = combineReducers({ visibilityFilter, todos })const store = createStore(reducer)Action: First, let’s define some actions. Actions are payloads of information that send data from your application to your store. They are the only source of information for the store. You send them to the store using store.dispatch(). Here’s an example action which represents adding a new todo item: const ADD_TODO = 'ADD_TODO'{  type: ADD_TODO,  text: 'Build my first Redux app'}Actions are plain JavaScript objects. Actions must have a type property that indicates the type of action being performed. Types should typically be defined as string constants. Once your app is large enough, you may want to move them into a separate module. import { ADD_TODO, REMOVE_TODO } from '../actionTypes'  Note on Boilerplate   You don’t have to define action type constants in a separate file, or even to define them at all. For a small project, it might be easier to just use string literals for action types. However, there are some benefits to explicitly declaring constants in larger codebases. Read Reducing Boilerplate for more practical tips on keeping your codebase clean. Other than type, the structure of an action object is really up to you. If you’re interested, check out Flux Standard Action for recommendations on how actions could be constructed. We’ll add one more action type to describe a user ticking off a todo as completed. We refer to a particular todo by index because we store them in an array. In a real app, it is wiser to generate a unique ID every time something new is created. {  type: TOGGLE_TODO,  index: 5}It’s a good idea to pass as little data in each action as possible. For example, it’s better to pass index than the whole todo object. Finally, we’ll add one more action type for changing the currently visible todos. {  type: SET_VISIBILITY_FILTER,  filter: SHOW_COMPLETED}Action Creators Action creators are exactly that—functions that create actions. It’s easy to conflate the terms “action” and “action creator”, so do your best to use the proper term. In Redux, action creators simply return an action: function addTodo(text) {  return {    type: ADD_TODO,    text  }}This makes them portable and easy to test. In traditional Flux, action creators often trigger a dispatch when invoked, like so: function addTodoWithDispatch(text) {  const action = {    type: ADD_TODO,    text  }  dispatch(action)}In Redux this is not the case.Instead, to actually initiate a dispatch, pass the result to the dispatch() function: dispatch(addTodo(text))dispatch(completeTodo(index))Alternatively, you can create a bound action creator that automatically dispatches: const boundAddTodo = text =&gt; dispatch(addTodo(text))const boundCompleteTodo = index =&gt; dispatch(completeTodo(index))Now you’ll be able to call them directly: boundAddTodo(text)boundCompleteTodo(index)The dispatch() function can be accessed directly from the store as store.dispatch(), but more likely you’ll access it using a helper like react-redux’s connect(). You can use bindActionCreators() to automatically bind many action creators to a dispatch() function. Action creators can also be asynchronous and have side-effects. You can read about async actions in the advanced tutorial to learn how to handle AJAX responses and compose action creators into async control flow. Don’t skip ahead to async actions until you’ve completed the basics tutorial, as it covers other important concepts that are prerequisite for the advanced tutorial and async actions. Data Flow - Most Important Redux architecture revolves around a strict unidirectional data flow. This means that all data in an application follows the same lifecycle pattern, making the logic of your app more predictable and easier to understand. It also encourages data normalization, so that you don’t end up with multiple, independent copies of the same data that are unaware of one another. If you’re still not convinced, read Motivation and The Case for Flux for a compelling argument in favor of unidirectional data flow. Although Redux is not exactly Flux, it shares the same key benefits. The data lifecycle in any Redux app follows these 4 steps:       You call store.dispatch(action).     An action is a plain object describing what happened. For example:      { type: 'LIKE_ARTICLE', articleId: 42 } { type: 'FETCH_USER_SUCCESS', response: { id: 3, name: 'Mary' } } { type: 'ADD_TODO', text: 'Read the Redux docs.' }        Think of an action as a very brief snippet of news. “Mary liked article 42.” or “‘Read the Redux docs.’ was added to the list of todos.”     You can call store.dispatch(action) from anywhere in your app, including components and XHR callbacks, or even at scheduled intervals.         The Redux store calls the reducer function you gave it.     The store will pass two arguments to the reducer: the current state tree and the action. For example, in the todo app, the root reducer might receive something like this:      // The current application state (list of todos and chosen filter) let previousState = {   visibleTodoFilter: 'SHOW_ALL',   todos: [     {       text: 'Read the docs.',       complete: false     }   ] }  // The action being performed (adding a todo) let action = {   type: 'ADD_TODO',   text: 'Understand the flow.' }  // Your reducer returns the next application state let nextState = todoApp(previousState, action)        Note that a reducer is a pure function. It only computes the next state. It should be completely predictable: calling it with the same inputs many times should produce the same outputs. It shouldn’t perform any side effects like API calls or router transitions. These should happen before an action is dispatched.         The root reducer may combine the output of multiple reducers into a single state tree.     How you structure the root reducer is completely up to you. Redux ships with a combineReducers() helper function, useful for “splitting” the root reducer into separate functions that each manage one branch of the state tree.     Here’s how combineReducers() works. Let’s say you have two reducers, one for a list of todos, and another for the currently selected filter setting:      function todos(state = [], action) {   // Somehow calculate it...   return nextState }  function visibleTodoFilter(state = 'SHOW_ALL', action) {   // Somehow calculate it...   return nextState }  let todoApp = combineReducers({   todos,   visibleTodoFilter })        When you emit an action, todoApp returned by combineReducers will call both reducers:      let nextTodos = todos(state.todos, action) let nextVisibleTodoFilter = visibleTodoFilter(state.visibleTodoFilter, action)        It will then combine both sets of results into a single state tree:      return {   todos: nextTodos,   visibleTodoFilter: nextVisibleTodoFilter }        While combineReducers() is a handy helper utility, you don’t have to use it; feel free to write your own root reducer!         The Redux store saves the complete state tree returned by the root reducer.     This new tree is now the next state of your app! Every listener registered with store.subscribe(listener) will now be invoked; listeners may call store.getState() to get the current state.     Now, the UI can be updated to reflect the new state. If you use bindings like React Redux, this is the point at which component.setState(newState) is called.   Docs to View: 1. Google Docs Overview: https://docs.google.com/document/d/1CrsP0a16JLZHWR-O3dsATFIGxKFgyOE72Mu4b1wnJxk/edit?userstoinvite=parth.mehta@oath.com&amp;ts=5ac3fcb5&amp;actionButton=1 2. React Docs: https://reactjs.org 3. Redux Docs: https://redux.js.org 4. Redux-Select: https://github.com/reactjs/reselect 5. React-atomic-css: https://git.ouroath.com/Mail/react-atomic-css ","categories": ["Tech"],
        "tags": [],
        "url": "http://localhost:4000/Intro-to-React/",
        "teaser":"http://localhost:4000/images/avatar.jpg"},{
        "title": "Pro-Git",
        "excerpt":"History of VCS   Local VCS (RCS) –&gt; Centralised Remote VCS (subversion) –&gt; Distributed Remote VCS (Git) History of Git   Linux Kernel used patch files from 1991 - 2002 —&gt; In 2002, started using Bitkeeper, a proprietary DCVS —&gt; In 2005, they fought and it Linus Torvalds decided to build something of his own, learning lessons from Bitkeeper. Git Vs. Other VCS             The basic difference is that Git is not a delta-based version control system. It stores snapshots of the entire filesystem at each commit, as opposed to storing what changed in all the files from the previous version.               Nearly every operation is local, be it looking up history, or making commits.               Everything in Git is checksummed before it is stored and is then referred to by that checksum. This means it’s impossible to change the contents of any file or directory without Git knowing about it. This functionality is built into Git at the lowest levels and is integral to its philosophy. You can’t lose information in transit or get file corruption without Git being able to detect it.       The mechanism that Git uses for this checksumming is called a SHA-1 hash.       Git Basics   Git has three main states that your files can reside in: committed, modified, and staged:       Committed means that the data is safely stored in your local database.    Modified means that you have changed the file but have not committed it to your database yet.    Staged means that you have marked a modified file in its current version to go into your next commit snapshot.    This leads us to the three main sections of a Git project: the Git directory, the working tree, and the staging area.   The Git directory is where Git stores the metadata and object database for your project. This is the most important part of Git, and it is what is copied when you clone a repository from another computer.   The working tree is a single checkout of one version of the project. These files are pulled out of the compressed database in the Git directory and placed on disk for you to use or modify.   The staging area is a file, generally contained in your Git directory, that stores information about what will go into your next commit. Its technical name in Git parlance is the “index”, but the phrase “staging area” works just as well.   The basic Git workflow goes something like this:       You modify files in your working tree.    You selectively stage just those changes you want to be part of your next commit, which adds onlythose changes to the staging area.    You do a commit, which takes the files as they are in the staging area and stores that snapshot permanently to your Git directory.    If a particular version of a file is in the Git directory, it’s considered committed. If it has been modified and was added to the staging area, it is staged. And if it was changed since it was checked out but has not been staged, it is modified. First-time Git Setup Git comes with a tool called git config that lets you get and set configuration variables that control all aspects of how Git looks and operates. These variables can be stored in three different places:   /etc/gitconfig file: Contains values applied to every user on the system and all their repositories. If you pass the option --system to git config, it reads and writes from this file specifically. (Because this is a system configuration file, you would need administrative or superuser privilege to make changes to it.)  ~/.gitconfig or ~/.config/git/config file: Values specific personally to you, the user. You can make Git read and write to this file specifically by passing the --global option, and this affects all of the repositories you work with on your system.  config file in the Git directory (that is, .git/config) of whatever repository you’re currently using: Specific to that single repository. You can force Git to read from and write to this file with the --local option, but that is in fact the default. (Unsurprisingly, you need to be located somewhere in a Git repository for this option to work properly.)Each level overrides values in the previous level, so values in .git/config trump those in /etc/gitconfig. Checking Your Settings If you want to check your configuration settings, you can use the git config --list command to list all the settings Git can find at that point: $ git config --listuser.name=John Doeuser.email=johndoe@example.comcolor.status=autocolor.branch=autocolor.interactive=autocolor.diff=auto...You may see keys more than once, because Git reads the same key from different files (/etc/gitconfig and ~/.gitconfig, for example). In this case, Git uses the last value for each unique key it sees. You can also check what Git thinks a specific key’s value is by typing git config &lt;key&gt;: $ git config user.nameJohn Doe            Note      Since Git might read the same configuration variable value from more than one file, it’s possible that you have an unexpected value for one of these values and you don’t know why. In cases like that, you can query Git as to the origin for that value, and it will tell you which configuration file had the final say in setting that value:$ git config --show-origin rerere.autoUpdate file:/home/johndoe/.gitconfig\tfalse                                Basic Concepts       Remember that each file in your working directory can be in one of two states: tracked or untracked. Tracked files are files that were in the last snapshot; they can be unmodified, modified, or staged. In short, tracked files are files that Git knows about. Untracked files are everything else — any files in your working directory that were not in your last snapshot and are not in your staging area. When you first clone a repository, all of your files will be tracked and unmodified because Git just checked them out and you haven’t edited anything.          Short Status     While the git status output is pretty comprehensive, it’s also quite wordy. Git also has a short status flag so you can see your changes in a more compact way. If you run git status -s or git status --short you get a far more simplified output from the command:     $ git status -s M READMEMM RakefileA  lib/git.rbM  lib/simplegit.rb?? LICENSE.txt        New files that aren’t tracked have a ?? next to them, new files that have been added to the staging area have an A, modified files have an M and so on. There are two columns to the output - the left-hand column indicates the status of the staging area and the right-hand column indicates the status of the working tree. So for example in that output, the README file is modified in the working directory but not yet staged, while the lib/simplegit.rb file is modified and staged. The Rakefile was modified, staged and then modified again, so there are changes to it that are both staged and unstaged.     ","categories": ["Tech"],
        "tags": [],
        "url": "http://localhost:4000/Pro-Git/",
        "teaser":"http://localhost:4000/images/avatar.jpg"},{
        "title": "iOS Development",
        "excerpt":"iOS Training - Big Nerd Ranch Instructor: Zachary Waldowski (zachary@bignerdranch.com) General Notes   Xcode comes with an iOS simulator, not emulator . The difference between emulators and simulators is that emulators mimic the software and hardware environments found on actual devices. Simulators, on the other hand, only mimic the software environment; they otherwise have access to all of the host system’s (the laptop’s) hardware resources such as disk space, memory and processor speed.  Main.storyboard –&gt; description of UI in the application.  control + drag to activate layout constraints between 2 views  alt + click –&gt; see data type  To connect views to their references in the code, go to Controller View, and in the connections inspector, connect the variables declared in code to the UI elements.  To create actions for methods, drag the action from connections inspector to the code to create a new action. It’s easier to use the Assistant editor to see both the ViewController.swift and the Main.storyboard.  Vertical spacing is similar to relative positioning. It is relative to two views.  Swift is a statically typed and a strongly typed language.  Unlike Android, the app or the activity is not relaunched when the screen is rotated. This is because iOS has separate view heirarchy process and a separate view layout process. Layout constraints are applied during the view layout process.  Many iOS frameworks are still written in Objective-C even though we interact with them through Swift.  The @discardableResult annotation before the func keyword in the function definition means that a caller of this function is free to ignore the result of calling this function.  When writing iOS applications, it is important to treat each UIViewController as its own little world. The stuff that has already been implemented in Cocoa Touch will do the heavy lifting.  Instead of assigning a value to the property directly, the value is sometimes set using a closure. Using a closure like this allows you to set the value for a variable or constant that requires multiple lines of code, which can be very useful when configuring objects. This makes your code more maintainable because it keeps the property and the code needed to generate the property together.MVC iOS follows Model-View-Controller pattern. In the MVC design pattern, which iOS developers do their best to follow, each class falls into exactly one of the following categories:   model: holds data and knows nothing about the UI  view: is visible to the user and knows nothing about the model objects  controller: keeps the UI and the model objects in sync and controls the flow of the application Sample app code: ////  ViewController.swift//  Quiz////  Created by Parth Mehta on 3/18/19.//  Copyright © 2019 Big Nerd Ranch. All rights reserved.//import UIKitclass ViewController: UIViewController {        let questions: [String] = [        \"From what is congnac made?\",        \"What is 7 + 7?\",        \"What is the capital of Vermont?\"    ]    let answers: [String] = [        \"Who knows\",        \"14\",        \"Montepelier\"    ]        var currentQuestionIndex = 0;    @IBOutlet var questionLabel: UILabel?    @IBOutlet var answerLabel: UILabel?        override func viewDidLoad() {        super.viewDidLoad()                let question = questions[currentQuestionIndex]        questionLabel?.text = question    }    @IBAction func onTapShowAction(_ sender: Any) {        let answer = answers[currentQuestionIndex]        answerLabel?.text = answer    }        @IBAction func onnTapNextQuestion(_ sender: Any) {        answerLabel?.text = \"????\"        currentQuestionIndex = (currentQuestionIndex + 1) % questions.count                let question = questions[currentQuestionIndex]        questionLabel?.text = question    }} Only this much code to create the question answer app!! :D Swift Basics Optionals and Optional Binding   An optional lets you express the possibility that a variable may not store a value at all. The value of an optional will either be an instance of the specified type or nil.  Allows the developer to indicate that an instance of any data type may be nil.  Note that before using the optional variables like normal variables, you must unwrap the optional and address the possibility of it being nil.  Use ‘if let’ to check values and conditionally perform logic (optional binding).  Two ways of unwrapping an optional variable: optional binding and forced unwrapping.  Subscripting dictionaries: Recall that subscripting an array beyond its bounds causes a trap. Dictionaries are different. The result of subscripting a dictionary is an optional:let titles = [\"Leader\": \"Dear Leader\", \"Commandante\": \"Commandante\", \"Brightlord\": \"Brightlord\"]var optionalTitle: String? = titles[\"Leader\"]var greeting = \"Hello\"if let title = optionalTitle {    greeting += \" \\(title)\"} // Note that here, we convert the optional optionalTitle to a String// greeting += \" \\(optionalTitle!)\" // crash if optionalTitle  == nilCollections: Array var bros: [String] = [\"Matt\",\"Scott\",\"Josh\",\"Nick\"] // could also infer typebros += [\"Brian\"] // [\"Matt\",\"Scott\",\"Josh\",\"Nick\",\"Brian\"]bros[3] = \"Brandon\" // [\"Matt\",\"Scott\",\"Josh\",\"Brandon\",\"Brian\"]bros.removeAtIndex(4) // [\"Matt\",\"Scott\",\"Josh\",\"Brandon\"]Collections: Dictionary var etBroHome: [String: String] = [\"Matt\": \"GA\",\"Scott\": \"DC\"]etBroHome[\"Brian\"] = \"GA\" // [\"Matt\": \"GA\",\"Scott\": \"DC\",\"Brian: GA\"]if let oldMattSt = etBroHome.updateValue(\"CA\", forKey:\"Matt\") {    print(\"Old state: \\(oldMattSt)\")}Control Flow: Conditional Statements ‘if’ executes a set of statements if expression evalutates to true var swiftIsAwesome: Bool = trueif swiftIsAwesome {    print(\"Duh\")} else {    print(\"Something went wrong.\")}‘switch’ statements compare a value against a number of cases // Very imp thing to note is the absence of break statements. Swift break statements don't fall through by default. You can however, specify it to fall through. You can't fall through multiple cases though.let favoriteFood: String = \"Cookie Pie\"var comment: Stringswitch favoriteFood {    case \"Vegetables\":        comment = \"Ew\"    case \"Fruit\":        comment = \"Okay...\"    case let x where x.hasSuffix(\"Pie\"): // this assigns x = favoriteFood first        comment = \"\\(x) sounds good!\"    default:        comment = \"Tell me more...\"}Control Flow: For-in Loop // Note that there is not manual version of the for-loop. If we need to use a manual version, we can use a while loop.for index in 1..&lt;5 {    print(index) // 1 2 3 4}for index in 1...5 {    print(index) // 1 2 3 4 5}var things = [\"socks\",\"bannana\",\"ennui\"]for word in things {    print(word)}var etBroHome = [\"Matt\": \"GA\",\"Scott\": \"DC\"] // infers typefor (name, state) in etBroHome {    print(name, state) // (Matt, GA); (Scott, DC)}Functions // pay attention to the return type and the external parameter namefunc printNumber(number: Int) {    print(number)}printNumber(5) // logs 5 to consolefunc equalToTen(myNumber number: Int) -&gt; Bool {     // myNumber is an explicitly named external parameter    return number == 10}equalToTen(myNumber: 5) // falsefunc hasMatches(list: [Int], condition: (Int -&gt; Bool)) -&gt; (Bool, Int) {    var count = 0    var hasMatch = false    for item in list {        if condition(item) {\t\t\tcount += 1         }    }    hasMatch = count != 0    return (hasMatch, count)}var numbers = [10, 20, 21, 10]print(\"Has matches: \\(hasMatches(numbers, condition: equalToTen))\") // (true, 2)Closures var moreNumbers = [10,3,11,24]let newNumbers = moreNumbers.map {    (number) -&gt; Int in   \t\t\t// in is just a seperator that separates params from \t\t\t\t\t\t\t\t\t\tthe function body in closures    return number % 2 != 0 ? 0 : number * 3}print(newNumbers) // [30,0,0,72]Structs struct House {    var hotTubs: Int    func describeHouse() -&gt; String { return \"House has \\(hotTubs) hot tubs!\" }}var myHouse = House(hotTubs: 4)print(myHouse.describeHouse()) // House has 4 hot tubs!Classes class Parent: Person {    var hasChildren: Bool    static var hasStaticChildren: Bool \t\t// class level variable    init(hasChildren: Bool) {        // constructor. Note that all inits are functions.        // You can also have destructors called dinit()        self.hasChildren = hasChildren    }    class func exampleTypeMethod() {        // class level method        // like a static method in Java?    \t// stuff here    }    func exampleInstanceMethod() {        // instance level method    \t// stuff here    }}var john = Parent(hasChildren: true)Parent.exampleTypeMethod()john.exampleInstanceMethod()// The way we assign innitialisation values are safer in Swiftclass Parent: Person {    var hasChildren: Bool    init(name: String, heightInMeters: Double, hasChildren: Bool) {        self.hasChildren = hasChildren        super.init(name: name, heightInMeters: heightInMeters)    }}var john = Parent(name: \"John\", heightInMeters: 1.8, hasChildren: true)Differences between Classes and Structs in Swift   Class instances are shared in memory.  Class instances are copied by reference, struct instances are copied by value, i.e. Each copy of a struct is a new instance.  Contents of classes are mutable by all instances, irrespective of whether they are defined as let  or const, unlike in structs.  Structs have default initializers, unlike classes. Classes need initializers to be defined by us.Properties struct Meal {    var time: Int    var duration: Int}struct Day {    let name: String    var breakFast: Meal    var intervalBetweenMeals: Int    var lunch: Meal {\t\tget {            let time = breakFast.time + breakFast.duration + intervalBetweenMeals            let duration = breakFast.duration            return Meal(time: time, duration: duration)        }        set(newLunch) {            breakFast.time = newLunch.time - intervalBetweenMeals            breakFast.duration = newLunch.duration        }    }}let aMeal = Meal(time: 8, duration: 1)var aDay = Day(name: \"Monday\", breakFast: aMeal, intervalBetweenMeals: 3)aDay.lunch // name = Monday; time = 12; duration = 1Protocols // Protocols are similar to interfaces in Java and you can conform to multiple protocols (this is how you can achieve multiple inheritance in Swift).protocol ExampleProtocol {    mutating func doSomething()    var aReadonlyIntProperty: Int { get }    var aReadwriteStringProperty: String { get set }}class SomeClass: ExampleProtocol {    func doSomething     {         // code here    }    // getter for aReadOnlyIntProperty here    // getter and setter for aReadWriteStringProperty here}Extensions // add custom vars and methods to the basic types in Swift.// Note the visibility of these extensions is across the entire project.extension Int: ExampleProtocol {    var timesFive: Int {        return self * 5    }    mutating func doSomething {    // code here     }}5.doSomething5.timesFive // 25Generics func swapTwoValues&lt;T&gt;(inout a: T, inout b: T) { \tlet temporaryA = a\ta = b    b = temporaryA         // (a, b) = (b, a)}swapTwoValues(&amp;someInt, &amp;anotherInt)swapTwoValues(&amp;someString, &amp;anotherString)protocol RemoveInstance {    typealias ItemType    mutating func removeInstance(item: ItemType)}Views Basics Views Views are objects that are visible to the user, like buttons, text fields, and sliders. View objects make up an application’s UI. A view:   is an instance of UIView or one of its subclasses  knows how to draw itself  can handle events, like touches  exists within a hierarchy of views whose root is the application’s windowThe View Hierarchy Every application has a single instance of UIWindow that serves as the container for all the views in the application. UIWindow is a subclass of UIView, so the window is itself a view. The window is created when the application launches. Once the window is created, other views can be added to it.  Views and Frames When the application is launched, the view for the initial view controller is added to the root-level window. This view controller is represented by the ViewController class defined in ViewController.swift. Creating a view programmatically. let rect = CGRect(x: 0, y: 0, width: 20, height: 20)let squareView = UIView(frame: rect)someOtherView.addSubview(squareView)  Note: that these values are in points, not pixels. If the values were in pixels, then they would not be consistent across displays of different resolutions (i.e., Retina versus non-Retina). A point is a relative unit of a measure; it will be a different number of pixels depending on how many pixels are in the display. Sizes, positions, lines, and curves are always described in points to allow for differences in display resolution. Frame Vs. Bounds Frame boundaries are the boundaries of the view, from where to where the view is displayed. Bounds, on the other hand are the limits of the content of the view. Think about scrolling in a maps view. The alignment rectangle is very similar to the frame. In fact, these two rectangles are often the same. Whereas the frame encompasses the entire view, the alignment rectangle only encompasses the content that you wish to use for alignment purposes. You cannot define a view’s alignment rectangle directly. You do not have enough information (like screen size) to do that. Instead, you provide a set of constraints. Taken together, these constraints enable the system to determine the layout attributes, and thus the alignment rectangle, for each view in the view hierarchy.  What other information does a view have? // Hierarchy (Painter's method):var window: UIWindow? { get }var superview: UIView? { get }var subviews: [UIView] { get }func addSubview(_ view: UIView)func insertSubview(_ view: UIView, at index: Int)// Location of view:var frame: CGRectvar bounds: CGRect// Display properties:var backgroundColor: UIColor?var hidden: Boolvar alpha: CGFloatAuto Layout Auto Layout is a crucial technology for every iOS developer. It helps you create flexible layouts that work across a range of devices and interface sizes. It also takes a lot of practice to master.  Constraints Menu In addition to using cntrl+drag to create relative positioning between 2 views, we also define constraints to the view.   If a view does not have any siblings in the specified direction, then the nearest neighbor is its superview, also known as its container. Align Menu  View Controller A view controller is an instance of a subclass of UIViewController. A view controller manages a view hierarchy. It is responsible for creating view objects that make up the hierarchy and for handling events associated with the view objects in its hierarchy. Just think of a view controller as one view hierarchy. When an app switches between view controllers, it just means that it is switching between two different view heirarchies. The View of a View Controller As subclasses of UIViewController, all view controllers inherit an important property: var view: UIView!This property points to a UIView instance that is the root of the view controller’s view hierarchy. When the root  view of a view controller is added as a subview of the window, the view controller’s entire view hierarchy is added .  A view controller’s view is not created until it needs to appear on the screen. This optimization is called lazy loading, and it can conserve memory and improve performance. There are two ways that a view controller can create its view hierarchy:   in Interface Builder, by using an interface file such as a storyboard  programmatically, by overriding the UIViewController method loadView()  NOTE: Although a storyboard can have many view controllers, each storyboard file has exactly one initial view controller. The initial view controller acts as an entry point into the storyboard. How does UIWindow handle the view controllers? UIWindow has a rootViewController property. When a view controller is set as the window’s rootViewController, that view controller’s view gets added to the window’s view hierarchy. When this property is set, any existing subviews on the window are removed and the view controller’s view gets added to the window with the appropriate Auto Layout constraints. Each application has one main interface, a reference to a storyboard. When the application launches, the initial view controller for the main interface gets set as the rootViewController of the window. The main interface for an application is set in the project settings. In the General tab of the project settings, find the Deployment Info section. Here you will see the Main Interface setting. If it is set to Main, for example, it corresponds to Main.storyboard. Tab Bar Controllers UITabBarController keeps an array of view controllers. It also maintains a tab bar at the bottom of the screen with a tab for each view controller in its array. Tapping on a tab results in the presentation of the view of the view controller associated with that tab. UITabBarController is itself a subclass of UIViewController. A UITabBarController’s view is a UIView with twoprimary subviews: the tab bar and the view of the selected view controller  Tab bar items Each tab on the tab bar can display a title and an image, and each view controller maintains a tabBarItem property for this purpose. When a view controller is contained by a UITabBarController, its tab bar item appears in the tab bar. The order of the tabs is determined by the order of the view controllers within the tab bar controller’s viewControllers array. Accessing subviews Often, you will want to do some extra initialization or configuration of subviews defined in Interface Builder before they appear to the user. So where can you access a subview? There are two main options, depending on what you need to do. The first option is the viewDidLoad() method. This method is called after the view controller’s interface file is loaded, at which point all of the view controller’s outlets will reference the appropriate objects. The second option is another UIViewController method, viewWillAppear. This method is called just before a view controller’s view is added to the window. Which should you choose? Override viewDidLoad() if the configuration only needs to be done once during the run of the app. Override viewWillAppear if you need the configuration to be done each time the view controller’s view appears onscreen. Interacting with View Controllers and Their Views Let’s look at some methods that are called during the lifecycle of a view controller and its view. Some of these methods you have already seen, and some are new.       init(coder:) is the initializer for UIViewController instances created from a storyboard. When a view controller instance is created from a storyboard, its init(coder:) gets called once.         init(nibName:bundle:) is the designated initializer for UIViewController.     When a view controller instance is created without the use of a storyboard, its init(nibName:bundle:) gets called once. Note that in some apps, you may end up creating several instances of the same view controller class. This method will get called once on each view controller as it is created.         loadView() is overridden to create a view controller’s view programmatically.         viewDidLoad() is overridden to configure views created by loading an interface file. This method gets called after the view of a view controller is created.         viewWillAppear(_:) is overridden to configure views created by loading an interface file.     This method and viewDidAppear(:)** get called every time your view controller is moved onscreen. **viewWillDisappear(:) and viewDidDisappear(_:) get called every time your view controller is moved offscreen.   Programmatic View Composition UIView has an instance method addSubview(_:) which let’s you add a child view to its subviews collec4on. Other useful methods:   bringSubview(toFront:)  sendSubview(toBack:)  removeFromSuperview()  NOTE: When using bringSubview and sendSubview, remember that the view to be brought back or sent forward is also already loaded (no lazy loading here). Programmatic Constraints   Note:             Constraints need to be added to the most recent common ancestor for the views associated with the constraint.               Creating and activating constraints are two different steps.       let leadingAlignConstraint =    view1.leadingAnchor.constraint(equalTo: view2.leadingAnchor)leadingAlignConstraint.isActive = true Layout Margin Guides Every view has a layoutMargins property that denotes the default spacing to use when laying out content. This property is an instance of UIEdgeInsets, which you can think of as a type of frame. When adding constraints, you will use the layoutMarginsGuide, which exposes anchors that are tied to the edges of the layoutMargins. The primary advantage of using the margins is that the margins can change depending on the device type (iPad or iPhone) as well as the size of the device. Using the margins will give you content that looks good on any device. let margins = view.layoutMarginsGuidelet constraint =    someView.leadingAnchor.constraint(equalTo: margins.leadingAnchor)constraint.isActive = trueLayout Safe Area Guides View instances have a property to assist with layout content: the safeAreaLayoutGuide. This layout guide represents the rectangular extent to which the a view will be visible on screen. Using safeAreaLayoutGuide will allow your content to not underlap the status bar at the top of the screen or the tab bar at the bottom of the screen. Layout guides like safeAreaLayoutGuide expose anchors that you can use to add constraints, such as : topAnchor, bottomAnchor, heightAnchor and widthAnchor. Because you want the segmented control to be under the status bar and sensor housing, you will constrain the top anchor of the safe area layout guide to the top anchor of the segmented control. let constraint =    someView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor,constant: 20)constraint.isActive = trueControls func loadView() {    ...    let button = UIButton(type: .system)    // this is similar to what we do in the interface builder by dragging and dropping.    button.addTarget(self,           action: #selector(buttonTapped(_:)),           for: .touchUpInside)    ...}func buttonTapped(_ sender: UIButton) {    // do something}Control Events  Q. When exactly is the loadview() method called? When a view controller is created, its view property is nil. If a view controller is asked for its view and its view is nil, then the loadView() method is called.   NOTE:  Apple recommends that you create and constrain your views in Interface Builder whenever possible. However, if your views are created in code, then you will need to constrain them programmatically.   NOTE: Every view has an autoresizing mask. By default, iOS creates constraints that match the autoresizing mask and adds them to the view. These translated constraints will often conflict with explicit constraints in the layout and cause an unsatisfiable constraints problem. The fix is to turn off this default translation by setting the property translatesAutoresizingMaskIntoConstraints to false. Text Input &amp; Delegation Delegation is an object-oriented approach to callbacks. A callback is a function that is supplied in advance of an event and is called every time the event occurs. Some objects need to make a callback for more than one event. For instance, the text field needs to “callback” when the user enters text as well as when the user presses the Return key. However, there is no built-in way for two (or more) callback functions to coordinate and share information. This is the problem addressed by delegation – you supply a single delegate to receive all of the event-related callbacks for a particular object. This delegate object can then store, manipulate, act on, and relay the information from the callbacks as it sees fit.  textField.delegate = self // Our controller// In our controllerfunc textFieldShouldReturn(_ textField: UITextField) -&gt; Bool {    print(textField.text)    // dismisses the keyboard and gives up the first responder status    textField.resignFirstResponder()     return true // whether to perform the default action or not? default action is nothing  in this particular case.}  Conforming to this Protocol (it’s just like an interface in Java) class MyViewController: UIViewController, UITextFieldDelegate {}  NOTE: When the text field is tapped, the method becomeFirstResponder() is called on it. This is the methodthat, among other things, causes the keyboard to appear. To dismiss the keyboard, you call the methodresignFirstResponder() on the text field.   NOTE: A property observer, is a chunk of code that gets called whenever a property’s value changes. A property observer is declared using curly braces immediately after the property declaration. Inside the braces, you declare your observer using either willSet or didSet, depending on whether you want to be notified immediately before or immediately after the property value changes, respectively. Note that property observers are not triggered when the property value is changed from within an initializer. Internalization and Localization Internationalization is making sure your native cultural information (like language, currency, date format, number format, etc.) is not hardcoded into your application. Localization is the process of providing the appropriate data in your application based on the user’s Language and Region Format settings.   NOTE: Locale knows everything about local customs.   Some formatters to keep in Mind   Date Formatters  NumberFormatter  DateComponentsFormatter  DateIntervalFormatter  MassFormatter  EnergyFormatter  LengthFormatter  Address FormatterWhen internationalizing, you ask the instance of Locale questions. But the Locale only has a few region-specific variables. This is where localization – creating application-specific substitutions for different region and language settings – comes into play. Localization usually involves either generating multiple copies of resources (like images, sounds, and interface files) for different regions and languages or creating and accessing strings tables to translate text into different languages. When you build a target in Xcode, an application bundle is created. All of the resources that you added to the target in Xcode are copied into this bundle along with the executable itself. This bundle is represented at runtime by an instance of Bundle known as the main bundle. Many classes work with the Bundle to load resources. Localizing a resource puts another copy of the resource in the application bundle. These resources are organized into language-specific directories, known as lproj directories. Each one of these directories is the name of the localization suffixed with lproj. For example, the American English localization is en_US, where en is the English language code and US is the United States of America region code, so the directory for American English resources is en_US.lproj. (The region can be omitted if you do not need to make regional distinctions in your resource files.) These language and region codes are standard on all platforms, not just iOS. When a bundle is asked for the path of a resource file, it first looks at the root level of the bundle for a file of that name. If it does not find one, it looks at the locale and language settings of the device, finds the appropriate lproj directory, and looks for the file there. Thus, just by localizing resource files, your application will automatically load the correct file. One option for localizing resource files is to create separate storyboard files and manually edit each string in each file. However, this approach does not scale well if you are planning multiple localizations. What happens when you add a new label or button to your localized storyboard? You have to add this view to the storyboard for every language. Not fun. To simplify the process of localizing interface files, Xcode has a feature called base internationalization. Base internationalization creates the Base.lproj directory, which contains the main interface files. Localizing individual interface files can then be done by creating just the Localizable.strings files. It is still possible to create the full interface files, in case localization cannot be done by changing strings alone. NSLocalizedString and strings tables In many places in your applications, you create String instances dynamically or display string literals to the user. To display translated versions of these strings, you must create a strings table. A strings table is a file containing a list of key-value pairs for all of the strings that your application uses and their associated translations. It is a resource file that you add to your application, but you do not need to do a lot of work to get data from it. Table Views As a view object, a UITableView does not handle application logic or data. When using a UITableView, you must consider what else is necessary to get the table working in your application:   A UITableView typically needs a view controller to handle its appearance on the screen.  A UITableView needs a data source. A UITableView asks its data source for the number of rows to display, the data to be shown in those rows, and other tidbits that make a UITableView a useful UI. Without a data source, a table view is just an empty container. The dataSource for a UITableView can be any type of object as long as it conforms to the UITableViewDataSource protocol.  A UITableView typically needs a delegate that can inform other objects of events involving the UITableView. The delegate can be any object as long as it conforms to the UITableViewDelegate protocol.An instance of the class UITableViewController can fill all three roles: view controller, data source, and delegate. UITableViewController is a subclass of UIViewController and therefore has a view. A UITableViewController’s view is always an instance of UITableView, and the UITableViewController handles the preparation and presentation of the UITableView. When a UITableViewController creates its view, the dataSource and delegate properties of the UITableView are automatically set to point at the UITableViewController.  Custom Initializers for classes Classes can have two kinds of initializers: designated initializers and convenience initializers. A designated initializer is a primary initializer for the class. Every class has at least one designated initializer. A designated initializer ensures that all properties in the class have a value. Once it ensures that, a designated initializer calls a designated initializer on its superclass (if it has one). When you implement your own custom initializer, you lose the free initializer – init() – that classes have. The free initializer is useful when all of your class’s properties have default values and you do not need to do additional work to create the new instance. Every class must have at least one designated initializer, but convenience initializers are optional. You can think of convenience initializers as helpers. A convenience initializer always calls another initializer on the same class. Convenience initializers are indicated by the convenience keyword before the initializer name. Convenience initializers must call another initializer on the same type, whereas designated initializers must call a designated initializer on its superclass. Dependency Inversion Principle —&gt; V.IMP       The essential goal of this principle is to decouple objects in an application by inverting certain dependencies between them. This results in more robust and maintainable code.         The dependency inversion principle states that:     High-level objects should not depend on low-level objects. Both should depend on abstractions.  Abstractions should not depend on details. Details should depend on abstractions.Example - The abstraction required by the dependency inversion principle in LootLogger is the concept of a “store.” A store is a lower-level object that retrieves and saves Item instances through details that are only known to that class. ItemsViewController is a higher-level object that only knows that it will be provided with a utility object (the store) from which it can obtain a list of Item instances and to which it can pass new or updated Item instances to be stored persistently. This results in a decoupling because ItemsViewController is not dependent on ItemStore. In fact, as long as the store abstraction is respected, ItemStore could be replaced by another object that fetches Item instances differently (such as by using a web service) without any changes to ItemsViewController.   A common pattern used when implementing the dependency inversion principle is dependency injection. In its simplest form, higher-level objects do not assume which lower-level objects they need to use. Instead, those are passed to them through an initializer or property.  In our implementation of ItemsViewController, we used injection through a property to give it a store.Data Source Methods When a UITableView wants to know what to display, it calls methods from the set of methods declared in the UITableViewDataSource protocol. UITableViewCells   Each row of a table view is a view. These views are instances of UITableViewCell.  A cell itself has one subview – its contentView. The contentView is the superview for the content of the cell. The cell may also have an accessory view.  The accessory view shows an action-oriented icon, such as a checkmark, a disclosure icon, or an information button. These icons are accessed through predefined constants for the appearance of the accessory view. The default is UITableViewCellAccessoryType.none.  The real meat of a UITableViewCell is the contentView, which has three subviews of its own. Two of those subviews are UILabel instances that are properties of UITableViewCell named textLabel and detailTextLabel. The third subview is a UIImageView called imageView. In this chapter, you will use textLabel and detailTextLabel. Reusing UITableViewCells   iOS devices have a limited amount of memory. If you were displaying a list with thousands of entries in a UITableView, you would have thousands of instances of UITableViewCell. Most of these cells would take up memory needlessly. After all, if the user cannot see a cell onscreen, then there is no reason for that cell to have a claim on memory.  To conserve memory and improve performance, you can reuse table view cells. When the user scrolls the table, some cells move offscreen. Offscreen cells are put into a pool of cells available for reuse. Then, instead of creating a brand new cell for every request, the data source first checks the pool. If there is an unused cell, the data source configures it with new data and returns it to the table view.  There is one problem to be aware of: Sometimes a UITableView has different types of cells. Occasionally, you subclass UITableViewCell to create a special look or behavior. However, different subclasses floating around the pool of reusable cells create the possibility of getting back a cell of the wrong type. You must be sure of the type of the cell returned so that you can be sure of what properties and methods it has.  Note that you do not care about getting any specific cell out of the pool because you are going to change the cell content anyway. What you need is a cell of a specific type. The good news is that every cell has a reuseIdentifier property of type String. When a data source asks the table view for a reusable cell, it passes a string and says, “I need a cell with this reuse identifier.” By convention, the reuse identifier is typically the name of the cell class.  To reuse cells, you need to register either a prototype cell or a class with the table view for a specific reuse identifier. The reuse identifier is an arbitrary string.  The method dequeueReusableCell(withIdentifier:for:) will check the pool, or queue, of cells to see whether a cell with the correct reuse identifier already exists. If so, it will “dequeue” that cell. If there is not an existing cell, a new cell will be created and returned.Editing Table Views One of the great feature of table views is their built-in support for editing. This includes inserting new rows, deleting existing rows, and rearranging rows. In this section, you will add in support for all three of those features to LootLogger. Editing Mode UITableView has an editing property, and when this property is set to true, the UITableView enters editing mode. Once the table view is in editing mode, the rows of the table can be manipulated by the user. Depending on how the table view is configured, the user can change the order of the rows, add rows, or remove rows. (Editing mode does not allow the user to edit the content of a row.)  Adding and Deleting Items Remember that the role of a view object is to present model objects to the user; updating views without updating the model objects is not very useful. Design Patterns The consistent use of design patterns throughout the development process reduces the mental overhead in solving a problem so you can create complex applications more easily and rapidly. Here are some of the design patterns that Apple is very consistent with:   Delegation: One object delegates certain responsibilities to another object. We used delegation with the UITextField to be informed when the contents of the text field change.  Data source: A data source is similar to a delegate, but instead of reacting to another object, a data source is responsible for providing data to another object when requested. We used the data source pattern with table views: Each table view has a data source that is responsible for, at a minimum, telling the table view how many rows to display and which cell it should display at each index path.  Model-View-Controller: Each object in your applications fulfills one of three roles. Model objects are the data. Views display the UI. Controllers provide the glue that ties the models and views together.  Target-action pairs: One object calls a method on another object when a specific event occurs. The target is the object that has a method called on it, and the action is the method being called. For example, we used target- action pairs with buttons: When a touch event occurs, a method will be called on another object (often a view controller).Subclassing UITableViewCell A UITableView displays a list of UITableViewCell objects. For many applications, the basic cell with its textLabel, detailTextLabel, and imageView is sufficient. However, when you need a cell with more detail or a different layout, you subclass UITableViewCell. Customizing the Cell   You customize the appearance of UITableViewCell subclasses by adding subviews to its contentView. Adding subviews to the contentView instead of directly to the cell itself is important because the cell will resize the contentView inside it at certain times.  For example, when a table view enters editing mode, the contentView resizes itself to make room for the editing controls. If you added subviews directly to the UITableViewCell, the editing controls would obscure the subviews. The cell cannot adjust its size when entering edit mode (it must remain the width of the table view), but the contentView can and does. Dynamic Type Creating an interface that appeals to everyone can be daunting. Some people prefer more compact interfaces so they can see more information at once. Others might want to be able to easily see information at a glance, or perhaps they have poor eyesight. In short: People have different needs. Good developers strive to make apps that meet those needs. Dynamic Type is a technology that helps realize this goal by providing specifically designed text styles that are optimized for legibility. Users can select one of seven preferred text sizes from within Apple’s Settings application (plus a few additional larger sizes from within the Accessibility section), and apps that support Dynamic Type will have their fonts scaled appropriately. The Dynamic Type system is centered around text styles. When a font is requested for a given text style, the system will consider the user’s preferred text size in association with the text style to return an appropriately configured font.  Responding to user changes When the user changes the preferred text size and returns to the application, the table view will get reloaded. Unfortunately, the labels will not know about the new preferred text size. To fix this, you need to have the labels automatically adjust to content size changes. Open Main.storyboard and select all three ItemCell labels. Open the attributes inspector, and check the box for Automatically Adjusts Font Bad Cell Constraints  Since there are are no vertical constraints, the label will be centered with height 0 and would thus, be invisible. Better Cell constraints  Stack Views Auto Layout can be used to create flexible interfaces that scale across device types and sizes. Auto Layout is a very powerful technology, but with that power comes complexity. Laying out an interface well often needs a lot of constraints, and it can be difficult to create dynamic interfaces due to the need to constantly add and remove constraints. Interfaces that have a linear layout are great candidates for using a stack view. A stack view is an instance ofUIStackView that allows you to create a vertical or horizontal layout that is easy to lay out and manages most of the constraints that you would typically have to manage yourself. Perhaps best of all, you are able to nest stack views within other stack views, which allows you to create truly amazing interfaces in a fraction of the time.   Nesting stack views is very common when creating more complex layouts  A stack view’s “arranged views” are a subset of its “subviews”  –&gt; because views may be hidden.  Can dynamically add/remove views in a stack view  Can dynamically change any of the stack views propertiesProperties of StackView   Hiding Views inside Stackview class ViewController: UIViewController {    @IBAction func hideViewTapped(_ sender: UIButton) {        UIView.animate(withDuration: 1.0) {            sender.superview?.isHidden = true        }    }}Implicit Constraints A view has one of these priorities for each axis:   horizontal content hugging priority  vertical content hugging priority  horizontal content compression resistance priority  vertical content compression resistance priorityContent hugging priorities The content hugging priority is like a rubber band that is placed around a view. The rubber band makes the view not want to be bigger than its intrinsic content size in that dimension. Each priority is associated with a value from 0 to 1000. A value of 1000 means that a view cannot get bigger than its intrinsic content size on that dimension. Content compression resistance priorities The content compression resistance priorities determine how much a view resists getting smaller than its intrinsic content size. Segues   Most iOS applications have a number of view controllers that users navigate between. Storyboards allow you to set up these interactions as segues without having to write code.  A segue moves another view controller’s view onto the screen and is represented by an instance of UIStoryboardSegue.  Each segue has a style, an action item, and an identifier.  The style of a segue determines how the view controller will be presented.  The action item is the view object in the storyboard file that triggers the segue, like a button, a table view cell, or some other UIControl.  The identifier is used to programmatically access the segue. This is useful when you want to trigger a segue that does not come from an action item, like a shake or some other interface element that cannot be set up in the storyboard file.Passing Data Around Whenever a segue is triggered, the prepare(for:sender:) method is called on the view controller initiating the segue. This method has two arguments: the UIStoryboardSegue, which gives you information about which segue is happening, and the sender, which is the object that triggered the segue (a UITableViewCell or a UIButton, for example). The UIStoryboardSegue gives you three pieces of information: the source view controller (where the segue originates), the destination view controller (where the segue ends), and the identifier of the segue. The identifier lets you differentiate segues. Let’s give the segue a useful identifier. UINavigationController       A UINavigationController maintains an array of view controllers presenting related information in a stack. When a UIViewController is on top of the stack, its view is visible.         When you initialize an instance of UINavigationController, you give it a UIViewController. This UIViewController is added to the navigation controller’s viewControllers array and becomes the navigation controller’s root view controller. The root view controller is always on the bottom of the stack.           Note: While this view controller is referred to as the navigation controller’s “root view controller,” UINavigationController does not have a rootViewController property.             More view controllers can be pushed on top of theUINavigationController’s stack while the application is running. These view controllers are added to the end of the viewControllers array that corresponds to the top of the stack. UINavigationController’s topViewController property keeps a reference to the view controller at the top of the stack.         When a view controller is pushed onto the stack, its view slides onscreen from the right. When the stack is popped (i.e., the last item is removed), the top view controller is removed from the stack and its view slides off to the right, exposing the view of the next view controller on the stack, which becomes the top view controller.         The view of the topViewController is what the user sees.         UINavigationController is a subclass of UIViewController, so it has a view of its own. Its view always has two subviews: a UINavigationBar and the view of topViewController    Appearing and Disappearing Views   Whenever a UINavigationController is about to swap views, it calls two methods: viewWillDisappear(:) and viewWillAppear(:). The UIViewController that is about to be popped off the stack has viewWillDisappear(:) called. The UIViewController that will then be on top of the stack has viewWillAppear(:) called on it.  To hold on to changes in the data, when a DetailViewController is popped off the stack you will set the properties of its item to the contents of the text fields. When implementing these methods for views appearing and disappearing, it is important to call the superclass’s implementation – it might have some work to do and needs to be given the chance to do it.First Responder Status   For the shake and keyboard events, for example, there is no event location within your view hierarchy to determine which view will receive the event, so another mechanism must be used. This mechanism is the first responder status. Many views and controls can be a first responder within your view hierarchy – but only one at a time. Think of it as a flag that can be passed among views. Whichever view holds the flag will receive the shake or keyboard event.  Instances of UITextField and UITextView have an uncommon response to touch events. When touched, a text field or a text view becomes the first responder, which in turn triggers the system to put the keyboard onscreen and send the keyboard events to the text field or view. The keyboard and the text field or view have no direct connection, but they work together through the first responder status.  This is a neat way to ensure that the keyboard input is delivered to the correct text field. The concept of a first responder is part of the broader topic of event handling in Cocoa Touch programming that includes the UIResponder class and the responder chain. You can visit Apple’s Event Handling Guide for iOS for more information.UINavigationBar       Every UIViewController has a navigationItem property of type UINavigationItem. However, unlikeUINavigationBar, UINavigationItem is not a subclass of UIView, so it cannot appear on the screen.         Instead, the navigation item supplies the navigation bar with the content it needs to draw. When a UIViewController comes to the top of a UINavigationController’s stack, the UINavigationBar uses the UIViewController’s navigationItem to configure itself.         By default, a UINavigationItem is empty. At the most basic level, a UINavigationItem has a simple title string. When a UIViewController is moved to the top of the navigation stack and its navigationItem has a valid string for its title property, the navigation bar will display that string.              A navigation item can hold more than just a title string. There are three customizable areas for each UINavigationItem: a leftBarButtonItem, a rightBarButtonItem, and a titleView. The left and right bar button items are references to instances of UIBarButtonItem, which contain the information for a button that can only be displayed on a UINavigationBar or a UIToolbar.         Recall that UINavigationItem is not a subclass of UIView. Instead, UINavigationItem encapsulates information that UINavigationBar uses to configure itself. Similarly, UIBarButtonItem is not a view, but holds the information about how a single button on the UINavigationBar should be displayed. (A UIToolbar also uses instances of UIBarButtonItem to configure itself.)         The third customizable area of a UINavigationItem is its titleView. You can either use a basic string as the title or have a subclass of UIView sit in the center of the navigation item. You cannot have both. If it suits the context of a specific view controller to have a custom view (like a segmented control or a text field, for example), you would set the titleView of the navigation item to that custom view. Typically, however, a title string is sufficient.          When you initialize an instance of UINavigationController, you give it a UIViewController. ThisUIViewController is added to the navigation controller’s viewControllers array and becomes the navigation controller’s root view controller. The root view controller is always on the bottom of the stack.           Note: While this view controller is referred to as the navigation controller’s “root view controller,” UINavigationController does not have a rootViewController property.         More view controllers can be pushed on top of theUINavigationController’s stack while the application is running. These view controllers are added to the end of the viewControllers array that corresponds to the top of the stack. UINavigationController’s topViewController property keeps a reference to the view controller at the top of the stack.   Saving, Loading and Error Handling   NOTE: Saving and loading “data” almost always means saving and loading model objects.       To save and load model objects to and from the disk, we need to make them of type codable.         Types whose instances need to be codable conform to the Encodable and Decodable protocols and implement their two required methods, encode(to:) and init(from:), respectively.   protocol Decodable {    init(from decoder: Decoder) throws}protocol Encodable {    func encode(to encoder: Encoder) throws}Although your types can conform to just one of these protocols, it’s common for types to conform to both. Apple has a type alias for types that conform to both protocols called Codable. typealias Codable = Decodable &amp; Encodable Property Lists       A property list is a representation of some data that can be saved to disk and read back in at a later point. Property lists can represent hierarchies of data and so are a great tool for saving and loading lightweight object graphs.     Under the hood, property list data can be represented by a number of formats, they are frequently represented using an XML or binary format.  Property lists can hold the following types: Array, Dictionary, String, Data, Date, Int, Float, and Bool. As long as a given type is composed of those types, or a hierarchy of those types, then it can be represented as a property list.func saveChanges() -&gt; Bool {        let encoder = PropertyListEncoder()    // You will have an error on the next line, for not catching errors.    let data = encoder.encode(allItems)    return false}Error Handling   Optionals provide a simple way to represent failure when you do not care about the reason for failure. When you need to know why something failed, an optional will not provide enough information.  If a method could generate an error, its method signature needs to indicate this using the throws keyword. Error throwing and exception hanndling is ‘opt-in’ in Swift.  The throws keyword indicates that this method could throw an error. (If you are familiar with throwing exception in other languages, Swift’s error handling is not the same as throwing exception.)  By using this keyword, the compiler ensures that anyone who uses this method knows that this method can throw an error – and, more importantly, that the caller also handles any potential errors.  To call a method that can throw, you use a do-catch statement. Within the do block, you annotate any methods that might throw an error using the try keyword to reinforce the idea that the call might fail.  If a method does throw an error, then the program immediately exits the do block; no further code in the do block is executed. At that point, the error is passed to the catch block for it to be handled in some way.func deleteImage(at imageURL: URL) {    let fileManager = FileManager.default    do {        // need try for every statement that can fail        try fileManager.removeItem(at: imageURL) // this method might throw an error} catch {         print(\"Error removing image: \\(error)\")    }} Application Sandbox Every iOS application has its own application sandbox. An application sandbox is a directory on the filesystem that is barricaded from the rest of the filesystem. Your application must stay in its sandbox, and no other application can access its sandbox.  Constructing a file URL The instances of our model objects will be saved to a single file in the Documents directory. The store will handle writing to and reading from that file. To do this, the store needs to construct a URL to this file. // Adding a URL where the items will be saved tovar allItems = [Item]()let itemArchiveURL: URL = {    let documentsDirectories =        FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)    let documentDirectory = documentsDirectories.first!    return documentDirectory.appendingPathComponent(\"items.plist\")}()      The method urls(for:in:) searches the filesystem for a URL that meets the criteria given by the arguments.         In iOS, the last argument is always the same. (This method is borrowed from macOS, where there are significantly more options.) The first argument is a SearchPathDirectory enumeration that specifies the directory in the sandbox you want the URL for. For example, searching for .cachesDirectory will return the Caches directory in the application’s sandbox.   Persisting the Items You have a place to save data on the filesystem and a model object that can be saved to the filesystem. How do you kick off the saving and loading processes, and when do you do it? // Writing data to diskfunc saveChanges() -&gt; Bool {\tprint(\"Saving items to: \\(itemArchiveURL)\")    do {        let encoder = PropertyListEncoder()        let data = try encoder.encode(allItems)         try data.write(to: itemArchiveURL)         return true \t    } catch let encodingError {        print(\"Error encoding allItems: \\(encodingError)\")        return false     } }   NOTE: When the user leaves the application (often by swiping up on the Home indicator), the messageapplicationDidEnterBackground(_:) is sent to the AppDelegate. Loading the Items init() {     do {         let data = try Data(contentsOf: itemArchiveURL)        let unarchiver = PropertyListDecoder()        let items = try unarchiver.decode([Item].self, from: data)        allItems =  items\t} catch {         print(\"Error reading in saved items: \\(error)\")    }} Application States and Transitions When an application is not running, it is in the not running state and it does not execute any code or have any memory reserved in RAM. After the user launches an application, it enters the active state. When in the active state, an application’s interface is on the screen, it is accepting events, and its code is handling those events. While in the active state, an application can be temporarily interrupted by a system event like an SMS message, push notification, phone call, or alarm. An overlay will appear on top of your application to handle this event, and the application enters the inactive state. In the inactive state, an application is visible behind the overlay and is executing code, but it is not receiving events. Applications typically spend very little time in the inactive state. You can force an active application into the inactive state by pressing the Lock button at the top of the device. The application will stay inactive until the device is unlocked. When the user swipes up on the Home indicator or switches to another application in some other way, the application enters the background state. (Actually, it spends a brief moment in the inactive state before transitioning to the background state.) In the background state, an application’s interface is not visible or receiving events, but it can still execute code. By default, an application that enters the background state has about 10 seconds before it enters the suspended state. Your application should not rely on this number; instead, it should save user data and release any shared resources as quickly as possible. An application in the suspended state cannot execute code. You cannot see its interface, and any resources it does not need while suspended are destroyed. A suspended application is essentially flash-frozen and can be quickly thawed when the user relaunches it. Application states flow chart  Q. If the app cannot execute any code when in the suspended state, how do chat apps receive push notifications? These push notifications are generally coming from a web service. These web services push the data to Apple, and Apple then sends us the notification. The code for sending these push nontifications is not in our app. Q. How can we reply directly from the notification then? Such actions in response to notifications is possible when we have a separate small “app” bundled with our app. This small app generally has a single view controller. When we reply from the notification window, we are basically using this small app, as opposed to our main application. This app has it’s own separae application state and transitions. So, our app need not be made active for such actions to be performed. Q. What does the background app refresh option do? When background app refresh is enabled, the OS may decide to enable the app to load or refresh it’s data for a brief period of time, when the OS is not busy doing other things. So for this brief period, the app may be made active, and then back to inactive and suspended.   NOTE: You can see what applications are in the background or suspended by swiping up and pausing on the Home indicator to get to the task switcher An application in the suspended state will remain in that state as long as there is adequate system memory. When the OS decides memory is getting low, it will terminate suspended applications as needed. A suspended application gets no indication that it is about to be terminated. It is simply removed from memory. (An application may remain in the task switcher after it has been terminated, but it will have to relaunch when tapped.) The Application Bundle When you build an iOS application project in Xcode, you create an application bundle. The application bundle contains the application executable and any resources you have bundled with your application. Resources are things like storyboard files, images, and audio files – any files that will be used at runtime. When you add a resource file to a project, Xcode is smart enough to realize that it should be bundled with your application. How can you tell which files are being bundled with your application? Select the project name from the project navigator. Check out the Build Phases pane in the project target. Everything under Copy Bundle Resources will be added to the application bundle when it is built. Modals and Popovers For example, when adding a new contact to your phone, you are presented with a screen to fill out the contact’s details. We call this kind of presentation a modal presentation as the application is being put into a different mode where a certain set of actions become our focus. Modally presented view controllers often occupy the entire screen, but in certain contexts they might only take up aportion of the screen. This is especially true on iPad where there is more space to work with. In either case, the user is expected to interact with the modally presented view controller before proceeding. Alert controllers To allow the user to choose a photo source, you will present an alert with the possible choices. Alerts are often used to display information to the user on which they must act. When you want to display an alert, you create an instance of UIAlertController with a preferred style. The two available styles are UIAlertControllerStyle.actionSheet and UIAlertControllerStyle.alert Presenting programmatically class CalendarViewController: UIViewController {    func addNewEvent(_ sender: UIBarButtonItem) {        let viewController = NewCalendarEventViewController()        present(viewController, animated: true, completion: nil)    }}Dismissing class CalendarViewController: UIViewController {    func cancel(_ sender: UIBarButtonItem) {        dismiss(animated: true, completion: nil)    }}  Completion closure dismiss(animated: true, completion: {    print(\"View controller finished dismissing!\")})Permissions There are a number of capabilities on iOS that require user approval before use. Here are a subset of those capabilities:   Camera and photos  Location  Microphone  HealthKit data  Calendar  RemindersFor each of these, your application must supply a usage description that specifies the reason that your application wants to access this information. This description will be presented to the user whenever the application accesses that capability. Caching in the data store class ImageStore {     let cache = NSCache&lt;NSString,UIImage&gt;()    func setImage(_ image: UIImage, forKey key: String) {        cache.setObject(image, forKey: key as NSString)    }    func image(forKey key: String) -&gt; UIImage? {        return cache.object(forKey: key as NSString)    }    func deleteImage(forKey key: String) {        cache.removeObject(forKey: key as NSString)    }}Note that the cache is associating an instance of NSString with UIImage. NSString is Objective-C’s version ofString. Due to the way NSCache is implemented (it is an Objective-C class, like most of Apple’s classes that you have been working with), it requires you to use NSString instead of String. // MARK: As your classes get longer, it can get more difficult to find a method buried in a long list of methods. A good way to organize your methods is to use // MARK: comments. Two useful // MARK: comments are the divider and the label: // This is a divider // MARK: - // This is a label// MARK: My Awesome MethodsThe divider and label can be combined: // MARK: - View life cycleoverride func viewDidLoad() { ... }override func viewWillAppear(_ animated: Bool) { ... }// MARK: - Actionsfunc addNewItem(_ sender: UIBarButtonItem) {...} Size classes The relative sizes of screens are defined in size classes. A size class represents a relative amount of screen space in a given dimension. Each dimension (width and height) can either be compact or regular, so there are four possible combinations of size classes:  Notice that the size classes cover both screen sizes and orientations. Instead of thinking about interfaces in terms of orientation or device, it is better to think in terms of size classes. Modifying Traits for a Specific Size Class When editing the interface for a specific size class combination, you are able to change:   properties for many views  whether a specific subview is installed  whether a specific constraint is installed  the constant of a constraint  the font for subviews that display text  NOTE: To detect a change in device orientation, we can use viewWillTransition(to:with:). Varying constraints for different size classes       To activate constraints on only a particular size classes ,for a partiular trait, you can change things like the axis of the stack view, and it will be applied to only that particular device orientation. We can add size-class-specific options to do this.         You can also deactivate particular constraints for a particular trait variation (by disabling the install checkbox when in the trait variation).   Web Services Building the URL Communication with servers is done via requests. A request encapsulates information about the interaction between the application and the server, and its most important piece of information is the destination URL. Access Control You can control what can access the properties and methods on your own types. There are five levels of access control that can be applied to types, properties, and methods:   open – This is used only for classes, and mostly by framework or third-party library authors. Anything can access this class, property, or method. Additionally, classes marked as open can be subclassed and methods can be overridden outside of the module.  public – This is very similar to open; however, classes can only be subclassed and methods can only be overridden inside (not outside of) the module.  internal – This is the default. Anything in the current module can access this type, property, or method. For an app, only files within your project can access these. If you write a third-party library, then only files within that third-party library can access them – apps that use your third-party library cannot.  fileprivate – Anything in the same source file can see this type, property, or method.  private – Anything within the enclosing scope can access this type, property, or method.Sending the Request   A URL request encapsulates information about the communication from the application to the server. Mostimportantly, it specifies the URL of the server for the request, but it also has a timeout interval, a cache policy, and other metadata about the request. A request is represented by the URLRequest class.  The URLSession API is a collection of classes that use a request to communicate with a server in a number of ways. The URLSessionTask class is responsible for communicating with a server. The URLSession class is responsible for creating tasks that match a given configuration.  The class that communicates with the web service is an instance of URLSessionTask. There are three kinds of tasks: data tasks, download tasks, and upload tasks. URLSessionDataTask retrieves data from the server and returns it as Data in memory. URLSessionDownloadTask retrieves data from the server and returns it as a file saved to the filesystem. URLSessionUploadTask sends data to the server.  Often, you will have a group of requests that have many properties in common. For example, maybe some downloads should never happen over cellular data, or maybe certain requests should be cached differently than others. It can become tedious to configure related requests the same way.      This is where URLSession comes in handy. URLSession acts as a factory for URLSessionTask instances. The session is created with a configuration that specifies properties that are common across all of the tasks that it creates. Although many applications might only need to use a single instance of URLSession, having the power and flexibility of multiple sessions is a great tool to have at your disposal.     Fetching data from a web service is an asynchronous process: Once the request starts, it may take a nontrivial amount of time for a response to come back from the server. Because of this, the fetchInterestingPhotos(completion:) method cannot directly return an instance of PhotosResult. Instead, the caller of this method will supply a completion closure for the PhotoStore to call once the request is complete.  This follows the same pattern that URLSessionTask uses with its completion handler: The task is created with a closure for it to call once the web service request completes. Figure 20.6 describes the flow of data with the web service request. The Main Thread   Modern iOS devices have multicore processors that enable them to run multiple chunks of code simultaneously. A common way to express this is by representing each computation with a different thread of control.  When the web service completes, you want it to update the image view. But by default, URLSessionDataTask runs the completion handler on a background thread. You need a way to force code to run on the main thread to update the image view. You can do that easily using the OperationQueue class.Collection Views Creating a UICollectionView let layout = UICollectionViewFlowLayout()let cv = UICollectionView(frame: frame, collectionViewLayout: layout)cv.delegate = selfcv.dataSource = selfUICollectionViewDataSource var photos: [Photos] = ...func collectionView(_ collectionView: UICollectionView,        numberOfItemsInSection section: Int) -&gt; Int {    return photos.count}func collectionView(_ collectionView: UICollectionView,        cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {    let identifier = \"UICollectionViewCell\"    let cell =        collectionView.dequeueReusableCell(withReuseIdentifier: identifier,                                           for: indexPath)    // Configure the cell    return cell } Customizing a Collection Layout   The display of cells is not driven by the collection view itself but by the collection view’s layout. The layout object is responsible for the placement of cells onscreen. Layouts, in turn, are driven by a subclass of UICollectionViewLayout. The flow layout that Photorama is currently using is UICollectionViewFlowLayout, which is the only concrete UICollectionViewLayout subclass provided by the UIKit framework. Some of the properties you can customize on UICollectionViewFlowLayout are:   scrollDirection – Do you want to scroll vertically or horizontally?  minimumLineSpacing – What is the minimum spacing between lines?  minimumInteritemSpacing – What is the minimum spacing between items in a row (or column, if scrolling horizontally)?  itemSize – What is the size of each item?  sectionInset – What are the margins used to lay out content for each section?","categories": ["Tech"],
        "tags": [],
        "url": "http://localhost:4000/iOS-Development/",
        "teaser":"http://localhost:4000/images/avatar.jpg"},{
        "title": "Intro to ML by Parth Mehta",
        "excerpt":"Supervised Machine Learning Models Focus of the talk   Understand core concepts and terminologies for Machine Learning  How to build Machine Learning models for classification problems and evaluate them  Supervised Learning models  Solve an actual ML problem posted on KaggleWhat is Machine Learning (ML)?   Machine learning is about extracting knowledge from data.  We want to learn, from a large dataset, to make decisions based on future observations.  You input to a machine learning program a dataset, and it learns to make decisions on future observations by itself.Why Machine Learning?   Creating rule-based system requires deep understanding of how the rules should be made, by an expert.  The logic required to make a decision is specific to a single domain and task. Changing the task even slightly might require a rewrite of the whole system.  You cannot create RULES for everything - eg. image recoginitionTypes of Machine Learning   Supervised Learning    &lt;==   Our focus for today  Unsupervised Learning  Reinforcement Learning (RL)Supervised Learning   Machine learning algorithms that learn from input/output pairs are called supervised learning algorithms      The desired outputs (Y vector in the image below) provided for each example act as a “supervisor” to the algorithms to help them learn.         Most common type of ML in industry and research currently.     A common example is spam filtering.Mathematically Speaking Supervised learning is where you have input variables (x) and an output variable (Y) and you use an algorithm to learn the mapping function from the input to the output. Y = f(X) The goal is to approximate the mapping function so well that when you have new input data (x) that you can predict the output variables (Y) for that data. Unsupervised Learning in contrast       In unsupervised learning, even for the given dataset, only the input data is known, and no known output data is given to the algorithm.         A common example is Identifying topics in a set of blog posts   Reinforcement Learning (RL)       This branch is increasingly ganining popularity. Alpha Go program from DeepMind company, that defeated the world champion in the game of Go used RL.         Reinforcement learning is about an agent learning to interact with an environment, with some ultimate goal. When the agent performs a desired action, the algorithm rewards the agent, and when it makes a mistake, the algorithm penalizes the agent. This helps the agent learn.   Important Python Libraries Some important python libraries and their uses: scikit-learn or sklearn - scikit-learn is a very popular tool, and the most prominent Python library for machine learning. It contains a number of state-of-the-art machine learning algorithms, as well as comprehensive documentation about each algorithm. NumPy - scikit-learn takes in data only in the form of NumPy arrays. It contains functionality for multidimensional arrays, and complex math operations. matplotlib - matplotlib is the primary scientific plotting library in Python. pandas - pandas is a Python library for data wrangling and analysis. A pandas DataFrame is a table, similar to an Excel spreadsheet. pandas also provides the ability to ingest data from variety of file formats like CSV, SQL, excel files, etc. Basic Terminology To understand the concepts and examples that follow, we need to grasp on some basic terminology used in Machine Learning. Let’s do that with an example from sklearn import datasetsdigits = datasets.load_digits() #pre-loaded labelled datasetprint(digits.keys())dict_keys(['data', 'target', 'target_names', 'images', 'DESCR'])print(\"Dimensions of the data\\n{}\".format(digits.images.shape))Dimensions of the data(1797, 8, 8)This tells us that in my dataset, there are 1797 images, each with dimensions 8 x 8 (64 pixels) This is a very small and simple image dataset.Every single image is a grayscale image, where each pixel is represented by a brightness value from 0 to 16. Let’s look at how these images look like: % matplotlib inlineimport matplotlib.pyplot as pltimages_and_labels = list(zip(digits.images, digits.target))for index, (image, label) in enumerate(images_and_labels[:8]):    plt.subplot(2, 4, index + 1)    plt.axis('off')    plt.imshow(image, cmap=plt.cm.gray_r, interpolation='nearest')    plt.title('Labels: %i' % label) Let’s see how a single image looks like in code. print(\"Arrangement of pixels in first image of the dataset\\n\\n{}\".format(digits.images[0]))Arrangement of pixels in first image of the dataset[[ 0.  0.  5. 13.  9.  1.  0.  0.] [ 0.  0. 13. 15. 10. 15.  5.  0.] [ 0.  3. 15.  2.  0. 11.  8.  0.] [ 0.  4. 12.  0.  0.  8.  8.  0.] [ 0.  5.  8.  0.  0.  9.  8.  0.] [ 0.  4. 11.  0.  1. 12.  7.  0.] [ 0.  2. 14.  5. 10. 12.  0.  0.] [ 0.  0.  6. 13. 10.  0.  0.  0.]]Data representation Since Machine Learning largely includes various mathematical operations over data, we need to represent our data in a way that we can apply these math operations in an optimized way The way we do it is to represent data in the form of matrices, or in programming terms, a 2D array. Since, each our image is an 8 x 8 matrix and we have about 1800 images, our data is currently represented in 3 dimensions (1800 x 8 x 8). So instead, we represent each image as a 1 x 64 matrix (or a vector). By doing this, our dataset of images would be a 2D matrix (1800 x 64) print(\"Dimensions of the data\\n{}\\n\".format(digits.data.shape))print(\"Representation of a single image\\n{}\".format(digits.data[0]))Dimensions of the data(1797, 64)Representation of a single image[ 0.  0.  5. 13.  9.  1.  0.  0.  0.  0. 13. 15. 10. 15.  5.  0.  0.  3. 15.  2.  0. 11.  8.  0.  0.  4. 12.  0.  0.  8.  8.  0.  0.  5.  8.  0.  0.  9.  8.  0.  0.  4. 11.  0.  1. 12.  7.  0.  0.  2. 14.  5. 10. 12.  0.  0.  0.  0.  6. 13. 10.  0.  0.  0.]So let’s say this is the data we would be working on. GOAL:  To create a model, that learns what digit the images represent and predict accurately the digit in a new image given to it. Now, that we have the data and have set our goal, we are ready to learn some terms: Sample: Each sample refers to a single row in a dataset. In our case, a sample would be a single image. Feature: Each column in the dataset is known as a feature vector and each entry in a sample is a feature. For our images, the pixel value is a feature. So our images have 64 features each. Features are the properties of a sample, that help the machine understand and learn about the sample. Label: Ground truth value of a sample. These are the values against which we check how accurate our predictions are. In our example, the label array tells us the actual value of the digits in the images. print(\"Dimensions of the labels array\\n{}\\n\".format(digits.target.shape))print(\"Target labels of the images\\n{}\".format(digits.target))Dimensions of the labels array(1797,)Target labels of the images[0 1 2 ... 8 9 8]Generalization, Training Data, Test Data One of the most important concepts to learn in supervised machine learning, is of generalization.       We want to build a machine learning model from this data that can predict the number in a new image. We need some data on which we can assess how our model is doing.         Unfortunately, we cannot use the data we used to build the model, to evaluate it too. This is because our model can always simply remember the whole training set, and will therefore always predict the correct label for any point in the training set.         This “remembering” does not indicate to us whether our model will also perform well on new data (in other words, whether it will generalize well).         To assess the model’s learning at every step, we show it new data (data that it hasn’t seen while learning), but for which we have labels.         This is usually done by splitting the labeled data we have collected (our 1797 images) into two parts. One part of the data is used to build our machine learning model, and is called the training data or training set. The rest of the data will be used to assess how well the model works; this is called the test data, test set, or hold-out set.         Think of this as your Math exam in school!!   from sklearn.model_selection import train_test_splitfrom sklearn import svm# separating out data for training and testingX_train, X_test, y_train, y_test = train_test_split(        digits['data'], digits['target'], random_state=0)# setting parameters for our modelclassifier_model = svm.SVC(gamma=0.01, C=100.)# training the model on the train data only!classifier_model.fit(X_train, y_train)# Let's check how well the model has learned on the training datatrain_accuracy = classifier_model.score(X_train, y_train)print('Train accuracy: {}%\\n'.format(train_accuracy * 100))Train accuracy: 100.0%Training accuracy only indicates that our model has learned the training set properties well. It doesn’t say how well it will perform on new data. # Now I have a model that has learned to predict the digits, given images. Let's test it out on 1 new imagesingle_prediction = classifier_model.predict(X_test[0].reshape(1, -1))print('prediction on new image \\n{}\\n'.format(single_prediction))# Now let's see if this matches with the actual label (ground-truth)plt.imshow(X_test[0].reshape(8,8), cmap=plt.cm.gray_r, interpolation='nearest')print('label of the new image \\n{}\\n'.format(y_test[0]))prediction on new image [2]label of the new image 2 # Let's check how accurate our model is, using the test datatest_accuracy = classifier_model.score(X_test, y_test)print('Test accuracy: {}%\\n'.format(test_accuracy * 100))Test accuracy: 86.8888888888889%      Now, I can infer from this that my model is 87% likely to recognise a new image correctly. This problem is commonly known as Optical Character Recognition     The above problem is also a good example of a certain type of a Machine Learning problem - Classification problems. We want to classify the images into categories.         A more relatable, but a very similar problem is a spam filter for emails. The goal is simple here: classify my email into either of 2 classes - spam or not spam.     The interesting question is: what are the features for every email sample?         The canIPush program we are trying to build, is also a perfect example of a classification problem.   Supervised Machine Learning Problems   Classification - the goal is to predict a class label, which is a choice from a predefined list of possibilities.  Regression - the goal is to predict a continuous number.Example: Predicting a person’s annual income from their education, their age, and where they live is an example of a regression task. When predicting income, the predicted value is an amount, and can be any number in a given range. ML Workflow  Focus today - Building Supervised Learning Models So what are ML Models?   Models are what make the machines “intelligent”.  They are the algorithms that help the machines learn using the available data, which you can then use as an input/output blackbox to get predictions on real-world input.  You don’t explicitly program the algorithm to answer for the new input. You help it learn from the data samples, and it tries and generalizes it to predict the answer to the new input.Model Complexity, Overfitting and Underfitting  Linear Models for Classification In our example above, we just used a linear classification model to classify our digits data. We used a library function with an in-built machine learning algorithm with a certain set of parameters. But how does these classification models work? It is important to know this to select the right model for the right use case, and also to tune a model with correct parameters. Dhruv will help us answer this question. References Introduction to Machine Learning in Python (IMLP) - https://www.oreilly.com/library/view/introduction-to-machine/9781449369880/ ","categories": ["Tech"],
        "tags": [],
        "url": "http://localhost:4000/ML-Tech-talk/",
        "teaser":"http://localhost:4000/images/avatar.jpg"},{
        "title": "Getting to Yes",
        "excerpt":"Conflict is inevitable. You need to learn how to transform this conflict into side-by-side hard headed problem solving. A standard negotiation has only two stratgies: soft negotiation or hard negotiation. A soft negotiator wants to avoid personal conflicts and thus makes concessions readily to reach agreement. The hard negotiator views it as a contest of wills and ends up producing an equally hard response, which may harm the relationship with the other side. Both strategies leave people dissatisfied, worn out or alienated - and frequently all three. There is a third way to negotiate which is both hard and soft - principled negotiation. The method of Principled Negotiation devleoped at the Harvard Negotiation Project is to decide issues on merits rather than through a process of haggling focused on what each side says it will and won’t do. This method is hard on the merits, soft on the people. It is an all purpose strategy. Unlike almost all other strategies, if the other side learns it, it does not become, more difficult; it becomes easier. Don’t bargain over Positions People routinely engage in positional bargaining where each side takes a position, argues for it, and makes concessions to reach a compromise. Any method of negotiation may be faitly judged by three criteria:   It should provide a wise agreement.  It should be efficient  It should improve, or atleast not damage the relationship between the parties.A wise agreement can be defined as one that meets the legitimate interests of each side to the extent possible, resolves conflicting issues fairly, is durable, and takes community interests into account. Positional bargaining fails to meet the basic criteria of producing a wise agreement, efficiently and amicably. Following are the downsides of positional bargaining:       Arguing over positions produces unwise outcomes     Any agreement reached may reflect a mechanical splitting of the difference between the final positions rather than a solution carefully crafted to meet the legitimate interests of the parties.         Arguing over positions is inefficient     Because both start with an extreme position, stubbornly hold to it, and make concessions only as necessary. It also involves a large number of decisions which is time consuming         It Arguing over positions endangers an ongoing relationship     Because one side often sees itself bending to the rigid will of the other while its own legitiamate concerns go unaddressed.         When there are many parties, positional bargaining is even worse         Being nice is no answer     It leaves you vulnerable to someone who is playing a hard negotiating game.   Principled Negotiation This method can be boiled down to four basic points:   People - Separate the people from the problem  Interests - Focus on interests, not positions  Options - Invent multiple options looking for mutual gains before deciding what to do  Criteria - Insist that the results be based on some objective criteriaSeparate the people from the problem Failing to deal with others as human beings prone to human reactions can be disastrous. Every negotiator has two kinds of interests: in the substance and in the relationship. Disentangle the relationship from the substance; deal directly with the people problem. Deal with people problems by changing how you treat people; don’t try to solve them with substantive concessions. It is useful to think of people problems, in terms of three categories:   Perception  Emotion  CommunicationPerception Ultimately, conflict lies not in the objective reality, but in people’s heads. Truth is simply one more argument for dealing with the difference. The difference itself exists because it exists in their thinking. As useful as looking for objective reality can be, it is ultimately the reality as each side sees it that constitutes the problem in a negotiation and also opens the way to a solution. The ability to see the situation as the other side sees it, as difficult as it may be, is one of the most important skills a negotiator can possess. If you want to influence them, you also need to understand empathetically, the power of their point of view and to feel the emotional force with which they believe in it. Points to keep in mind:       Don’t deduce their intentions from your fears         Don’t blame them for your problem     Even if blaming is justified, it is usually counterproductive. Under attack, the other side will become defensive and will resist what you have to say.         Discuss each other’s perceptions         Look for opportunities to act inconsistently with their perceptions         Give them a stake in the outcome by making sure they participate in the process     This is precisely what people tend to not do. When you have a difficult issue to handle, your instinct is to leave the last part until last. But if you want the other side to accept a disagreeable conclusion, it is crucial that you involve them in the process of reaching that conclusion.         Face-saving     Often in a negotiation people will continue to hold out not because the proposal on the table is inherently unacceptable, but simply because they want to avoid the feeling or the appearance of backing down to the other side. If the substance can be phrased or conceptualized differently so that it seems a fair outcome, they will then accept it. Face-saving involves reconciling an agreement with principle and with the self-image of the negotiators. Its importance should not be underestimated.   Emotion Pay attention to core concerns. Many emotions in negotiations are driven by a core set of five interests:   Autonomy - The desire to make your own choices and control your own fate  Appreciation - The desire to be recognized and valued  Affiliation - The desire to belong as an accepted member of some peer group  Role - The desire to have a meaningful purpose  Status - The desire to be fairly seen and acknowledgedTrampling on these interests tends to generate strong negative emotions. Attending to them can build rapport and a positive climate for problem-solving negotiation. Points to keep in mind:       Consider the role of identity     More specifically, percieved threat to identiy - one’s self-image or self-respect         Make emotions explicit and acknowledge them as legitimate         Allow the other side to let off steam     People obtain psychological release through the simple process of recounting their grievances to an attentive audience         Don’t react to emotional outbursts     Adopt a rule that only one person can get angry at a time         Use symbolic gestures   Communication There are three big problems in communication:   Negotiators may not be talking to each other. Instead, they talk merely to impress third parties or their own constituency.  Even if one is talking directly to the other, the other might not be listening. Instead, he might be busy thinking what to say next, how to respond to that last point or how to frame the next argument, or he may be listening more attentively to his constitiuency than the other side.  What one says, the other might misunderstandWhat to do about these problems?       Listen actively and acknowledge what is being said     Active listening improves not only what you hear but also what they say. If you pay attention and interrupt to say, “Did I understand correctly that you are saying that…?”, the other side will realize that they are not just killing time, not just going through a routine. It has been said that the cheapest concession you can make to the other side is to let them know they have been heard.     Show that you understand them. “Let me see whether I follow what you are telling me. From your point of view, the situation looks like this…”. As you repeat what you understood them to have said, phrase it positively from their point of view, making the strength of their case clear. You might say, “You have a strong case. Let me see if I can explain it. Here’s the way it strikes me…”. Once you have made their case for them, then come back with the problems you find in their proposals. If you can put their case better than they can, and then refute it, you maximize the chance of initiating a constructive dialogue on the merits and minimize the chance of their believing you have misunderstood them.         Speak to be understood     The person you are trying to persuade is seated at the table with you. If a negotiation is to be compared with a legal proceeding, the situation resembles that of two judges trying to reach an agreement on how to decide a case.         Speak about yourself, not about them     It is more persuasive, to describe a problem in terms of its impact on you than in terms of what they did or why: “I feel let down” instead of “You broke your word”. “We feel discriminated against”, rather than “You’re a racist”. If you make a statement about them that they believe is untrue, they will ignore you or get angry; they will not focus on your concern. But a statement about how you feel is difficult to challenge. You convey the same information without provoking a defensive reaction that will prevent them from taking it in.         Speak for a purpose     Before making a significant statement, know what you want to communicate or find out, and what purpose this information will serve.   Focus on Interests, not Positions For a wise solution, reconcile interests, not positions. Interests define the problem The basic problem in a negotiation lies not in conflicting positions, but in the conflict between each side’s needs, desires, concerns, and fears. Such desires and concerns are interests. Interests motivate people; they are the silent movers behind the hubbub of positions. Your position is something you have decided upon. Your interests are what caused you to so decide. Reconciling interests rather than positions works for two reasons:   For every interest there usually exist several possible positions that could satisfy it. All too often people simply adopt the most obvious position. When you do look behind opposed positions for the motivating interests, you can often find an alternative position that meets not only your interests but theirs as well.  Behind opposed positions lie many more interests than conflicting ones. There lie shared and compatible interests, as well as conflicting ones.How do you identify interests A position is likely to be concrete and explicit; the interests underlying it may well be unexpressed, intangible, and perhaps inconsistent.       Ask “Why?”     One basic technique is to put yourself in their shoes. Examine each position they take, and ask yourself “Why?”         Ask “Why not?” Think about their choice     One of the most useful ways to uncover interests is first to identify the basic decision that those on the other side probably see you asking them for, and then to ask yourself why they have not made that decision. What interest of theirs stand in the way?         Realize that each side has multiple interests     Whether it is their emloyer, client, employees, colleagues, family, or spouse, all negotiators have a constituency to whose interests are sensitive. To understand a negotiator’s interests means to understand the variety of somewhat differing interests that they need to take into account.         The most powerful interests are basic human needs, including:           security      economic well-being      a sense of belonging      recognition      control over one’s life            Make a list     To sort out the various interests of each side, it helps to write them down as they occur to you. This will not only help you remember them; it will also enable you to improve the quality of your assessment as you learn new information and to place interests in their estimated order of importance. Furthermore, it may stimulate ideas for how to meet these interests.   Talking about interests The purpose of negotiating is to serve your interests. The chance of that happening increases when you communicate them.       Make you interests come alive     If you go with a raging ulcer to see a doctor, you should not hope for much relief if you describe it as a mild stomachache. It is your job to have the other side understand exactly how important and legitimate your interests are. One guideline is to be specific. Concrete details not only make your description credible, they add impact.     Part of the task of impressing the other side with your interests lies in establishing the legitimacy of those interests. You want them to feel not that you are attacking them personally, but rather that the problem you face legitimately demands attention. You need to convince them that they might well feel the same way if you were in your shoes.         Acknowledge their interests as part of the problem     People listen better if they feel that you have understood them. They tend to think that those who understand them are intelligent and sympathetic people whose own opinions may be worth listening to. In addition to demonstrating that you have understood their interests, it helps to acknowledge that their interests are part of the overall problem you are trying to solve. This is especially easy to do if you have shared interests.         Put the problem before your answer     If you want someone to listen and understand your reasoning, give your interests and reasoning first, and your conclusions or proposals later.         Look forward, not back     Instead of arguing with the other side about the past, talk about what you want to have happen in the future.         Be concrete but flexible     To keep your flexibility, treat each option you formulate as simlply illustrative. Think in terms of more than one option that meets your interests. Much of what positional bargainers hope to achieve with an opening position can be accomplished equally well with an illustrative suggestion that generously takes care of your interest.           For example, in a sports contract negotiation, an agent might say that $500,000 a year would be the kind of money that should satisfy Henderson’s interest in receiving the salary he feels he is worth. Something of the order of a five-year contract should meet his need for job-security         Having thought about your interests, you should go into a meeting not only with one or more specific options that would meet your legitimate interests but also with an open mind. An open mind is not an empty one.         Be hard on the problem, soft on the people     You can be just as hard in talking about your interests as any negotiator can be in talking about their position. In fact, it is usually advisable to be hard. It may not be wise to commit yourself to your position, but it is wise to commit yourself to your interests.     This is the place in a negotiation to spend your aggressive energies. Often the wisest solutions, those that produce the maximum gain for you at the minimum cost to the other side, are produced only by strongly advocating your interests. Two negotiators, each pushing hard for their interests, will often stimulate each other’s creativity in thinking up mutually advantageous solutions.     It is important to separate the people from the problem and attack the problem without blaming the people. Go even further and be personally supportive. This combination of support and vigour may seem inconsistent. Psychologically, it is; the inconsistency helps make it work. A well-known theory of psychology, the theory of cognitive dissonance, holds that people dislike inconsistency and will act to eliminate it.     Successful negotiation requires being both firm and open.   Invent Options for Mutual Gains Skill at inventing options is one of the most useful assets a negotiator can have. Expand the pie before dividing it. In most negotiations there are four major obstacles that inhibit the inventing of an abundance of options: Premature judgement Nothing is so harmful to inventing as a critical sense waiting to pounce on the drawbacks of any new idea. Judgement hinders imagination. Under the pressure of a forthcoming negotiation, your critical sense is likely to be sharper. Practical negotiation appears to call for practical thinking, not wild ideas. Searching for the single answer The first impediment to creative thinking is premature crticism, the second is premature closure. By looking from the outset for the single best answer, you are likely to short-circuit a wiser decision-making process in which you select from a large number of possible answers. The assumption of a fixed pie Why bother to invent at all if all the options are obvious and I can satisfy you only at my own expense? Thinking that solving their problem is their problem Short-sighted self concern thus leads a negotiator to develop only partisan positions, partisan arguments, and one-sided solutions. Following are the solutions to these problems: Separate inventing from deciding Since judgement hinders imagination, separate the creative act from the critical one; separate the process of thinking up possible decisions from the process of selecting among them. Invent first, decide later. As a negotiator, you will of necessity do much inventing by yourself. By definition, inventing new ideas requires you to think about things that are not already in your head. You should therefore consider the desirability of holding a brain-storming session with a few colleagues or friends. The group simply invents ideas without pausing to consider whether they are good, bad, realistic or unrealistic. Guidelines for a successful brainstorming session Before Brainstorming:   Define your purpose - Think of what you would like to walk out of the meeting with.  Choose a few participants - The group should usually be between five and eight people.  Change the environment - Select a time and place distinguishing the session as much as possible from regular discussions. The more different a brainstorming session seems from a normal meeting, the easier it is for participants to suspend judgement.  Design an informal atmosphere - What does it take for you and other to relax?  Choose a facilitator - Someone at the meeting needs to facilitate —&gt; to keep the meeting on track, to make sure everyone gets a chance to speak, to enforce any ground rules, and to stimulate discussion by asking questions.During Brainstorming:       Seat the participants side-by-side facing the problem     The physical reinforces the psychological. Physically sitting side by side can reinforce the mental attitude of tacking a common problem together.         Clarify the ground rules, including the no-criticism rule.     The meeting begins with introduction all around and clarification of ground rules. Outlaw negative criticism of any kind.         Brainstorm     Once the purpose of the meeting is clear, let your imaginations go. Try to come up with a long list of ideas, approaching the question from every conceivable angle.         Record the ideas in full view     Recording the ideas either on a whiteboard or flipcharts gives the group a tangible sense of collective achievement; it reinforces the no-criticism rule; it reduces the tendency to repeat; and it helps stimulate other ideas.   After Brainstorming:   Star the most promising ideas  Invent improvements for promising ideas  Setup a time to evaluate ideas and decideBroaden your options The key to wise decision-making lies in selecting from a great number and variety of options.       Multiply options by shuttling between the specific and the general: The Circle Chart              Look through the eyes of different experts     Generate multiple options by examining the problem from the perspective of different professions and disciplines         Invent agreements of different strengths     You can multiply the number of possible agreements on the table by thinking of “weaker” versions you might want to have on hand in case a sought-for agreement proves beyond reach. Similarly, where a permanent agreement is not possible, perhaps a provisional agreement is. At the very least, if you and the other side cannot reach first-order agreement, you can usually reach second-order agreement — that is, agree on where you disagree, so that you both know the issues in dispute, which are not always obvious.         Change the scope of a proposed agreement     Agreements may be partial, involve fewer parties, cover only selected subject matters, apply only to a certain geographical area, or remain in effect for only a limited period of time.   Look for mutual gains       Identify shared interests     In almost every case, your satisfaction depends to a degree on making the other side sufficiently content with an agreement to want to live up to it. Three points about shared interests are worth remembering.     First, shared interests lie latent in every negotiation. They may not be immediately obvious. Ask yourself: Do we have a shared interest in preserving our relationship? What opportunities lie ahead for cooperation and mutual benefit? What costs would we bear if negotiations broke off? Are there common principles, like a fair price, that we both can respect?     Second, shared interests are opportunities, not godsends. To be of use, you need to make something out of them. It helps to make a shared interest explicit and to formulate it as a shared goal.     Third, stressing your shared interests can make the negotiation smoother and more amicable.         Dovetail differing interests     In many cases, a satisfactory agreement is made possible because each side wants different things. This is genuinely startling if you think about it. People generally assume that differences between two parties create the problem. Yet differences can also lead to a solution. Differences in interests and belief make it possible for an item to be of high benefit to you, yet low cost to the other side.           Different beliefs?      Different values placed on time?      Different predictions or forecasts?      Differences in aversion to risk?        If dovetailing had to be summed up in one sentence, it would be: Look for items that are of low cost to you and high benefit to them, and vice versa. Differences in interests, priorities, beliefs, forecasts, and attitudes toward risk all make dovetailing possible.         Make their decisions easy     However complex the other side’s decisional process may seem, you will understand it better if you pick one person — probably the person with whom you are dealing — and see how the problem looks from his or her point of view. You may come to appreciate your negotiating role in a new light, and see your job, for example, as strengthening that person’s hand or giving her arguments that she will need to persuade others to go along.     ​\tTake a pencil and paper in hand try drafting a few possible agreements. It is never too early in a negotiation to start drafting as an aid to clear thinking. Prepare multiple versions, starting with the simplest possible. What are some of the terms that the other party could sign, terms that would be attractive to them as well as to you? Can you reduce the number of people whose approval would be required? Can you formulate an agreement that will be easy for them to implement?     ​\tBecause most people are strongly influenced be their notions of legitimacy, one effective way to develop solutions easy for the other side to accept is to shape them so that they will appear legitimate. The other side is more likely to accept a solution if it seems the right thing to do — right in terms of being fair, legal, honorable, and hence forth.     ​\tFew things facilitate a decision as much as precedent. Search for it. Look for a decision or statement that the other side may have made in a similar situation, and try to base a proposed agreement on it. This provides an objective standard for your request and makes it easier for them to go along. Recognizing their probable desire to be consistent, thinking about what they have already done or said will help you generate options acceptable to you that also take their point of view into account.         Making threats is not enough     We often try to influence others by threats and warnings of what will happen if they do not decide as we would like. Offers are usually more effective. Concentrate both on making them aware of the consequences they can expect if they do decide as you wish and on improving those consequences from their point of view.     To evaluate an option from the other side’s point of view, consider how they might be criticized if they adopted it. Write out a sentence or two illustrating what the other side’s most powerful critic might say about the decision you are thinking of asking for. Such an exercise will help you appreciate the restraints within which the other side is negotiating. It should help you generate options that will adequately meet their interests so that they can make a decision that meets yours.     A final test of an option is to write it out in the form of a “yes able proposition.” Try to draft a proposal to which their responding with the single word “yes” would be sufficient, realistic, and operational. When you can do so, you will have reduced the risk that you immediate self-interest has blinded you to the necessity of meeting concerns of the other side.   In summary, generate many options before selecting among them. Invent first; decide later. Look for shared interests and differing interests to dovetail. And seek to make their decision easy. Insist on Using Objective Criteria The approach is to commit yourself to reaching a solution based on principle, not pressure. Concentrate on the merits of the problem, not the mettle of the parties. Be open to reason, but closed to threats. Principled negotiation produces wise agreements amicably and efficiently The more you bring standards of fairness, efficiency, or scientific merit to bear on your particular problem, the more likely you are to produce a final package that is wise and fair. The more you and the other side refer to precedent and community practice, the greater your chance of benefitting from past experience. And an agreement consistent with precedent is less vulnerable to attack. A constant battle for dominance threatens a relationship; principled negotiation protects it. It is far easier to deal with people when both of you are discussing objective standards for settling a problem instead of trying to force each other to back down. Approaching agreement through discussion of objective criteria also reduces the number of commitments that each side must make and then unmake as they move toward agreement. In positional bargaining, negotiators spend much of the time defending theri position and attacking the other side’s. People using objective criteria tend to use time more efficiently talking about possible standards and solutions. Developing objective criteria How do you develop objective criteria, and how do you use them in negotiating? Whatever method of negotiation you use, you will do better if you prepare in advance. This certainly holds true of principled negotiation. So develop some alternative standards beforehand and think through their application to your case.       Fair standards     At a minimum, objective criteria need to be independent of each side’s will. Ideally, to assure a wise agreement, objective criteria should not be only independent of will but also both legitimate and practical.         Fair procedures     Consider, for example, the age-old way to divide a piece of cake between two children; one cuts and the other chooses. Neither can complain about an unfair division. A variation on the procedure of “one cuts, the other chooses” is for the parties to negotiate what they think is a fair arrangement before they go on to decide their respective roles in it. As you consider procedural solutions, look at other basic means of settling differences: taking turns, drawing lots, letting someone else decide, and so on. The results may be unequal, but each side had an equal opportunity.   Negotiating with objective criteria There are 3 basic points to remember:       Frame each issue as a joint search for objective criteria.                   Ask “What’s your theory?”                     Agree first on principles         Each principle or standard the other side proposes becomes a lever you can then use to persuade them. Your case will have more impact if it is  presented in terms of ther criteria, and they will find it difficult to resist applying their criteria to the problem. What makes conceding particularly difficult is having to accept someone else’s proposal. If they suggested the standard, their deferring to it is not an act of weakness but an act of strength, of carrying out their word.                   Reason and be open to reason as to which standards are most appropriate and how they should be applied.         Never yield to pressure, only to principle.     Pressure can take many forms: a bribe, a threat, a manipulative appeal to trust, or a simple refusal to budge. In all these cases, the princpled response is the same: invite them to state their reasoning, suggest objective criteria you think apply, and refuse to budge except on this basis. Never yield to pressure, only to principle.   What if they are more powerful In any negotiation there exist realities that are hard to change. In response to power, the most any method of negotiation can do is to meet two objectives: first, to protect you against making an agreement you should reject and second, to help you make the most of the assets you do have so that any agreement you reach will satisfy your interests as well as possible. Protecting yourself       The cost of using a bottom line     Your predetermined bottom line may save you from making a decision you would later regret. But the protection offered by adopting a bottom line involves high costs. It limits your ability to benefit from what you learn during negotiation. A bottom line also inhibits imagination. It reduces the incentive to invent a tailor-made solution that would reconcile differing interests in a way more advantageous for both you and them. A bottom line — by its very nature rigid — is almost certain to be too rigid.         Know your BATNA     The reason you negotiate is to produce something better than the results you can obtain without negotiating. What are your results? What is that alternative? That is the standard against which any proposed agreement should be measured. Your BATNA not only is a better measure but also has the advantage of being flexible enough to permit the exploration of imaginative solutions. Instead of ruling out any solution that does not meet your bottom line, you can compare a proposal with your BATNA to see whether it better satisfies your interests.         The insecurity of an unknown BATNA     If you have not thought carefully about what you will do if you fail to reach an agreement, you are negotiating with your eyes closed. You may, for instance, be too optimistic and assume that you have many other choices. One frequent mistake is psychologically to see your alternatives in the aggregate. In most circumstances, however, the greater danger is that you are too committed to reaching agreement. Not developed any alternative to a negotiated solution, you are unduly pessimistic about what would happen if negotiations broke off.         Formulate a trip wire     Although your BATNA is your true measure by which you should judge any proposed agreement, you may want another test as well. To give you early warning that the content of a possible agreement is beginning to run the risk of being too unattractive, it is useful to identify one far from perfect agreement that is better than your BATNA. Before accepting any agreement worse than the trip-wire package, you should take a break and reexamine the situation. A trip wire should provide you with some margin in reserve.   Making the most of your assets       The better your BATNA, the greater your power     People think of negotiating power as being determined by resources like wealth, political connections, physical strength, friends, and military might. In fact, relative negotiating power of two parties depends primarily upon how attractive to each is the option of not reaching agreement. Think for a moment about how you would feel walking into a job interview with no other job offers — only some uncertain leads. Think how the talk about salary would go. Now contrast that with how you would feel walking in with two other job offers. How would that salary negotiation proceed? The difference is power.         Develop your BATNA     Vigorous exploration of what you do if you do not reach agreement can greatly strengthen your hand. Attractive alternatives are not just sitting there waiting for you; you usually have to develop them. Generating possible BATNAs requires three distinct operations.           Inventing a list of actions you might conceivably take if no agreement is reached      Improving some of the more promising ideas and converting them into practical alternatives      Selecting, tentatively, the one alternative that seems best        The desirability of disclosing your BATNA to the other side depends on your assessment of the other side’s thinking. If your BATNA is extremely attractive — if you have another customer waiting in the next room — it is in your interest to let the other side know. If they think you lack a good alternative when in fact you have one, then you should almost certainly let them know. However, if your best alternative to a negotiated agreement is worse for you than they think, disclosing it will weaken rather than strengthen your hand.         Consider the other side’s BATNA     You should also think about the alternatives to a negotiated agreement available to the other side. The more you can learn of their alternatives, the better prepared you are for negotiation. Knowing their alternatives, you can realistically estimate what you can expect from the negotiation. If they appear to overestimate their BATNA, you will want to help them think through whether their expectations are realistic. If their BATNA is so good they don’t see any need to negotiate on the merits, consider what you can do to change it.     If both sides have attractive BATNAs, the best outcome of the negotiation — for both parties — may well be not to reach agreement. In such cases, a successful negotiation is one in which you and they amicably and efficiently discover that the best way to advance your respective interests is for each of you to look elsewhere and not to try further to reach agreement.         When the other side is powerful     If the other side has big guns, you do not want to turn a negotiation into a gunfight. The stronger they appear in terms of physical or economic power, the more you benefit by negotiating on the merits. To the extent that they have muscle and you have principle, the larger a role you can establish for principle the better off you are. The more easily and happily you can walk away from a negotiation, the greater your capacity to affect its outcome.     Developing your BATNA thus not only enables you to determine what is a minimally acceptable agreement, it will probably raise that minimum. Developing your BATNA is perhaps the most effective course of action you can take in dealing with a seemingly more powerful negotiator.   What if they won’t play? You may attack the problem on its merits; they may attack you. What can you do to turn them away from positions and toward the merits? There are 3 basic approaches for focusing ther attention on the merits. The first centers on what you can do. You yourself can concentrate on the merits, rather than on positions. This is contagious. If this doesn’t work, and they continue to use positional bargaining, you can resort to a second strategy that focuses on what they may do. It counters the basic moves of positional bargaining in ways that direct their attention to the merits. This strategy is called negotiation jujitsu. The third approach focuses on what a third party can do. If neither of the first two approaches work, consider including a third party trained to focus the discussion on interests,  options and criteria. Negotiation Jujitsu If the other side announces a firm position, you may be tempted to criticize and reject it. If they criticize your proposal, you may be tempted to defend it and dig yourself in. If they attack you, you may be tempted to defend yourself and counterattack. In short, if they push hard, you will tend to push back. Yet if you do, you will end up playing the positional bargaining game. DO NOT PUSH BACK. When they assert their positions, do not reject them. When they attack your ideas, don’t defend them. When they attack you, don’t counterattack. Break the viscious cycle by refusing to react. Instead of pushing back, sidestep their attack and deflect it against the problem. As in the Oriental martial arts of judo and jujitsu, avoid pitting your strength against theirs directly; instead, use your skill to step aside and turn their strength to your ends. Rather than resisting their force, channel it into exploring interests, inventing options for mutual gain, and searching for independent standards. Typically their attack will consist of three maneuvers: asserting their position forcefully, attacking your ideas, and attacking you.       Don’t attack their position, look behind it     Seek out and discuss the principles underlying the other side’s positions. To direct their attention toward improving the options on the table, discuss with them hypothetically what would happen if one of their positons was accepted.         Don’t defend your ideas, invite criticism and advice     A lot of time in negotiation is spent criticizing. Rather than resisting the other side’s criticism, invite it. Instead of asking them to accept or reject an idea, ask them what’s wrong with it. Examine their negative judgements to find out their underlying interests and to improve your ideas from their point of view. Rework your ideas and thus turn criticism from being an abstacle in the process of working toward agreement into an essential ingredient of that process.     Another way to channel criticism in a constructive direction is to turn the situation around and ask for their advice. Ask them what they would do if they were in your position.         Recast an attack on you as an attack on the problem     When the other side attacks you personally — as frequently happens — resist the temptation to defend yourself or to attack them. Instead, sit back and allow them to let off steam, Listen to them, show you understand what they are saying, and when they have finished, recast their attack on you as an attack on the problem.         Ask questions and pause     Those involved in negotiation jujitsu use two key tools. The first is to use questions instead of statements. Statements generate resistance, whereas questions generate answers. Silence is one of your best weapons, use it. If they have made an unreasonable proposal or an attack you regard as unjustified, the best thing to do may be to sit there and not say a word.     If you have asked an honest question to which they have provided an insufficient answer, just wait. Silence creates the impression of a stalemate that the other side will feel impelled to break by answering your question or coming up with a new suggestion. When you ask questions, pause. Don’t take them off the hook by going right on with another question or some comment of your own. Some of the most effective negotiating you will ever do is when you are not talking.   Stock phrases you can use for principled negotiation       “Please correct me if I’m wrong”         “We appreciate what you’ve done for us”         “My concern is fairness”         “We would like to settle this on the basis of independent standards, not of who can do what to whom”         “Trust is a separate issue” — This is not a matter of trust. The issue is the principle         “Could I ask you a few questions to see whether my facts are right?”         “What’s the principle behind your action?”         “Let me see if I understand what you’re saying”         “Let me get back to you”         “Let me show you where I have trouble following some of your reasoning”         “One fair solution might be…”         “It’s been a pleasure dealing with you”         “If we agree… if we disagree…”     The trickiest part of the message to communicate is the alternative if no agreement is reached. Try to base the alternative on objective principle by attributing it to someone else. Distance yourself personally from the suggestion. Don’t state it as if you will definitely take action. Instead, leave it as a possibility and emphazise the reluctance to do anything drastic. Finally, try to close by affirming your confidence that a mutually satisfactory agreement will be reached   What if they use dirty tricks Tricky bargaining tactics are in effect one-sided proposals about negotiating procedure, about the negotiating game that the parties are going to play. To counter them, you will want to engage in principled negotiation about the negotiating process. How do you negotiate about the rules of the game? Often just recognizing a tactic will neutralize it. After recognizing the tactic, consider bringing it up with the other side. Apart from that, consider this a meta negotiation and follow the same steps:   Separate the people from the problem  Focus on interests, not positions  Invent options for mutual gain  Insist on using objective criteriaSome common tricky tactics Tricky tactics can be divided into three categories: deliberate deception, psychological warfare, and positional pressure tactics       Deliberate deception - Misinterpretation of facts, authority or intentions                   Phony facts         Unless you have good reason to trust somebody, don’t. Do not let someone treat your doubtsas a personal attack. A practice of verifying factual assertions reduces the incentive for deception, and your risk of being cheated.                     Ambiguous authority         The other side may allow you to believe that they, like you, have full authority to compromise whn they don’t. Before starting on any give-and-take, find out about the authority on the other side. It is perfectly legitimate to inquire, “Just how much authority do you have in this particular negotiation?” If the answer is ambiguous, you may wish to talk to someone with real authority or to make clear that you on your side are reserving equal freedom to reconsider any point.                     Dubious intentions         Where the issue is one of possible misrepresentation of their intentions to comply with the agreement, it is often possible to build compliance features into the agreement itself. Make the problem explicit and use their protestations to get a guarantee.                     Less than full disclosure is not the same as deception         Good faith negotiation does not require total disclosure                   Psychological warfare     These tactics are designed to make you feel uncomfortable, so that you will have a subconscious desire to end the negotiation as soon as possible                   Stressful situations         If you find the physical surroundings detrimental, do not hesitate to say so. You can suggest changing chairs, taking a break, or adjourning to a different location or another time.                     Personal attacks         Recognizing the tactic will help nullify its effect; bringing it up explicitly will probably prevent a recurrence.                     The good-guy/bad-guy routine         If you recognize it, you won’t be taken in. When the good guy makes his pitch, just ask him the same question you asked the bad guy.                     Threats         You can ignore threats; you can take them as unauthorized, spoken in haste, or simply irrelevant. You can also make it risky for the other side to communicate them. Sometimes, threats can also be turned to you political advantage.                   Positional pressure tactics     This kind of bargaining tactic is designed to structure the situation so that only one side can effectively make concessions.                   Refusal to negotiate         This is a negotiating ploy that attempts to use their entry into negotiation as a bargaining chip to obtain some concession on substance. You can communicate, suggest optionsand insist on using principles.                     Extreme demands         Bringing the tactic to their attention works well. Ask for principled justification of their position until it looks ridiculous even to them.                     Escalating demands         Call it to their attention, and take a break. Insist on using principle.                     Lock-in tactics         Lock-ins, like threats, depend on communication. So, you may be able to interrupt the communication to make it ineffective. Alternatively, you can crack a joke and not take the lock-in seriously.                     Hardhearted partner/boss         Recognize the tactic. Rather than discussing it with the other negotiator, you may want to get his agreement to the principle involved involved — perhaps in writing — and then if possible speak directly with the hardhearted partner.                     A calculated delay         In addition to making delaying tactics explicit and negotiating about them, consider creating a fading oppotunity for the other side.                     Take it or leave it         As an alternative to explicitly recognizing the “take it or leave it” tactic and negotiating about it, consider ignoring it at first. Keep talking as if you didn’t hear it, or change the subject, perhaps by introducing other solutions. If you do bring up the tactic specifically, let them know what they have to lose if no agreement is reached and look for a face-saving way, such as a change in circumstances, for them to get out of the situation.             Questions “Can the way I negotiate really make a difference if the other side is more powerful?” AND “How do I enhance my negotiating power?” —&gt; How you negotiate (and how you prepare to negotiate) can make an enormous difference, whatever the relative strengths of each party. 1. Some things you can’t get You should not expect success in negotiation unless you are able to make the other side an offer they find more attractive than their BATNA. If that seems impossible, then negotiation doesn’t make sense. Concentrate instead on improving your BATNA and perhaps changing theirs. 2. How you negotiate makes a big difference In a situation where there is a chance for agreement, the way you negotiate can make the difference between coming to terms and not, or between an outcome that you find favorable and one that is merely acceptable. How you negotiate may determine whether the pie is expanded or merely divided, and whether you have a good relationship with the other side or a strained one. When the other side holds all the cards, how you negotiate is absolutely critical. 3. Resources are not the same as “negotiation power” Negotiation power is the ability to persuade someone to do something. The United States is rich and has lots of nuclear bombs, but neither has been of much help in deterring terrorist actions or freeing hostages when they have been held. Whether your resources give you negotiating power will depend on the context — on whom you are trying to persuade and what you want them to do. 4. Don’t ask who’s more powerful Trying to estimate whether you or your counterparts are more powerful can be risky. In fact, a great deal can be done to ehance your negotiation power even when the resource balance is one-sided. Of course, there will be negotiations where, at least in the short term, the best cards are held by the other side. But in this increasingly interdependent world, there are almost always resources and potential allies that a skilled and persistent negotiator can exploit, at least to move the fulcrum, if not ultimately to tip the balance of power the other way. You won’t find out what’s possible unless you try. The best rule of thumb is to be optimistic — to let your reach exceed your grasp. Without wasting a lot of resources on hopeless causes, recognize that many things are worth trying for even if you may not succeed. Studies of negotiation consistently show a strong correlation between aspiration and result. Within reason, it pays to think positively. 5. There are many sources of negotiation power Negotiation power has a lot of sources. One is having a good BATNA. Provided they believe you, it is persuasive to tell the other side that you have a better alternative.       There is power in developing a good working relationship between the people negotiating     If you understand the other side and they understand you, negotiations are likely to be smoother and more successful for both parties. In this sense, negotiation power is not a zero-sum phenomenon. More negotiation power for the other side does not necessarliy mean less for you.         There is power in effective communication     Good communication is an especially significant source of negotating power. Crafting your message with punch, listening to the other side, and showing that you have heard can all increase your persuasiveness.     It is comparatively easy to listen when the other side is saying something that you agree with. It is harder to listen to things with which you disagree, but that is the very time it is most effective. Listen before you launch into a rebuttal. Inquire. Make sure you understand their view, and make sure they know you understand. Once the other side knows that you understand what they have said, they cannot dismiss your disagreement as simple lack of understanding.     As we know, recognizing a tactic or move allows us to name it and begin an explicit negotiation process. Another way to “change the game” is to change the frame. In other words, move focus in the negotiation from positions to interests, options, or standards. If the other side says, for example, “$10,000 is the most we will pay,” when you think $50,000 would be fair, you could respond in several ways:           Reframe to interests: “I hear that is your position. Given how far that seems below the market price, help me understand your interests. Are you experiencing a serious cash flow crisis?”      Reframe to options: “10,000 is one option, just as $100,000 or $200,000 would be attracive options from our point of view. I think we’ll get a lot further brainstorming options likely to be acceptable and attractive to both of us. What if we were to…?”      Reframe to standards: “You must have good reasons for thinking $10,000 is a fair offer. How did you arrive at that number? Why that number, instead of, say $0 or $100,000? My understanding is that the market price is $50,000. Why should we agree on less?”      Reframe to BATNA: “Of course, that’s your decision to make, and perhaps someone else will accept that. I think we need to think hard now about whether an agreement is possible here that would make sense for both of us.”        One of the greatest powers you have is to reframe, using statements and questions to change the focus of negotiation to interests, options and standards — and thus to change the game from postional bargaining to principled negotiation.         There is power in understanding interests     The more clearly you understand the other side’s concerns, the better able you will be to satisfy them at minimum cost to yourself.         There is power in inventing an elegant option         There is power in using external standards of legitimacy     You can use standards of legitimacy both as a sword to persuade others, and a shield to help you resist pressure to give in arbitrarily         There is power in developing a good BATNA     In addition to improving your overall BATNA, you shouldalso prepare a “micro-BATNA” — if no agreement is reached at THIS MEETING, what is the best outcome? It helps to draft in advance a good exit line to use if a meeting is inconclusive.         There is power in making a carefully crafted commitment     One additional source of persuasive power is the power of making committments. You can use a committment to enhance your negotiating power in three ways: You can commit to what you will do. You can, with care, make a negative committment as to what you will not do. And you can clarify precisely what commitments you would like the other side to make.   6. Make the most of your potential power To make the most of your potential negotiating power, you should use each source of power in harmony with the other sources. Negotiators sometimes look for their strongest source of power and try to use it alone. For example, if a negotiator has a strong BATNA, he or she may confront the other side with it, threatening to walk away unless the last offer is accepted. The total impact of such negotiation power as you have will be greater if each element is used in ways that reinforce the others. You will also be more effective as a negotiator if you believe in what you are saying and doing. Whatever use you are able to make of the ideas in this book, don’t wear them as though you were wearing someone else’s clothes. Cut and fit what we say until you find an approach that both makes sense and is comfortable for you. This may require experimentation and a period od adjustment that is not so comfortable, but in the end, you are likely to maximize your negotiation power if you believe what you say and what you believe. ","categories": ["Books"],
        "tags": [],
        "url": "http://localhost:4000/Getting-to-Yes/",
        "teaser":"http://localhost:4000/images/avatar.jpg"},{
        "title": "Negotiations Workshop",
        "excerpt":"- Instructor: Holly Schroth   If one party feels he/she has lost in a negotiation, then both the parties have lost!  Negotiate in packages, not item by item  Expand the pie by creating value, before dividing it    Before negotiating, create an Aspiration Point package, with all the items that you want from the negotiation  Create a resistance point, which is the minimum you want from this negotiation  Create a BATNA, and also look at the counterpart’s BATNA  One approach during negotiations is: Create an aspiration package. Communicate what is important to you and talk about what is important to them. Negotiate on the whole package and not item by item          Prep Sheet    Common Negotiation Gambits and how to diffuse them  ","categories": ["Learning"],
        "tags": [],
        "url": "http://localhost:4000/Negotiations-Workshop/",
        "teaser":"http://localhost:4000/images/avatar.jpg"},{
        "title": "System Design prep notes",
        "excerpt":"System Design Prep Outline   Requirements, goals and scope          Functional requirements      Non-functional requirements                  Reliability          Availability          Scalability          Latency (Response time)          Throughput (Bandwidth)          Privacy          Security                      Capacity estimation and constraints          Trafffic estimates                  Read-write ratio                    Storage estimates      Bandwidth estimates      Memory estimates (Cache requirements)        System APIs          What type of request      JSON object bodies      Response objects        Database design          Observations about the data                  Billions of records          Each record size          Relationships between records          Read/write heavy                    DB schemas                  Metadata store          Content store (Object storage, file storage, block storage)          Store to have access to content quickly, like timelines                    NoSQL or SQL?        System Design and Algorithm          High level design      Detailed component design                  Application Layer          Database Layer                    Multiple approaches        Data Partition and Replication          Range based      Hash-based, Consistent Hashing        Cache          Cache size      Number of servers to fit cache      Cache eviction policy      Cache invalidation scheme      In memory cache VS (distributed) global cache        In-Process Caching vs. Distributed Caching - DZone Performance     Load balancing          Where all required?      Load balancing algorithm?        Detailed component design  Front-end connection with the backend Thought process General Notes   MD5 hash function returns a 128-bit hash, represented by 32 hexadecimal digits.  Base64 ([a-z], [A-Z], [0-9], +, /) encoding uses 6 bits to represent a character value.  Base64 encoded strings of 6 characters has 68.7B possible strings.      In-memory caches     The most potent–in terms of raw performance–caches you’ll encounter are those which store their entire set of data in memory. Memcached and Redis are both examples of in-memory caches (caveat: Redis can be configured to store some data to disk). This is because accesses to RAM are orders of magnitude faster than those to disk.     On the other hand, you’ll generally have far less RAM available than disk space, so you’ll need a strategy for only keeping the hot subset of your data in your memory cache. The most straightforward strategy is least recently used, and is employed by Memcache (and Redis as of 2.2 can be configured to employ it as well). LRU works by evicting less commonly used data in preference of more frequently used data, and is almost always an appropriate caching strategy.         Put vs Post request:     What’s the difference between a POST and a PUT HTTP REQUEST?   Rough calculations 8 bits = 1 byte1 byte = 1 character4 bytes = 1 integer (Java) $2^{10} bytes = 1KB \\qquad 10^{3} = 1KB $ $2^{20} bytes = 1MB \\qquad 10^{6} = 1MB$ $2^{30} bytes = 1GB \\qquad 10^{9} = 1GB$$ Consistent Hashing Consistent Hashing - Grokking the System Design Interview Drawbacks of commonly used hash-based partitioning (key % n):   Not horizontally scalable, as it requires all k keys to be remapped.  It may not be load balanced as the real data is not uniformly distributed.We use consistent hashing to solve this problem. The idea is simple. We hash all servers, say 5, to an integer in the range, say [0, 256) and place them on a virtual ring. Then to map a given key to a sever, hash the key to a single integer. Move clockwise in the ring and map the key to the first server you encounter. To add a new server, map it to another integer on the ring. Some of the keys from the nearby servers will then move to the new server. If any server fails, all the keys of that server then move to the next server. So, at max, only k/n severs need to be remapped. For load balancing, we add virtual replicas of servers on the ring. Basically instead of mapping the server to just one integer, also map it to several points on the ring. Assuming the hash function to hash servers to integers “mixes well”, the data on these servers will be partitioned uniformly. Key Generation Service (KGS) The application server will store the contents of the paste and the generated key in the database. After the successful insertion, the server can return the key to the user. One possible problem here could be that the insertion fails because of a duplicate key. Since we are generating a random key, there is a possibility that the newly generated key could match an existing one. In that case, we should regenerate a new key and try again. We should keep retrying until we don’t see failure due to the duplicate key. We should return an error to the user if the custom key they have provided is already present in our database. Another solution of the above problem could be to run a standalone Key Generation Service (KGS) that generates random six letters strings beforehand and stores them in a database (let’s call it key-DB).   Whenever we want to store a new paste, we will just take one of the already generated keys and use it. This approach will make things quite simple and fast since we will not be worrying about duplications or collisions. KGS will make sure all the keys inserted in key-DB are unique.  KGS can use two tables to store keys, one for keys that are not used yet and one for all the used keys. As soon as KGS gives some keys to an application server, it can move these to the used keys table.  KGS can always keep some keys in memory so that whenever a server needs them, it can quickly provide them. As soon as KGS loads some keys in memory, it can move them to the used keys table, this way we can make sure each server gets unique keys.  If KGS dies before using all the keys loaded in memory, we will be wasting those keys. We can ignore these keys given that we have a huge number of them.  Isn’t KGS a single point of failure? Yes, it is. To solve this, we can have a standby replica of KGS and whenever the primary server dies it can take over to generate and provide keys.  Can each app server cache some keys from key-DB? Yes, this can surely speed things up. Although in this case, if the application server dies before consuming all the keys, we will end up losing those keys. This could be acceptable since we have 68B unique six letters keys, which are a lot more than we require.Load balancing algorithms There is a variety of load balancing methods, which use different algorithms for different needs.   Least Connection Method — This method directs traffic to the server with the fewest active connections. This approach is quite useful when there are a large number of persistent client connections which are unevenly distributed between the servers.  Least Response Time Method — This algorithm directs traffic to the server with the fewest active connections and the lowest average response time.  Least Bandwidth Method - This method selects the server that is currently serving the least amount of traffic measured in megabits per second (Mbps).  Round Robin Method — This method cycles through a list of servers and sends each new request to the next server. When it reaches the end of the list, it starts over at the beginning. It is most useful when the servers are of equal specification and there are not many persistent connections.  Weighted Round Robin Method — The weighted round-robin scheduling is designed to better handle servers with different processing capacities. Each server is assigned a weight (an integer value that indicates the processing capacity). Servers with higher weights receive new connections before those with less weights and servers with higher weights get more connections than those with less weights.  IP Hash — Under this method, a hash of the IP address of the client is calculated to redirect the request to a server.  Consistent HashingContent Delivery Networks (CDNs) CDNs are a kind of cache that comes into play for sites serving large amounts of static media. In a typical CDN setup, a request will first ask the CDN for a piece of static media; the CDN will serve that content if it has it locally available. If it isn’t available, the CDN will query the back-end servers for the file, cache it locally, and serve it to the requesting user.  Cache invalidation schemes       Write through cache     When “write hit”, update both cache and memory with new data. This scheme prevents data loss during cache failures. But the writes become slower because of doubling the writes.         Write back cache     When “write hit”, update only the cache with new data. Update the storage only when the cache entry is going to get replaced by some other entry. This is done using a dirty bit for every entry. This scheme has a risk of data loss in the case of cache failure.         Write around cache     When “write miss”, update only the storage. This prevents large number of writes into the cache. But if the recently written data is read again, it will have a cache miss.         Write allocation cache     When “write miss”, bring the old data into the cache and update the cache entry. Use this along with either write back or write through.   Cache eviction schemes   Least Recently Used (LRU): Discards the least recently used items first.  Most Recently Used (MRU): Discards, in contrast to LRU, the most recently used items first.  Least Frequently Used (LFU): Counts how often an item is needed. Those that are used least often are discarded first.  Least Frequently Recently Used (LFRU): Privileged and unprivileged sections. Frequently used are in privileged section. Replacement of the privileged partition is done as follows: LFRU evicts content from the unprivileged partition, pushes content from privileged partition to unprivileged partition, and finally inserts new content into the privileged partition  Random Replacement (RR): Randomly selects a candidate item and discards it to make space when necessary.  First In First Out (FIFO): The cache evicts the first block accessed first without any regard to how often or how many times it was accessed before.  Last In First Out (LIFO): The cache evicts the block accessed most recently first without any regard to how often or how many times it was accessed before.Cache coherance In computer architecture, cache coherence is the uniformity of shared resource data that ends up stored in multiple local caches. When clients in a system maintain caches of a common memory resource, problems may arise with incoherent data, which is particularly the case with CPUs in a multiprocessing system. The following are the requirements for cache coherence: Write Propagation - Changes to the data in any cache must be propagated to other copies (of that cache line) in the peer caches. Transaction Serialization - Reads/Writes to a single memory location must be seen by all processors in the same order. Two common protocols used for cache coherence are Snooping protocol and directory based Data partitioning schemes   Horizontal partitioning (Range-based partitioning) → con: non-uniform distribution of data  Vertical partitioning → Feature based partitioning. con: How to further scale if a partitioned server needs to scale.  Hash-based partitioning → con: scaling required remapping → use consistent hashing  Directory-based partitioning → Have a lookup service that maintains a directory of where a particular data entry resides. Pro: can easily scale and change our partitioning scheme. Con: single point of failure, increased complexity.Problems of data partitioning   Joins and denormalization across partitions  Referential integrity across partitions  Rebalancing the partitionsIndexes Indexes are well known when it comes to databases. Sooner or later there comes a time when database performance is no longer satisfactory. One of the very first things you should turn to when that happens is database indexing. The goal of creating an index on a particular table in a database is to make it faster to search through the table and find the row or rows that we want. Indexes can be created using one or more columns of a database table, providing the basis for both rapid random lookups and efficient access of ordered records. SQL - Indexes Single vs Composite Indexes in Relational Databases How does database indexing work? SQL vs NoSQL       Schema     Fixed schema in SQL, dynamic schema in NoSQL. Columns can be added on the fly and a row does not have to contain all the columns.         Scalability     SQL is easy to scale vertically, but complicated to scale horizontally. NoSQL databases are horizontally scalable.         Reliability and ACID compliancy     SQL is a safe bet when it comes to data reliability. Most of the NoSQL solutions sacrifice ACID compliance for scalability and performance.   → When data is structured and not changing very frequently, or when there is a need for an ACID-compliant database for critical data, use SQL. → When you need to scale horizontally to store huge data that is not necessarily structured and still have a fast and seamless database, or when you want to have rapid development and iterations, use NoSQL. Types of NoSQL databases Following are the most common types of NoSQL: Key-Value Stores: Data is stored in an array of key-value pairs. The ‘key’ is an attribute name which is linked to a ‘value’. Well-known key-value stores include Redis, Voldemort, and Dynamo. Document Databases: In these databases, data is stored in documents (instead of rows and columns in a table) and these documents are grouped together in collections. Each document can have an entirely different structure. Document databases include the CouchDB and MongoDB. Wide-Column Databases: Instead of ‘tables,’ in columnar databases we have column families, which are containers for rows. Unlike relational databases, we don’t need to know all the columns up front and each row doesn’t have to have the same number of columns. Columnar databases are best suited for analyzing large datasets - big names include Cassandra and HBase. Graph Databases: These databases are used to store data whose relations are best represented in a graph. Data is saved in graph structures with nodes (entities), properties (information about the entities), and lines (connections between the entities). Examples of graph database include Neo4J and InfiniteGraph. CAP theorem In theoretical computer science, the CAP theorem, also named Brewer’s theorem after computer scientist Eric Brewer, states that it is impossible for a distributed data store to simultaneously provide more than two out of the following three guarantees:   Consistency: Every read receives the most recent write or an error  Availability: Every request receives a (non-error) response, without the guarantee that it contains the most recent write  Partition tolerance: The system continues to operate despite an arbitrary number of messages being dropped (or delayed) by the network between nodesWhen a network partition failure happens should we decide to   Cancel the operation and thus decrease the availability but ensure consistency  Proceed with the operation and thus provide availability but risk inconsistencyThe CAP theorem implies that in the presence of a network partition, one has to choose between consistency and availability. Note that consistency as defined in the CAP theorem is quite different from the consistency guaranteed in ACID database transactions. HTTP Long-Polling This is a variation of the traditional polling technique that allows the server to push information to a client whenever the data is available. With Long-Polling, the client requests information from the server exactly as in normal polling, but with the expectation that the server may not respond immediately. That’s why this technique is sometimes referred to as a “Hanging GET”.   If the server does not have any data available for the client, instead of sending an empty response, the server holds the request and waits until some data becomes available.  Once the data becomes available, a full response is sent to the client. The client then immediately re-request information from the server so that the server will almost always have an available waiting request that it can use to deliver data in response to an event.The basic life cycle of an application using HTTP Long-Polling is as follows:   The client makes an initial request using regular HTTP and then waits for a response.  The server delays its response until an update is available or a timeout has occurred.  When an update is available, the server sends a full response to the client.  The client typically sends a new long-poll request, either immediately upon receiving a response or after a pause to allow an acceptable latency period.  Each Long-Poll request has a timeout. The client has to reconnect periodically after the connection is closed due to timeouts.Server-Sent Events (SSEs) Under SSEs the client establishes a persistent and long-term connection with the server. The server uses this connection to send data to a client. If the client wants to send data to the server, it would require the use of another technology/protocol to do so.   Client requests data from a server using regular HTTP.  The requested webpage opens a connection to the server.  The server sends the data to the client whenever there’s new information available.SSEs are best when we need real-time traffic from the server to the client or if the server is generating data in a loop and will be sending multiple events to the client. WebSockets WebSocket provides Full duplex communication channels over a single TCP connection. It provides a persistent connection between a client and a server that both parties can use to start sending data at any time. The client establishes a WebSocket connection through a process known as the WebSocket handshake. If the process succeeds, then the server and client can exchange data in both directions at any time. The WebSocket protocol enables communication between a client and a server with lower overheads, facilitating real-time data transfer from and to the server. This is made possible by providing a standardized way for the server to send content to the browser without being asked by the client and allowing for messages to be passed back and forth while keeping the connection open. In this way, a two-way (bi-directional) ongoing conversation can take place between a client and a server. ","categories": ["Learning"],
        "tags": [],
        "url": "http://localhost:4000/System-Design-Prep/",
        "teaser":"http://localhost:4000/images/avatar.jpg"}]
